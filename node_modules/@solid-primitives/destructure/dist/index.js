import { getOwner, createMemo, runWithOwner } from 'solid-js';
import { access } from '@solid-primitives/utils';

// src/index.ts
var isReactiveObject = (value) => typeof value === "object" && value !== null;
function createProxyCache(obj, get) {
  return new Proxy(
    {},
    {
      get: (target, key) => {
        if (key === Symbol.iterator || key === "length")
          return Reflect.get(obj, key);
        const saved = Reflect.get(target, key);
        if (saved)
          return saved;
        const value = get(key);
        Reflect.set(target, key, value);
        return value;
      },
      set: () => false
    }
  );
}
function destructure(source, options) {
  const config = options ?? {};
  const memo = config.memo ?? typeof source === "function";
  const getter = typeof source === "function" ? (key) => () => source()[key] : (key) => () => source[key];
  const obj = access(source);
  if (config.lazy) {
    const owner = getOwner();
    return createProxyCache(obj, (key) => {
      const calc = getter(key);
      if (config.deep && isReactiveObject(obj[key]))
        return runWithOwner(owner, () => destructure(calc, { ...config, memo }));
      return memo ? runWithOwner(owner, () => createMemo(calc, void 0, options)) : calc;
    });
  }
  const result = Array.isArray(obj) ? [] : {};
  for (const [key, value] of Object.entries(obj)) {
    const calc = getter(key);
    if (config.deep && isReactiveObject(value))
      result[key] = destructure(calc, { ...config, memo });
    else
      result[key] = memo ? createMemo(calc, void 0, options) : calc;
  }
  return result;
}

export { destructure };
