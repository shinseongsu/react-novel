import { MemoOptions, Accessor } from 'solid-js';
import { Values, AnyFunction, MaybeAccessor, AnyObject } from '@solid-primitives/utils';

type ReactiveSource = [] | any[] | AnyObject;
type DestructureOptions<T extends ReactiveSource> = MemoOptions<Values<T>> & {
    memo?: boolean;
    lazy?: boolean;
    deep?: boolean;
};
type Spread<T extends ReactiveSource> = {
    readonly [K in keyof T]: Accessor<T[K]>;
};
type DeepSpread<T extends ReactiveSource> = {
    readonly [K in keyof T]: T[K] extends ReactiveSource ? T[K] extends AnyFunction ? Accessor<T[K]> : DeepSpread<T[K]> : Accessor<T[K]>;
};
type Destructure<T extends ReactiveSource> = {
    readonly [K in keyof T]-?: Accessor<T[K]>;
};
type DeepDestructure<T extends ReactiveSource> = {
    readonly [K in keyof T]-?: T[K] extends ReactiveSource ? T[K] extends AnyFunction ? Accessor<T[K]> : DeepDestructure<T[K]> : Accessor<T[K]>;
};
/**
 * Destructures an reactive object *(e.g. store or component props)* or a signal of one into a tuple/map of signals for each object key.
 * @param source reactive object or signal returning one
 * @param options memo options + primitive configuration:
 * - `memo` - wraps accessors in `createMemo`, making each property update independently. *(enabled by default for signal source)*
 * - `lazy` - property accessors are created on key read. enable if you want to only a subset of source properties, or use properties initially missing
 * - `deep` - destructure nested objects
 * @returns object of the same keys as the source, but with values turned into accessors.
 * @example // spread tuples
 * const [first, second, third] = destructure(() => [1,2,3])
 * first() // => 1
 * second() // => 2
 * third() // => 3
 * @example // spread objects
 * const { name, age } = destructure({ name: "John", age: 36 })
 * name() // => "John"
 * age() // => 36
 */
declare function destructure<T extends ReactiveSource, O extends DestructureOptions<T>>(source: MaybeAccessor<T>, options?: O): O extends {
    lazy: true;
    deep: true;
} ? DeepDestructure<T> : O["lazy"] extends true ? Destructure<T> : O["deep"] extends true ? DeepSpread<T> : Spread<T>;

export { DeepDestructure, DeepSpread, Destructure, DestructureOptions, Spread, destructure };
