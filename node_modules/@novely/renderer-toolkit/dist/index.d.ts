import { Atom, ReadableAtom, BaseDeepMap, DeepMapStore } from 'nanostores';
export * from 'nanostores';
import { CustomHandler, NovelyScreen, AudioHandle, Renderer, Stored, StorageData, Data, Context, RendererInit, DefaultActionProxy, State, CustomActionHandle, ActionInputOnInputMeta, ActionInputSetup } from '@novely/core';
import { createAudio as createAudio$1 } from 'simple-web-audio';

declare const memo: <T, K>(input: Atom<T>, cb: (value: T) => K) => ReadableAtom<K>;

type AnyFunction = (...args: any[]) => any;
/**
 * @deprecated
 * @todo remove it
 */
type NoInfer<T> = [T][T extends any ? 0 : never];
type Setter<T> = T extends AnyFunction ? () => T : (T | ((prev: T) => T));
type DeepAtom<T extends BaseDeepMap> = DeepMapStore<T> & {
    mutate: <$MutateValue>(getPath: ((object: T) => $MutateValue), setter: Setter<NoInfer<$MutateValue>>) => NoInfer<$MutateValue>;
};
/**
 * Creates a `deepMap` extended with `mutate` method
 *
 * @example
 * ```ts
 * const $user = deepAtom({ age: 16 });
 *
 * $user.mutate((s) => s.age, (age) => age + 1);
 * ```
 */
declare const deepAtom: <$AtomValue extends BaseDeepMap>(init: $AtomValue) => DeepAtom<$AtomValue>;

type Disposable = {
    /**
     * Function that is called after action is completed and game should move forward
     *
     * @example
     * ```ts
     * function handleTextActionClick() {
     *   const { resolve } = contextState.get().text;
     *
     *   // as user clicked on text we will hide text by updating this store
     *   contextState.setKey('text', { content: '' });
     *
     *   // now proceed to go to next action
     *   resolve()
     * }
     * ```
     */
    resolve?: () => void;
};
type WithActionVisibility = {
    /**
     * Used to check if something should be rendered
     */
    visible: boolean;
};
type Labelled = {
    /**
     * Label for the action.
     *
     * In example for Input action it might be "Enter youʼ age", and for Choice action it might be "Select youʼr next move"
     */
    label: string;
};
type ContextStateBackground = {
    /**
     * In-game background image
     */
    background: string;
    /**
     * Function that is NOT provided by core. You can set it yourself.
     */
    clear?: () => void;
};
type ContextStateCharacter = WithActionVisibility & {
    /**
     * Basically `element.style`
     */
    style: string | undefined;
    /**
     * Character removal can be delayed so it could be removed with animation.
     *
     * Storing timeout id is needed to cancel it if in example ShowCharacter was called before time for removal came to the end to prevent character unexpectedly be removed
     */
    hideTimeoutId?: ReturnType<typeof setTimeout>;
};
type ContextStateCharacters = {
    [key: string]: ContextStateCharacter | undefined;
};
type ContextStateCustomHandler = {
    /**
     * Node in which custom action is rendered
     */
    node: null | HTMLDivElement;
    /**
     * Custom Handler function itself
     */
    fn: CustomHandler;
    /**
     * Clear Function. Removes the action.
     */
    clear: () => void;
};
type ContextStateCustomHandlers = {
    [key: string]: ContextStateCustomHandler | undefined;
};
type ContextStateText = Disposable & {
    /**
     * Text to be rendered
     */
    content: string;
};
type ContextStateDialog = Disposable & WithActionVisibility & {
    /**
     * Character lyrics
     */
    content: string;
    /**
     * Character lyrics. It might be also empty
     */
    name: string;
    /**
     * Miniature character rendered along with text
     */
    miniature: {
        /**
         * Character
         */
        character?: string;
        /**
         * Character's emotion
         */
        emotion?: string;
    };
};
type ContextStateInput = Disposable & WithActionVisibility & Labelled & {
    /**
     * Input Element. Input action very dependent on DOM so this is needed
     */
    element: null | HTMLInputElement;
    /**
     * When input validation failed this error message should be shown near input element.
     * When error is present, going to next action should be restricted.
     */
    error: string;
    /**
     * Function that should be called before input action should be removed
     */
    cleanup?: () => void;
};
type ContextStateChoice = WithActionVisibility & Labelled & {
    /**
     * It is an array of choices.
     *
     * First item of choice is a choice text and second one is active it or not.
     * When choice is not action it should be impossible to select that choice.
     */
    choices: [string, boolean][];
    /**
     * Function that is called after choice was made and game should move forward
     * @param selected index
     * @example
     * ```ts
     * function handleChoiceActionSelection() {
     *   const index = document.querySelector('select.choice').selectedIndex;
     *
     *   const { resolve } = contextState.get().choice;
     *
     *   // pass index
     *   resolve(index);
     *
     *   contextState.setKey('choice', { choices: [] });
     * }
     * ```
     */
    resolve?: (selected: number) => void;
};
type ContextStateMeta = {
    /**
     * Is it currently in restoring phase
     */
    restoring: boolean;
    /**
     * Is it in preview mode
     *
     * In this mode game should be un-playable
     */
    preview: boolean;
    /**
     * Is Novely in goingBack state
     */
    goingBack: boolean;
};
/**
 * State which is related to game contexts and contains data about it
 */
type ContextState = {
    /**
     * ShowBackground action.
     */
    background: ContextStateBackground;
    /**
     * Character information.
     */
    characters: ContextStateCharacters;
    /**
     * Text action. Basically shown over other action
     */
    text: ContextStateText;
    /**
     * Dialog action.
     */
    dialog: ContextStateDialog;
    /**
     * Input action.
     */
    input: ContextStateInput;
    /**
     * Choice action.
     */
    choice: ContextStateChoice;
    /**
    * Meta information about current context
    */
    meta: ContextStateMeta;
    /**
     * Custom Action store
     */
    custom: ContextStateCustomHandlers;
};
declare const defaultEmpty$1: {};
type ContextStateStore<Extension extends BaseDeepMap = typeof defaultEmpty$1> = ContextState & Extension;
/**
 * Creates typed context state root
 *
 * @example
 * ```ts
 * const { useContextState, removeContextState } = createContextStateRoot<{ additionalContextProp: number }>(() => {
 *   return {
 *     additionalContextProp: 123
 *   }
 * });
 *
 * // when you want to create or get context state
 * useContextState('id here')
 *
 * // when context state should be removed
 * removeContextState('id here')
 * ```
 */
declare const createContextStateRoot: <Extension extends BaseDeepMap = {}>(getExtension?: () => Extension) => {
    useContextState: (id: string) => DeepAtom<ContextStateStore<Extension>>;
    removeContextState: (id: string) => void;
};

/**
 * State which is related to whole renderer
 */
type RendererState = {
    /**
     * Current screen that should be rendered
     */
    screen: NovelyScreen;
    /**
     * Is loading shown. Unlike screen 'loading', it does not change screen and shown above all layers
     */
    loadingShown: boolean;
    /**
     * Is exit prompt should be shown
     */
    exitPromptShown: boolean;
};
declare const defaultEmpty: {};
type RendererStateStore<Extension extends BaseDeepMap = typeof defaultEmpty> = RendererState & Extension;
/**
 * Helper to make renderer state with default recommended values
 * @param extension Additional object to be merged with default values
 * @returns Store
 * @example
 * ```ts
 * createRenderer(() => {
 *   const rendererState = createRendererState();
 *
 *   return {
 *     ui: {
 *       showScreen(name) {
 *         rendererState.setKey('screen', name)
 *       },
 *       getScreen() {
 *         return rendererState.get().screen;
 *       }
 *     }
 *   }
 * })
 * ```
 */
declare const createRendererState: <Extension extends BaseDeepMap = {}>(extension?: Extension) => DeepAtom<RendererStateStore<Extension>>;

declare const noop: () => void;

/**
 * Unmounts app
 *
 * @example
 * ```ts
 * import { createRoot } from 'react-dom/client';
 *
 * const root = createRoot(document.body);
 *
 * root.render(<App />);
 *
 * // this is we want
 * root.unmount();
 * ```
 */
type StartFunctionUnMountFn = () => void;
/**
 * Mounts app, returns unmount function
 *
 * @example
 * ```ts
 * import { createRoot } from 'react-dom/client';
 *
 * const root = createRoot(document.body);
 *
 * function start() {
 *   root.render(<App />);
 *
 *   return () => {
 *     root.unmount();
 *   }
 * }
 * ```
 */
type StartFunctionMountFn = () => StartFunctionUnMountFn;
/**
 * @example
 * ```ts
 * import { createRoot } from 'react-dom/client';
 *
 * const root = createRoot(document.body);
 *
 * createStartFunction(() => {
 *   root.render(<App />);
 *
 *   return () => {
 *     root.unmount();
 *   }
 * })
 * ```
 */
declare const createStartFunction: (fn: StartFunctionMountFn) => () => {
    unmount: () => void;
};

type AudioMisc = Pick<Renderer['misc'], 'preloadAudioBlocking'>;
type StorageDataStore = Stored<StorageData<string, Data>>;
type KeepAudio = {
    music: Set<string>;
    sounds: Set<string>;
};
/**
 * Audio easy! This implementation uses `simple-web-audio` package under the hood.
 *
 * @example
 * ```ts
 * const audio = createAudio(options.storageData);
 * ```
 */
declare const createAudio: (storageData: StorageDataStore) => {
    context: {
        voice: (source: string) => void;
        voiceStop: () => void;
        music: (source: string, method: "music" | "sound") => AudioHandle;
        clear: () => void;
        destroy: () => void;
        start: () => void;
    };
    clear: (keepAudio: KeepAudio) => void;
    getVolume: (type: "music" | "sound" | "voice") => number;
    getAudio: (type: "music" | "sound" | "voice", src: string) => {
        play(): Promise<void>;
        pause(): Promise<void>;
        reset(): Promise<void>;
        stop(): Promise<void>;
        destroy(): Promise<void>;
        fetch(): Promise<void>;
        readonly playing: boolean;
        readonly destroyed: boolean;
        volume: number;
        loop: boolean;
    };
};
declare const createAudioMisc: () => AudioMisc;

type AudioInstance = ReturnType<typeof createAudio$1>;
type AudioStore = {
    music: Partial<Record<string, AudioInstance>>;
    sound: Partial<Record<string, AudioInstance>>;
    voices: Partial<Record<string, AudioInstance>>;
    voice?: AudioInstance;
};

/**
 * Creates a map of mutable objects
 *
 * todo: practical usage
 *
 * @example
 * ```ts
 * const { useShared, removeShared } = createShared<{ count: number }>(() => {
 *   return {
 *     count: 0
 *   }
 * })
 *
 * useShared('HELLO').count += 1
 * console.log(useShared('HELLO').count) // prints 1
 *
 * useShared('WORLD').count += 1
 * console.log(useShared('WORLD').count) // prints 1 too
 * ```
 */
declare const createShared: <T extends Record<PropertyKey, unknown>>(get: () => T) => {
    useShared: (id: string) => T;
    removeShared: (id: string) => void;
};

/**
 * Creates utilities to manage context's in renderer
 * @example
 * ```ts
 * function renderer(options: RendererInit) {
 *   const { getContextCached, removeContext } = createGetContext();
 *
 *   return {
 *     getContext: getContextCached((key) => {
 *       // return Context
 *       return {}
 *     }),
 *     removeContext: (key) => {
 *       removeContext(key);
 *     }
 *   }
 * }
 * ```
 */
declare const createGetContext: () => {
    getContextCached: (createContext: (key: string) => Context) => (key: string) => Context;
    removeContext: (key: string) => void;
};

/**
 * Simply set root to the context
 * @param getContext Function that returns main context
 * @example
 * ```ts
 * const { root, setRoot } = createRootSetter(() => renderer.getContext(options.mainContextKey));
 *
 * const renderer = {
 *   getContext: getContextCached((key) => {
 *     return {
 *       root: root()
 *     }
 *   }),
 *   ui: {
 *     start: createStartFunction(() => {
 *       // this is just an example, use your library to get the node
 *       const element = document.createElement('div');
 *
 *       document.body.appendChild(element);
 *
 *       setRoot(element);
 *
 *       return () => {
 *         element.remove();
 *       }
 *     })
 *   }
 * }
 * ```
 */
declare const createRootSetter: (getContext: () => Context) => {
    root(): HTMLElement;
    setRoot(root: HTMLElement): void;
};

declare const handleBackgroundAction: ($contextState: DeepAtom<ContextStateStore<Record<PropertyKey, unknown>>>, background: Record<string, string>) => void;
declare const handleDialogAction: ($contextState: DeepAtom<ContextStateStore<Record<PropertyKey, unknown>>>, content: string, name: string, character: string | undefined, emotion: string | undefined, resolve: () => void) => void;
declare const handleChoiceAction: ($contextState: DeepAtom<ContextStateStore<Record<PropertyKey, unknown>>>, label: string, choices: [name: string, active: boolean][], resolve: (selected: number) => void) => void;
declare const handleClearAction: ($rendererState: DeepAtom<RendererStateStore<Record<PropertyKey, unknown>>>, $contextState: DeepAtom<ContextStateStore<Record<PropertyKey, unknown>>>, options: RendererInit<any, any>, context: Context, keep: Set<keyof DefaultActionProxy>, keepCharacters: Set<string>) => void;
/**
 * You must return value returned by this function
 */
declare const handleCustomAction: ($contextState: DeepAtom<ContextStateStore<Record<PropertyKey, unknown>>>, fn: CustomHandler<string, State>) => CustomActionHandle;
declare const handleClearBlockingActions: ($contextState: DeepAtom<ContextStateStore<Record<PropertyKey, unknown>>>, preserve?: "choice" | "dialog" | "input" | "text" | undefined) => void;
declare const handleTextAction: ($contextState: DeepAtom<ContextStateStore<Record<PropertyKey, unknown>>>, content: string, resolve: () => void) => void;
declare const handleInputAction: ($contextState: DeepAtom<ContextStateStore<Record<PropertyKey, unknown>>>, options: RendererInit<any, any>, context: Context, label: string, onInput: (opts: ActionInputOnInputMeta<string, State>) => void, setup: ActionInputSetup, resolve: () => void) => void;
declare const handleVibrateAction: (pattern: VibratePattern) => void;

export { type AudioStore, type ContextState, type ContextStateCharacter, type ContextStateCustomHandler, type ContextStateStore, type DeepAtom, type RendererState, type RendererStateStore, type StartFunctionMountFn, type StartFunctionUnMountFn, createAudio, createAudioMisc, createContextStateRoot, createGetContext, createRendererState, createRootSetter, createShared, createStartFunction, deepAtom, handleBackgroundAction, handleChoiceAction, handleClearAction, handleClearBlockingActions, handleCustomAction, handleDialogAction, handleInputAction, handleTextAction, handleVibrateAction, memo, noop };
