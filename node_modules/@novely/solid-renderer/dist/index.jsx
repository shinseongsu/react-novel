// ../../node_modules/.pnpm/solid-js@1.8.19/node_modules/solid-js/dist/solid.js
var sharedConfig = {
  context: void 0,
  registry: void 0,
  getContextId() {
    return getContextId(this.context.count);
  },
  getNextContextId() {
    return getContextId(this.context.count++);
  }
};
function getContextId(count) {
  const num = String(count), len = num.length - 1;
  return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
}
function setHydrateContext(context) {
  sharedConfig.context = context;
}
function nextHydrateContext() {
  return {
    ...sharedConfig.context,
    id: sharedConfig.getNextContextId(),
    count: 0
  };
}
var equalFn = (a, b) => a === b;
var $PROXY = Symbol("solid-proxy");
var $TRACK = Symbol("solid-track");
var $DEVCOMP = Symbol("solid-dev-component");
var signalOptions = {
  equals: equalFn
};
var ERROR = null;
var runEffects = runQueue;
var STALE = 1;
var PENDING = 2;
var UNOWNED = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
};
var Owner = null;
var Transition = null;
var Scheduler = null;
var ExternalSourceConfig = null;
var Listener = null;
var Updates = null;
var Effects = null;
var ExecCount = 0;
function createRoot(fn, detachedOwner) {
  const listener = Listener, owner = Owner, unowned = fn.length === 0, current = detachedOwner === void 0 ? owner : detachedOwner, root = unowned ? UNOWNED : {
    owned: null,
    cleanups: null,
    context: current ? current.context : null,
    owner: current
  }, updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));
  Owner = root;
  Listener = null;
  try {
    return runUpdates(updateFn, true);
  } finally {
    Listener = listener;
    Owner = owner;
  }
}
function createSignal(value, options) {
  options = options ? Object.assign({}, signalOptions, options) : signalOptions;
  const s = {
    value,
    observers: null,
    observerSlots: null,
    comparator: options.equals || void 0
  };
  const setter = (value2) => {
    if (typeof value2 === "function") {
      if (Transition && Transition.running && Transition.sources.has(s)) value2 = value2(s.tValue);
      else value2 = value2(s.value);
    }
    return writeSignal(s, value2);
  };
  return [readSignal.bind(s), setter];
}
function createComputed(fn, value, options) {
  const c = createComputation(fn, value, true, STALE);
  if (Scheduler && Transition && Transition.running) Updates.push(c);
  else updateComputation(c);
}
function createRenderEffect(fn, value, options) {
  const c = createComputation(fn, value, false, STALE);
  if (Scheduler && Transition && Transition.running) Updates.push(c);
  else updateComputation(c);
}
function createEffect(fn, value, options) {
  runEffects = runUserEffects;
  const c = createComputation(fn, value, false, STALE), s = SuspenseContext && useContext(SuspenseContext);
  if (s) c.suspense = s;
  if (!options || !options.render) c.user = true;
  Effects ? Effects.push(c) : updateComputation(c);
}
function createMemo(fn, value, options) {
  options = options ? Object.assign({}, signalOptions, options) : signalOptions;
  const c = createComputation(fn, value, true, 0);
  c.observers = null;
  c.observerSlots = null;
  c.comparator = options.equals || void 0;
  if (Scheduler && Transition && Transition.running) {
    c.tState = STALE;
    Updates.push(c);
  } else updateComputation(c);
  return readSignal.bind(c);
}
function batch(fn) {
  return runUpdates(fn, false);
}
function untrack(fn) {
  if (!ExternalSourceConfig && Listener === null) return fn();
  const listener = Listener;
  Listener = null;
  try {
    if (ExternalSourceConfig) return ExternalSourceConfig.untrack(fn);
    return fn();
  } finally {
    Listener = listener;
  }
}
function on(deps, fn, options) {
  const isArray = Array.isArray(deps);
  let prevInput;
  let defer2 = options && options.defer;
  return (prevValue) => {
    let input;
    if (isArray) {
      input = Array(deps.length);
      for (let i = 0; i < deps.length; i++) input[i] = deps[i]();
    } else input = deps();
    if (defer2) {
      defer2 = false;
      return prevValue;
    }
    const result = untrack(() => fn(input, prevInput, prevValue));
    prevInput = input;
    return result;
  };
}
function onMount(fn) {
  createEffect(() => untrack(fn));
}
function onCleanup(fn) {
  if (Owner === null) ;
  else if (Owner.cleanups === null) Owner.cleanups = [fn];
  else Owner.cleanups.push(fn);
  return fn;
}
function getOwner() {
  return Owner;
}
function runWithOwner(o, fn) {
  const prev = Owner;
  const prevListener = Listener;
  Owner = o;
  Listener = null;
  try {
    return runUpdates(fn, true);
  } catch (err) {
    handleError(err);
  } finally {
    Owner = prev;
    Listener = prevListener;
  }
}
function startTransition(fn) {
  if (Transition && Transition.running) {
    fn();
    return Transition.done;
  }
  const l = Listener;
  const o = Owner;
  return Promise.resolve().then(() => {
    Listener = l;
    Owner = o;
    let t;
    if (Scheduler || SuspenseContext) {
      t = Transition || (Transition = {
        sources: /* @__PURE__ */ new Set(),
        effects: [],
        promises: /* @__PURE__ */ new Set(),
        disposed: /* @__PURE__ */ new Set(),
        queue: /* @__PURE__ */ new Set(),
        running: true
      });
      t.done || (t.done = new Promise((res) => t.resolve = res));
      t.running = true;
    }
    runUpdates(fn, false);
    Listener = Owner = null;
    return t ? t.done : void 0;
  });
}
var [transPending, setTransPending] = /* @__PURE__ */ createSignal(false);
function useTransition() {
  return [transPending, startTransition];
}
function createContext(defaultValue, options) {
  const id = Symbol("context");
  return {
    id,
    Provider: createProvider(id),
    defaultValue
  };
}
function useContext(context) {
  let value;
  return Owner && Owner.context && (value = Owner.context[context.id]) !== void 0 ? value : context.defaultValue;
}
function children(fn) {
  const children2 = createMemo(fn);
  const memo2 = createMemo(() => resolveChildren(children2()));
  memo2.toArray = () => {
    const c = memo2();
    return Array.isArray(c) ? c : c != null ? [c] : [];
  };
  return memo2;
}
var SuspenseContext;
function readSignal() {
  const runningTransition = Transition && Transition.running;
  if (this.sources && (runningTransition ? this.tState : this.state)) {
    if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);
    else {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(this), false);
      Updates = updates;
    }
  }
  if (Listener) {
    const sSlot = this.observers ? this.observers.length : 0;
    if (!Listener.sources) {
      Listener.sources = [this];
      Listener.sourceSlots = [sSlot];
    } else {
      Listener.sources.push(this);
      Listener.sourceSlots.push(sSlot);
    }
    if (!this.observers) {
      this.observers = [Listener];
      this.observerSlots = [Listener.sources.length - 1];
    } else {
      this.observers.push(Listener);
      this.observerSlots.push(Listener.sources.length - 1);
    }
  }
  if (runningTransition && Transition.sources.has(this)) return this.tValue;
  return this.value;
}
function writeSignal(node, value, isComp) {
  let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
  if (!node.comparator || !node.comparator(current, value)) {
    if (Transition) {
      const TransitionRunning = Transition.running;
      if (TransitionRunning || !isComp && Transition.sources.has(node)) {
        Transition.sources.add(node);
        node.tValue = value;
      }
      if (!TransitionRunning) node.value = value;
    } else node.value = value;
    if (node.observers && node.observers.length) {
      runUpdates(() => {
        for (let i = 0; i < node.observers.length; i += 1) {
          const o = node.observers[i];
          const TransitionRunning = Transition && Transition.running;
          if (TransitionRunning && Transition.disposed.has(o)) continue;
          if (TransitionRunning ? !o.tState : !o.state) {
            if (o.pure) Updates.push(o);
            else Effects.push(o);
            if (o.observers) markDownstream(o);
          }
          if (!TransitionRunning) o.state = STALE;
          else o.tState = STALE;
        }
        if (Updates.length > 1e6) {
          Updates = [];
          if (false) ;
          throw new Error();
        }
      }, false);
    }
  }
  return value;
}
function updateComputation(node) {
  if (!node.fn) return;
  cleanNode(node);
  const time = ExecCount;
  runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
  if (Transition && !Transition.running && Transition.sources.has(node)) {
    queueMicrotask(() => {
      runUpdates(() => {
        Transition && (Transition.running = true);
        Listener = Owner = node;
        runComputation(node, node.tValue, time);
        Listener = Owner = null;
      }, false);
    });
  }
}
function runComputation(node, value, time) {
  let nextValue;
  const owner = Owner, listener = Listener;
  Listener = Owner = node;
  try {
    nextValue = node.fn(value);
  } catch (err) {
    if (node.pure) {
      if (Transition && Transition.running) {
        node.tState = STALE;
        node.tOwned && node.tOwned.forEach(cleanNode);
        node.tOwned = void 0;
      } else {
        node.state = STALE;
        node.owned && node.owned.forEach(cleanNode);
        node.owned = null;
      }
    }
    node.updatedAt = time + 1;
    return handleError(err);
  } finally {
    Listener = listener;
    Owner = owner;
  }
  if (!node.updatedAt || node.updatedAt <= time) {
    if (node.updatedAt != null && "observers" in node) {
      writeSignal(node, nextValue, true);
    } else if (Transition && Transition.running && node.pure) {
      Transition.sources.add(node);
      node.tValue = nextValue;
    } else node.value = nextValue;
    node.updatedAt = time;
  }
}
function createComputation(fn, init, pure, state = STALE, options) {
  const c = {
    fn,
    state,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: init,
    owner: Owner,
    context: Owner ? Owner.context : null,
    pure
  };
  if (Transition && Transition.running) {
    c.state = 0;
    c.tState = state;
  }
  if (Owner === null) ;
  else if (Owner !== UNOWNED) {
    if (Transition && Transition.running && Owner.pure) {
      if (!Owner.tOwned) Owner.tOwned = [c];
      else Owner.tOwned.push(c);
    } else {
      if (!Owner.owned) Owner.owned = [c];
      else Owner.owned.push(c);
    }
  }
  if (ExternalSourceConfig && c.fn) {
    const [track, trigger] = createSignal(void 0, {
      equals: false
    });
    const ordinary = ExternalSourceConfig.factory(c.fn, trigger);
    onCleanup(() => ordinary.dispose());
    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());
    const inTransition = ExternalSourceConfig.factory(c.fn, triggerInTransition);
    c.fn = (x) => {
      track();
      return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);
    };
  }
  return c;
}
function runTop(node) {
  const runningTransition = Transition && Transition.running;
  if ((runningTransition ? node.tState : node.state) === 0) return;
  if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);
  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
  const ancestors = [node];
  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
    if (runningTransition && Transition.disposed.has(node)) return;
    if (runningTransition ? node.tState : node.state) ancestors.push(node);
  }
  for (let i = ancestors.length - 1; i >= 0; i--) {
    node = ancestors[i];
    if (runningTransition) {
      let top = node, prev = ancestors[i + 1];
      while ((top = top.owner) && top !== prev) {
        if (Transition.disposed.has(top)) return;
      }
    }
    if ((runningTransition ? node.tState : node.state) === STALE) {
      updateComputation(node);
    } else if ((runningTransition ? node.tState : node.state) === PENDING) {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(node, ancestors[0]), false);
      Updates = updates;
    }
  }
}
function runUpdates(fn, init) {
  if (Updates) return fn();
  let wait = false;
  if (!init) Updates = [];
  if (Effects) wait = true;
  else Effects = [];
  ExecCount++;
  try {
    const res = fn();
    completeUpdates(wait);
    return res;
  } catch (err) {
    if (!wait) Effects = null;
    Updates = null;
    handleError(err);
  }
}
function completeUpdates(wait) {
  if (Updates) {
    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);
    else runQueue(Updates);
    Updates = null;
  }
  if (wait) return;
  let res;
  if (Transition) {
    if (!Transition.promises.size && !Transition.queue.size) {
      const sources = Transition.sources;
      const disposed = Transition.disposed;
      Effects.push.apply(Effects, Transition.effects);
      res = Transition.resolve;
      for (const e2 of Effects) {
        "tState" in e2 && (e2.state = e2.tState);
        delete e2.tState;
      }
      Transition = null;
      runUpdates(() => {
        for (const d of disposed) cleanNode(d);
        for (const v of sources) {
          v.value = v.tValue;
          if (v.owned) {
            for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);
          }
          if (v.tOwned) v.owned = v.tOwned;
          delete v.tValue;
          delete v.tOwned;
          v.tState = 0;
        }
        setTransPending(false);
      }, false);
    } else if (Transition.running) {
      Transition.running = false;
      Transition.effects.push.apply(Transition.effects, Effects);
      Effects = null;
      setTransPending(true);
      return;
    }
  }
  const e = Effects;
  Effects = null;
  if (e.length) runUpdates(() => runEffects(e), false);
  if (res) res();
}
function runQueue(queue) {
  for (let i = 0; i < queue.length; i++) runTop(queue[i]);
}
function scheduleQueue(queue) {
  for (let i = 0; i < queue.length; i++) {
    const item = queue[i];
    const tasks2 = Transition.queue;
    if (!tasks2.has(item)) {
      tasks2.add(item);
      Scheduler(() => {
        tasks2.delete(item);
        runUpdates(() => {
          Transition.running = true;
          runTop(item);
        }, false);
        Transition && (Transition.running = false);
      });
    }
  }
}
function runUserEffects(queue) {
  let i, userLength = 0;
  for (i = 0; i < queue.length; i++) {
    const e = queue[i];
    if (!e.user) runTop(e);
    else queue[userLength++] = e;
  }
  if (sharedConfig.context) {
    if (sharedConfig.count) {
      sharedConfig.effects || (sharedConfig.effects = []);
      sharedConfig.effects.push(...queue.slice(0, userLength));
      return;
    } else if (sharedConfig.effects) {
      queue = [...sharedConfig.effects, ...queue];
      userLength += sharedConfig.effects.length;
      delete sharedConfig.effects;
    }
    setHydrateContext();
  }
  for (i = 0; i < userLength; i++) runTop(queue[i]);
}
function lookUpstream(node, ignore) {
  const runningTransition = Transition && Transition.running;
  if (runningTransition) node.tState = 0;
  else node.state = 0;
  for (let i = 0; i < node.sources.length; i += 1) {
    const source = node.sources[i];
    if (source.sources) {
      const state = runningTransition ? source.tState : source.state;
      if (state === STALE) {
        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);
      } else if (state === PENDING) lookUpstream(source, ignore);
    }
  }
}
function markDownstream(node) {
  const runningTransition = Transition && Transition.running;
  for (let i = 0; i < node.observers.length; i += 1) {
    const o = node.observers[i];
    if (runningTransition ? !o.tState : !o.state) {
      if (runningTransition) o.tState = PENDING;
      else o.state = PENDING;
      if (o.pure) Updates.push(o);
      else Effects.push(o);
      o.observers && markDownstream(o);
    }
  }
}
function cleanNode(node) {
  let i;
  if (node.sources) {
    while (node.sources.length) {
      const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
      if (obs && obs.length) {
        const n = obs.pop(), s = source.observerSlots.pop();
        if (index < obs.length) {
          n.sourceSlots[s] = index;
          obs[index] = n;
          source.observerSlots[index] = s;
        }
      }
    }
  }
  if (Transition && Transition.running && node.pure) {
    if (node.tOwned) {
      for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);
      delete node.tOwned;
    }
    reset(node, true);
  } else if (node.owned) {
    for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);
    node.owned = null;
  }
  if (node.cleanups) {
    for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();
    node.cleanups = null;
  }
  if (Transition && Transition.running) node.tState = 0;
  else node.state = 0;
}
function reset(node, top) {
  if (!top) {
    node.tState = 0;
    Transition.disposed.add(node);
  }
  if (node.owned) {
    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);
  }
}
function castError(err) {
  if (err instanceof Error) return err;
  return new Error(typeof err === "string" ? err : "Unknown error", {
    cause: err
  });
}
function runErrors(err, fns, owner) {
  try {
    for (const f of fns) f(err);
  } catch (e) {
    handleError(e, owner && owner.owner || null);
  }
}
function handleError(err, owner = Owner) {
  const fns = ERROR && owner && owner.context && owner.context[ERROR];
  const error = castError(err);
  if (!fns) throw error;
  if (Effects) Effects.push({
    fn() {
      runErrors(error, fns, owner);
    },
    state: STALE
  });
  else runErrors(error, fns, owner);
}
function resolveChildren(children2) {
  if (typeof children2 === "function" && !children2.length) return resolveChildren(children2());
  if (Array.isArray(children2)) {
    const results = [];
    for (let i = 0; i < children2.length; i++) {
      const result = resolveChildren(children2[i]);
      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
    }
    return results;
  }
  return children2;
}
function createProvider(id, options) {
  return function provider(props) {
    let res;
    createRenderEffect(() => res = untrack(() => {
      Owner.context = {
        ...Owner.context,
        [id]: props.value
      };
      return children(() => props.children);
    }), void 0);
    return res;
  };
}
function from(producer) {
  const [s, set] = createSignal(void 0, {
    equals: false
  });
  if ("subscribe" in producer) {
    const unsub = producer.subscribe((v) => set(() => v));
    onCleanup(() => "unsubscribe" in unsub ? unsub.unsubscribe() : unsub());
  } else {
    const clean2 = producer(set);
    onCleanup(clean2);
  }
  return s;
}
var FALLBACK = Symbol("fallback");
function dispose(d) {
  for (let i = 0; i < d.length; i++) d[i]();
}
function mapArray(list, mapFn, options = {}) {
  let items = [], mapped = [], disposers = [], len = 0, indexes = mapFn.length > 1 ? [] : null;
  onCleanup(() => dispose(disposers));
  return () => {
    let newItems = list() || [], newLen = newItems.length, i, j;
    newItems[$TRACK];
    return untrack(() => {
      let newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start, end, newEnd, item;
      if (newLen === 0) {
        if (len !== 0) {
          dispose(disposers);
          disposers = [];
          items = [];
          mapped = [];
          len = 0;
          indexes && (indexes = []);
        }
        if (options.fallback) {
          items = [FALLBACK];
          mapped[0] = createRoot((disposer) => {
            disposers[0] = disposer;
            return options.fallback();
          });
          len = 1;
        }
      } else if (len === 0) {
        mapped = new Array(newLen);
        for (j = 0; j < newLen; j++) {
          items[j] = newItems[j];
          mapped[j] = createRoot(mapper);
        }
        len = newLen;
      } else {
        temp = new Array(newLen);
        tempdisposers = new Array(newLen);
        indexes && (tempIndexes = new Array(newLen));
        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++) ;
        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {
          temp[newEnd] = mapped[end];
          tempdisposers[newEnd] = disposers[end];
          indexes && (tempIndexes[newEnd] = indexes[end]);
        }
        newIndices = /* @__PURE__ */ new Map();
        newIndicesNext = new Array(newEnd + 1);
        for (j = newEnd; j >= start; j--) {
          item = newItems[j];
          i = newIndices.get(item);
          newIndicesNext[j] = i === void 0 ? -1 : i;
          newIndices.set(item, j);
        }
        for (i = start; i <= end; i++) {
          item = items[i];
          j = newIndices.get(item);
          if (j !== void 0 && j !== -1) {
            temp[j] = mapped[i];
            tempdisposers[j] = disposers[i];
            indexes && (tempIndexes[j] = indexes[i]);
            j = newIndicesNext[j];
            newIndices.set(item, j);
          } else disposers[i]();
        }
        for (j = start; j < newLen; j++) {
          if (j in temp) {
            mapped[j] = temp[j];
            disposers[j] = tempdisposers[j];
            if (indexes) {
              indexes[j] = tempIndexes[j];
              indexes[j](j);
            }
          } else mapped[j] = createRoot(mapper);
        }
        mapped = mapped.slice(0, len = newLen);
        items = newItems.slice(0);
      }
      return mapped;
    });
    function mapper(disposer) {
      disposers[j] = disposer;
      if (indexes) {
        const [s, set] = createSignal(j);
        indexes[j] = set;
        return mapFn(newItems[j], s);
      }
      return mapFn(newItems[j]);
    }
  };
}
var hydrationEnabled = false;
function createComponent(Comp, props) {
  if (hydrationEnabled) {
    if (sharedConfig.context) {
      const c = sharedConfig.context;
      setHydrateContext(nextHydrateContext());
      const r = untrack(() => Comp(props || {}));
      setHydrateContext(c);
      return r;
    }
  }
  return untrack(() => Comp(props || {}));
}
function trueFn() {
  return true;
}
var propTraps = {
  get(_, property, receiver) {
    if (property === $PROXY) return receiver;
    return _.get(property);
  },
  has(_, property) {
    if (property === $PROXY) return true;
    return _.has(property);
  },
  set: trueFn,
  deleteProperty: trueFn,
  getOwnPropertyDescriptor(_, property) {
    return {
      configurable: true,
      enumerable: true,
      get() {
        return _.get(property);
      },
      set: trueFn,
      deleteProperty: trueFn
    };
  },
  ownKeys(_) {
    return _.keys();
  }
};
function resolveSource(s) {
  return !(s = typeof s === "function" ? s() : s) ? {} : s;
}
function resolveSources() {
  for (let i = 0, length = this.length; i < length; ++i) {
    const v = this[i]();
    if (v !== void 0) return v;
  }
}
function mergeProps(...sources) {
  let proxy = false;
  for (let i = 0; i < sources.length; i++) {
    const s = sources[i];
    proxy = proxy || !!s && $PROXY in s;
    sources[i] = typeof s === "function" ? (proxy = true, createMemo(s)) : s;
  }
  if (proxy) {
    return new Proxy({
      get(property) {
        for (let i = sources.length - 1; i >= 0; i--) {
          const v = resolveSource(sources[i])[property];
          if (v !== void 0) return v;
        }
      },
      has(property) {
        for (let i = sources.length - 1; i >= 0; i--) {
          if (property in resolveSource(sources[i])) return true;
        }
        return false;
      },
      keys() {
        const keys2 = [];
        for (let i = 0; i < sources.length; i++) keys2.push(...Object.keys(resolveSource(sources[i])));
        return [...new Set(keys2)];
      }
    }, propTraps);
  }
  const sourcesMap = {};
  const defined = /* @__PURE__ */ Object.create(null);
  for (let i = sources.length - 1; i >= 0; i--) {
    const source = sources[i];
    if (!source) continue;
    const sourceKeys = Object.getOwnPropertyNames(source);
    for (let i2 = sourceKeys.length - 1; i2 >= 0; i2--) {
      const key = sourceKeys[i2];
      if (key === "__proto__" || key === "constructor") continue;
      const desc = Object.getOwnPropertyDescriptor(source, key);
      if (!defined[key]) {
        defined[key] = desc.get ? {
          enumerable: true,
          configurable: true,
          get: resolveSources.bind(sourcesMap[key] = [desc.get.bind(source)])
        } : desc.value !== void 0 ? desc : void 0;
      } else {
        const sources2 = sourcesMap[key];
        if (sources2) {
          if (desc.get) sources2.push(desc.get.bind(source));
          else if (desc.value !== void 0) sources2.push(() => desc.value);
        }
      }
    }
  }
  const target = {};
  const definedKeys = Object.keys(defined);
  for (let i = definedKeys.length - 1; i >= 0; i--) {
    const key = definedKeys[i], desc = defined[key];
    if (desc && desc.get) Object.defineProperty(target, key, desc);
    else target[key] = desc ? desc.value : void 0;
  }
  return target;
}
function splitProps(props, ...keys2) {
  if ($PROXY in props) {
    const blocked = new Set(keys2.length > 1 ? keys2.flat() : keys2[0]);
    const res = keys2.map((k) => {
      return new Proxy({
        get(property) {
          return k.includes(property) ? props[property] : void 0;
        },
        has(property) {
          return k.includes(property) && property in props;
        },
        keys() {
          return k.filter((property) => property in props);
        }
      }, propTraps);
    });
    res.push(new Proxy({
      get(property) {
        return blocked.has(property) ? void 0 : props[property];
      },
      has(property) {
        return blocked.has(property) ? false : property in props;
      },
      keys() {
        return Object.keys(props).filter((k) => !blocked.has(k));
      }
    }, propTraps));
    return res;
  }
  const otherObject = {};
  const objects = keys2.map(() => ({}));
  for (const propName of Object.getOwnPropertyNames(props)) {
    const desc = Object.getOwnPropertyDescriptor(props, propName);
    const isDefaultDesc = !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;
    let blocked = false;
    let objectIndex = 0;
    for (const k of keys2) {
      if (k.includes(propName)) {
        blocked = true;
        isDefaultDesc ? objects[objectIndex][propName] = desc.value : Object.defineProperty(objects[objectIndex], propName, desc);
      }
      ++objectIndex;
    }
    if (!blocked) {
      isDefaultDesc ? otherObject[propName] = desc.value : Object.defineProperty(otherObject, propName, desc);
    }
  }
  return [...objects, otherObject];
}
var counter = 0;
function createUniqueId() {
  const ctx = sharedConfig.context;
  return ctx ? sharedConfig.getNextContextId() : `cl-${counter++}`;
}
var narrowedError = (name) => `Stale read from <${name}>.`;
function For(props) {
  const fallback = "fallback" in props && {
    fallback: () => props.fallback
  };
  return createMemo(mapArray(() => props.each, props.children, fallback || void 0));
}
function Show(props) {
  const keyed = props.keyed;
  const condition = createMemo(() => props.when, void 0, {
    equals: (a, b) => keyed ? a === b : !a === !b
  });
  return createMemo(() => {
    const c = condition();
    if (c) {
      const child = props.children;
      const fn = typeof child === "function" && child.length > 0;
      return fn ? untrack(() => child(keyed ? c : () => {
        if (!untrack(condition)) throw narrowedError("Show");
        return props.when;
      })) : child;
    }
    return props.fallback;
  }, void 0, void 0);
}
function Switch(props) {
  let keyed = false;
  const equals = (a, b) => (keyed ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2];
  const conditions = children(() => props.children), evalConditions = createMemo(() => {
    let conds = conditions();
    if (!Array.isArray(conds)) conds = [conds];
    for (let i = 0; i < conds.length; i++) {
      const c = conds[i].when;
      if (c) {
        keyed = !!conds[i].keyed;
        return [i, c, conds[i]];
      }
    }
    return [-1];
  }, void 0, {
    equals
  });
  return createMemo(() => {
    const [index, when, cond] = evalConditions();
    if (index < 0) return props.fallback;
    const c = cond.children;
    const fn = typeof c === "function" && c.length > 0;
    return fn ? untrack(() => c(keyed ? when : () => {
      if (untrack(evalConditions)[0] !== index) throw narrowedError("Match");
      return cond.when;
    })) : c;
  }, void 0, void 0);
}
function Match(props) {
  return props;
}

// ../../node_modules/.pnpm/solid-js@1.8.19/node_modules/solid-js/web/dist/web.js
var booleans = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "disabled", "formnovalidate", "hidden", "indeterminate", "inert", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "seamless", "selected"];
var Properties = /* @__PURE__ */ new Set(["className", "value", "readOnly", "formNoValidate", "isMap", "noModule", "playsInline", ...booleans]);
var ChildProperties = /* @__PURE__ */ new Set(["innerHTML", "textContent", "innerText", "children"]);
var Aliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
  className: "class",
  htmlFor: "for"
});
var PropAliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
  class: "className",
  formnovalidate: {
    $: "formNoValidate",
    BUTTON: 1,
    INPUT: 1
  },
  ismap: {
    $: "isMap",
    IMG: 1
  },
  nomodule: {
    $: "noModule",
    SCRIPT: 1
  },
  playsinline: {
    $: "playsInline",
    VIDEO: 1
  },
  readonly: {
    $: "readOnly",
    INPUT: 1,
    TEXTAREA: 1
  }
});
function getPropAlias(prop, tagName) {
  const a = PropAliases[prop];
  return typeof a === "object" ? a[tagName] ? a["$"] : void 0 : a;
}
var DelegatedEvents = /* @__PURE__ */ new Set(["beforeinput", "click", "dblclick", "contextmenu", "focusin", "focusout", "input", "keydown", "keyup", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "pointerdown", "pointermove", "pointerout", "pointerover", "pointerup", "touchend", "touchmove", "touchstart"]);
var SVGNamespace = {
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace"
};
function reconcileArrays(parentNode, a, b) {
  let bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = a[aEnd - 1].nextSibling, map2 = null;
  while (aStart < aEnd || bStart < bEnd) {
    if (a[aStart] === b[bStart]) {
      aStart++;
      bStart++;
      continue;
    }
    while (a[aEnd - 1] === b[bEnd - 1]) {
      aEnd--;
      bEnd--;
    }
    if (aEnd === aStart) {
      const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;
      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);
    } else if (bEnd === bStart) {
      while (aStart < aEnd) {
        if (!map2 || !map2.has(a[aStart])) a[aStart].remove();
        aStart++;
      }
    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
      const node = a[--aEnd].nextSibling;
      parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);
      parentNode.insertBefore(b[--bEnd], node);
      a[aEnd] = b[bEnd];
    } else {
      if (!map2) {
        map2 = /* @__PURE__ */ new Map();
        let i = bStart;
        while (i < bEnd) map2.set(b[i], i++);
      }
      const index = map2.get(a[aStart]);
      if (index != null) {
        if (bStart < index && index < bEnd) {
          let i = aStart, sequence = 1, t;
          while (++i < aEnd && i < bEnd) {
            if ((t = map2.get(a[i])) == null || t !== index + sequence) break;
            sequence++;
          }
          if (sequence > index - bStart) {
            const node = a[aStart];
            while (bStart < index) parentNode.insertBefore(b[bStart++], node);
          } else parentNode.replaceChild(b[bStart++], a[aStart++]);
        } else aStart++;
      } else a[aStart++].remove();
    }
  }
}
var $$EVENTS = "_$DX_DELEGATE";
function render(code, element, init, options = {}) {
  let disposer;
  createRoot((dispose2) => {
    disposer = dispose2;
    element === document ? code() : insert(element, code(), element.firstChild ? null : void 0, init);
  }, options.owner);
  return () => {
    disposer();
    element.textContent = "";
  };
}
function template(html, isCE, isSVG) {
  let node;
  const create = () => {
    const t = document.createElement("template");
    t.innerHTML = html;
    return isSVG ? t.content.firstChild.firstChild : t.content.firstChild;
  };
  const fn = isCE ? () => untrack(() => document.importNode(node || (node = create()), true)) : () => (node || (node = create())).cloneNode(true);
  fn.cloneNode = fn;
  return fn;
}
function delegateEvents(eventNames, document2 = window.document) {
  const e = document2[$$EVENTS] || (document2[$$EVENTS] = /* @__PURE__ */ new Set());
  for (let i = 0, l = eventNames.length; i < l; i++) {
    const name = eventNames[i];
    if (!e.has(name)) {
      e.add(name);
      document2.addEventListener(name, eventHandler);
    }
  }
}
function setAttribute(node, name, value) {
  if (!!sharedConfig.context && node.isConnected) return;
  if (value == null) node.removeAttribute(name);
  else node.setAttribute(name, value);
}
function setAttributeNS(node, namespace, name, value) {
  if (!!sharedConfig.context && node.isConnected) return;
  if (value == null) node.removeAttributeNS(namespace, name);
  else node.setAttributeNS(namespace, name, value);
}
function className(node, value) {
  if (!!sharedConfig.context && node.isConnected) return;
  if (value == null) node.removeAttribute("class");
  else node.className = value;
}
function addEventListener2(node, name, handler, delegate) {
  if (delegate) {
    if (Array.isArray(handler)) {
      node[`$$${name}`] = handler[0];
      node[`$$${name}Data`] = handler[1];
    } else node[`$$${name}`] = handler;
  } else if (Array.isArray(handler)) {
    const handlerFn = handler[0];
    node.addEventListener(name, handler[0] = (e) => handlerFn.call(node, handler[1], e));
  } else node.addEventListener(name, handler);
}
function classList(node, value, prev = {}) {
  const classKeys = Object.keys(value || {}), prevKeys = Object.keys(prev);
  let i, len;
  for (i = 0, len = prevKeys.length; i < len; i++) {
    const key = prevKeys[i];
    if (!key || key === "undefined" || value[key]) continue;
    toggleClassKey(node, key, false);
    delete prev[key];
  }
  for (i = 0, len = classKeys.length; i < len; i++) {
    const key = classKeys[i], classValue = !!value[key];
    if (!key || key === "undefined" || prev[key] === classValue || !classValue) continue;
    toggleClassKey(node, key, true);
    prev[key] = classValue;
  }
  return prev;
}
function style(node, value, prev) {
  if (!value) return prev ? setAttribute(node, "style") : value;
  const nodeStyle = node.style;
  if (typeof value === "string") return nodeStyle.cssText = value;
  typeof prev === "string" && (nodeStyle.cssText = prev = void 0);
  prev || (prev = {});
  value || (value = {});
  let v, s;
  for (s in prev) {
    value[s] == null && nodeStyle.removeProperty(s);
    delete prev[s];
  }
  for (s in value) {
    v = value[s];
    if (v !== prev[s]) {
      nodeStyle.setProperty(s, v);
      prev[s] = v;
    }
  }
  return prev;
}
function spread(node, props = {}, isSVG, skipChildren) {
  const prevProps = {};
  if (!skipChildren) {
    createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));
  }
  createRenderEffect(() => typeof props.ref === "function" && use(props.ref, node));
  createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));
  return prevProps;
}
function use(fn, element, arg) {
  return untrack(() => fn(element, arg));
}
function insert(parent, accessor, marker, initial) {
  if (marker !== void 0 && !initial) initial = [];
  if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
  createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
}
function assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {
  props || (props = {});
  for (const prop in prevProps) {
    if (!(prop in props)) {
      if (prop === "children") continue;
      prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef);
    }
  }
  for (const prop in props) {
    if (prop === "children") {
      if (!skipChildren) insertExpression(node, props.children);
      continue;
    }
    const value = props[prop];
    prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef);
  }
}
function toPropertyName(name) {
  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());
}
function toggleClassKey(node, key, value) {
  const classNames = key.trim().split(/\s+/);
  for (let i = 0, nameLen = classNames.length; i < nameLen; i++) node.classList.toggle(classNames[i], value);
}
function assignProp(node, prop, value, prev, isSVG, skipRef) {
  let isCE, isProp, isChildProp, propAlias, forceProp;
  if (prop === "style") return style(node, value, prev);
  if (prop === "classList") return classList(node, value, prev);
  if (value === prev) return prev;
  if (prop === "ref") {
    if (!skipRef) value(node);
  } else if (prop.slice(0, 3) === "on:") {
    const e = prop.slice(3);
    prev && node.removeEventListener(e, prev);
    value && node.addEventListener(e, value);
  } else if (prop.slice(0, 10) === "oncapture:") {
    const e = prop.slice(10);
    prev && node.removeEventListener(e, prev, true);
    value && node.addEventListener(e, value, true);
  } else if (prop.slice(0, 2) === "on") {
    const name = prop.slice(2).toLowerCase();
    const delegate = DelegatedEvents.has(name);
    if (!delegate && prev) {
      const h = Array.isArray(prev) ? prev[0] : prev;
      node.removeEventListener(name, h);
    }
    if (delegate || value) {
      addEventListener2(node, name, value, delegate);
      delegate && delegateEvents([name]);
    }
  } else if (prop.slice(0, 5) === "attr:") {
    setAttribute(node, prop.slice(5), value);
  } else if ((forceProp = prop.slice(0, 5) === "prop:") || (isChildProp = ChildProperties.has(prop)) || !isSVG && ((propAlias = getPropAlias(prop, node.tagName)) || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes("-"))) {
    if (forceProp) {
      prop = prop.slice(5);
      isProp = true;
    } else if (!!sharedConfig.context && node.isConnected) return value;
    if (prop === "class" || prop === "className") className(node, value);
    else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;
    else node[propAlias || prop] = value;
  } else {
    const ns = isSVG && prop.indexOf(":") > -1 && SVGNamespace[prop.split(":")[0]];
    if (ns) setAttributeNS(node, ns, prop, value);
    else setAttribute(node, Aliases[prop] || prop, value);
  }
  return value;
}
function eventHandler(e) {
  const key = `$$${e.type}`;
  let node = e.composedPath && e.composedPath()[0] || e.target;
  if (e.target !== node) {
    Object.defineProperty(e, "target", {
      configurable: true,
      value: node
    });
  }
  Object.defineProperty(e, "currentTarget", {
    configurable: true,
    get() {
      return node || document;
    }
  });
  if (sharedConfig.registry && !sharedConfig.done) sharedConfig.done = _$HY.done = true;
  while (node) {
    const handler = node[key];
    if (handler && !node.disabled) {
      const data = node[`${key}Data`];
      data !== void 0 ? handler.call(node, data, e) : handler.call(node, e);
      if (e.cancelBubble) return;
    }
    node = node._$host || node.parentNode || node.host;
  }
}
function insertExpression(parent, value, current, marker, unwrapArray) {
  const hydrating = !!sharedConfig.context && parent.isConnected;
  if (hydrating) {
    !current && (current = [...parent.childNodes]);
    let cleaned = [];
    for (let i = 0; i < current.length; i++) {
      const node = current[i];
      if (node.nodeType === 8 && node.data.slice(0, 2) === "!$") node.remove();
      else cleaned.push(node);
    }
    current = cleaned;
  }
  while (typeof current === "function") current = current();
  if (value === current) return current;
  const t = typeof value, multi = marker !== void 0;
  parent = multi && current[0] && current[0].parentNode || parent;
  if (t === "string" || t === "number") {
    if (hydrating) return current;
    if (t === "number") {
      value = value.toString();
      if (value === current) return current;
    }
    if (multi) {
      let node = current[0];
      if (node && node.nodeType === 3) {
        node.data !== value && (node.data = value);
      } else node = document.createTextNode(value);
      current = cleanChildren(parent, current, marker, node);
    } else {
      if (current !== "" && typeof current === "string") {
        current = parent.firstChild.data = value;
      } else current = parent.textContent = value;
    }
  } else if (value == null || t === "boolean") {
    if (hydrating) return current;
    current = cleanChildren(parent, current, marker);
  } else if (t === "function") {
    createRenderEffect(() => {
      let v = value();
      while (typeof v === "function") v = v();
      current = insertExpression(parent, v, current, marker);
    });
    return () => current;
  } else if (Array.isArray(value)) {
    const array = [];
    const currentArray = current && Array.isArray(current);
    if (normalizeIncomingArray(array, value, current, unwrapArray)) {
      createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));
      return () => current;
    }
    if (hydrating) {
      if (!array.length) return current;
      if (marker === void 0) return [...parent.childNodes];
      let node = array[0];
      let nodes = [node];
      while ((node = node.nextSibling) !== marker) nodes.push(node);
      return current = nodes;
    }
    if (array.length === 0) {
      current = cleanChildren(parent, current, marker);
      if (multi) return current;
    } else if (currentArray) {
      if (current.length === 0) {
        appendNodes(parent, array, marker);
      } else reconcileArrays(parent, current, array);
    } else {
      current && cleanChildren(parent);
      appendNodes(parent, array);
    }
    current = array;
  } else if (value.nodeType) {
    if (hydrating && value.parentNode) return current = multi ? [value] : value;
    if (Array.isArray(current)) {
      if (multi) return current = cleanChildren(parent, current, marker, value);
      cleanChildren(parent, current, null, value);
    } else if (current == null || current === "" || !parent.firstChild) {
      parent.appendChild(value);
    } else parent.replaceChild(value, parent.firstChild);
    current = value;
  } else ;
  return current;
}
function normalizeIncomingArray(normalized, array, current, unwrap) {
  let dynamic = false;
  for (let i = 0, len = array.length; i < len; i++) {
    let item = array[i], prev = current && current[normalized.length], t;
    if (item == null || item === true || item === false) ;
    else if ((t = typeof item) === "object" && item.nodeType) {
      normalized.push(item);
    } else if (Array.isArray(item)) {
      dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;
    } else if (t === "function") {
      if (unwrap) {
        while (typeof item === "function") item = item();
        dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev) ? prev : [prev]) || dynamic;
      } else {
        normalized.push(item);
        dynamic = true;
      }
    } else {
      const value = String(item);
      if (prev && prev.nodeType === 3 && prev.data === value) normalized.push(prev);
      else normalized.push(document.createTextNode(value));
    }
  }
  return dynamic;
}
function appendNodes(parent, array, marker = null) {
  for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);
}
function cleanChildren(parent, current, marker, replacement) {
  if (marker === void 0) return parent.textContent = "";
  const node = replacement || document.createTextNode("");
  if (current.length) {
    let inserted = false;
    for (let i = current.length - 1; i >= 0; i--) {
      const el = current[i];
      if (node !== el) {
        const isParent = el.parentNode === parent;
        if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
        else isParent && el.remove();
      } else inserted = true;
    }
  } else parent.insertBefore(node, marker);
  return [node];
}
var RequestContext = Symbol();
var isServer = false;
var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
function createElement(tagName, isSVG = false) {
  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);
}
function Portal(props) {
  const {
    useShadow
  } = props, marker = document.createTextNode(""), mount = () => props.mount || document.body, owner = getOwner();
  let content;
  let hydrating = !!sharedConfig.context;
  createEffect(() => {
    if (hydrating) getOwner().user = hydrating = false;
    content || (content = runWithOwner(owner, () => createMemo(() => props.children)));
    const el = mount();
    if (el instanceof HTMLHeadElement) {
      const [clean2, setClean] = createSignal(false);
      const cleanup = () => setClean(true);
      createRoot((dispose2) => insert(el, () => !clean2() ? content() : dispose2(), null));
      onCleanup(cleanup);
    } else {
      const container = createElement(props.isSVG ? "g" : "div", props.isSVG), renderRoot = useShadow && container.attachShadow ? container.attachShadow({
        mode: "open"
      }) : container;
      Object.defineProperty(container, "_$host", {
        get() {
          return marker.parentNode;
        },
        configurable: true
      });
      insert(renderRoot, content);
      el.appendChild(container);
      props.ref && props.ref(container);
      onCleanup(() => el.removeChild(container));
    }
  }, void 0, {
    render: !hydrating
  });
  return marker;
}

// ../../node_modules/.pnpm/nanostores@0.11.2/node_modules/nanostores/task/index.js
var tasks = 0;
function cleanTasks() {
  tasks = 0;
}

// ../../node_modules/.pnpm/nanostores@0.11.2/node_modules/nanostores/clean-stores/index.js
var clean = Symbol("clean");
var cleanStores = (...stores) => {
  if (false) {
    throw new Error(
      "cleanStores() can be used only during development or tests"
    );
  }
  cleanTasks();
  for (let $store of stores) {
    if ($store) {
      if ($store.mocked) delete $store.mocked;
      if ($store[clean]) $store[clean]();
    }
  }
};

// ../../node_modules/.pnpm/nanostores@0.11.2/node_modules/nanostores/atom/index.js
var listenerQueue = [];
var lqIndex = 0;
var QUEUE_ITEMS_PER_LISTENER = 4;
var epoch = 0;
var atom = (initialValue) => {
  let listeners = [];
  let $atom = {
    get() {
      if (!$atom.lc) {
        $atom.listen(() => {
        })();
      }
      return $atom.value;
    },
    lc: 0,
    listen(listener) {
      $atom.lc = listeners.push(listener);
      return () => {
        for (let i = lqIndex + QUEUE_ITEMS_PER_LISTENER; i < listenerQueue.length; ) {
          if (listenerQueue[i] === listener) {
            listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER);
          } else {
            i += QUEUE_ITEMS_PER_LISTENER;
          }
        }
        let index = listeners.indexOf(listener);
        if (~index) {
          listeners.splice(index, 1);
          if (!--$atom.lc) $atom.off();
        }
      };
    },
    notify(oldValue, changedKey) {
      epoch++;
      let runListenerQueue = !listenerQueue.length;
      for (let listener of listeners) {
        listenerQueue.push(
          listener,
          $atom.value,
          oldValue,
          changedKey
        );
      }
      if (runListenerQueue) {
        for (lqIndex = 0; lqIndex < listenerQueue.length; lqIndex += QUEUE_ITEMS_PER_LISTENER) {
          listenerQueue[lqIndex](
            listenerQueue[lqIndex + 1],
            listenerQueue[lqIndex + 2],
            listenerQueue[lqIndex + 3]
          );
        }
        listenerQueue.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(newValue) {
      let oldValue = $atom.value;
      if (oldValue !== newValue) {
        $atom.value = newValue;
        $atom.notify(oldValue);
      }
    },
    subscribe(listener) {
      let unbind = $atom.listen(listener);
      listener($atom.value);
      return unbind;
    },
    value: initialValue
  };
  if (true) {
    $atom[clean] = () => {
      listeners = [];
      $atom.lc = 0;
      $atom.off();
    };
  }
  return $atom;
};

// ../../node_modules/.pnpm/nanostores@0.11.2/node_modules/nanostores/lifecycle/index.js
var MOUNT = 5;
var UNMOUNT = 6;
var REVERT_MUTATION = 10;
var on2 = (object, listener, eventKey, mutateStore) => {
  object.events = object.events || {};
  if (!object.events[eventKey + REVERT_MUTATION]) {
    object.events[eventKey + REVERT_MUTATION] = mutateStore((eventProps) => {
      object.events[eventKey].reduceRight((event, l) => (l(event), event), {
        shared: {},
        ...eventProps
      });
    });
  }
  object.events[eventKey] = object.events[eventKey] || [];
  object.events[eventKey].push(listener);
  return () => {
    let currentListeners = object.events[eventKey];
    let index = currentListeners.indexOf(listener);
    currentListeners.splice(index, 1);
    if (!currentListeners.length) {
      delete object.events[eventKey];
      object.events[eventKey + REVERT_MUTATION]();
      delete object.events[eventKey + REVERT_MUTATION];
    }
  };
};
var STORE_UNMOUNT_DELAY = 1e3;
var onMount2 = ($store, initialize) => {
  let listener = (payload) => {
    let destroy = initialize(payload);
    if (destroy) $store.events[UNMOUNT].push(destroy);
  };
  return on2($store, listener, MOUNT, (runListeners) => {
    let originListen = $store.listen;
    $store.listen = (...args) => {
      if (!$store.lc && !$store.active) {
        $store.active = true;
        runListeners();
      }
      return originListen(...args);
    };
    let originOff = $store.off;
    $store.events[UNMOUNT] = [];
    $store.off = () => {
      originOff();
      setTimeout(() => {
        if ($store.active && !$store.lc) {
          $store.active = false;
          for (let destroy of $store.events[UNMOUNT]) destroy();
          $store.events[UNMOUNT] = [];
        }
      }, STORE_UNMOUNT_DELAY);
    };
    if (true) {
      let originClean = $store[clean];
      $store[clean] = () => {
        for (let destroy of $store.events[UNMOUNT]) destroy();
        $store.events[UNMOUNT] = [];
        $store.active = false;
        originClean();
      };
    }
    return () => {
      $store.listen = originListen;
      $store.off = originOff;
    };
  });
};

// ../../node_modules/.pnpm/nanostores@0.11.2/node_modules/nanostores/deep-map/path.js
function getPath(obj, path) {
  let allKeys = getAllKeysFromPath(path);
  let res = obj;
  for (let key of allKeys) {
    if (res === void 0) {
      break;
    }
    res = res[key];
  }
  return res;
}
function setPath(obj, path, value) {
  return setByKey(obj != null ? obj : {}, getAllKeysFromPath(path), value);
}
function setByKey(obj, splittedKeys, value) {
  let key = splittedKeys[0];
  let copy = Array.isArray(obj) ? [...obj] : { ...obj };
  if (splittedKeys.length === 1) {
    if (value === void 0) {
      if (Array.isArray(copy)) {
        copy.splice(key, 1);
      } else {
        delete copy[key];
      }
    } else {
      copy[key] = value;
    }
    return copy;
  }
  ensureKey(copy, key, splittedKeys[1]);
  copy[key] = setByKey(copy[key], splittedKeys.slice(1), value);
  return copy;
}
var ARRAY_INDEX = /(.*)\[(\d+)\]/;
function getAllKeysFromPath(path) {
  return path.split(".").flatMap((key) => getKeyAndIndicesFromKey(key));
}
function getKeyAndIndicesFromKey(key) {
  if (ARRAY_INDEX.test(key)) {
    let [, keyPart, index] = key.match(ARRAY_INDEX);
    return [...getKeyAndIndicesFromKey(keyPart), index];
  }
  return [key];
}
var IS_NUMBER = /^\d+$/;
function ensureKey(obj, key, nextKey) {
  if (key in obj) {
    return;
  }
  let isNum = IS_NUMBER.test(nextKey);
  if (isNum) {
    obj[key] = Array(parseInt(nextKey, 10) + 1);
  } else {
    obj[key] = {};
  }
}

// ../../node_modules/.pnpm/nanostores@0.11.2/node_modules/nanostores/deep-map/index.js
function deepMap(initial = {}) {
  let $deepMap = atom(initial);
  $deepMap.setKey = (key, value) => {
    if (getPath($deepMap.value, key) !== value) {
      let oldValue = $deepMap.value;
      $deepMap.value = setPath($deepMap.value, key, value);
      $deepMap.notify(oldValue, key);
    }
  };
  return $deepMap;
}

// ../../node_modules/.pnpm/dequal@2.0.3/node_modules/dequal/dist/index.mjs
var has = Object.prototype.hasOwnProperty;
function find(iter, tar, key) {
  for (key of iter.keys()) {
    if (dequal(key, tar)) return key;
  }
}
function dequal(foo, bar) {
  var ctor, len, tmp;
  if (foo === bar) return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date) return foo.getTime() === bar.getTime();
    if (ctor === RegExp) return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len])) ;
      }
      return len === -1;
    }
    if (ctor === Set) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len;
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp) return false;
        }
        if (!bar.has(tmp)) return false;
      }
      return true;
    }
    if (ctor === Map) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len[0];
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp) return false;
        }
        if (!dequal(len[1], bar.get(tmp))) {
          return false;
        }
      }
      return true;
    }
    if (ctor === ArrayBuffer) {
      foo = new Uint8Array(foo);
      bar = new Uint8Array(bar);
    } else if (ctor === DataView) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo.getInt8(len) === bar.getInt8(len)) ;
      }
      return len === -1;
    }
    if (ArrayBuffer.isView(foo)) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo[len] === bar[len]) ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}

// ../../node_modules/.pnpm/yocto-queue@1.1.1/node_modules/yocto-queue/index.js
var Node = class {
  value;
  next;
  constructor(value) {
    this.value = value;
  }
};
var Queue = class {
  #head;
  #tail;
  #size;
  constructor() {
    this.clear();
  }
  enqueue(value) {
    const node = new Node(value);
    if (this.#head) {
      this.#tail.next = node;
      this.#tail = node;
    } else {
      this.#head = node;
      this.#tail = node;
    }
    this.#size++;
  }
  dequeue() {
    const current = this.#head;
    if (!current) {
      return;
    }
    this.#head = this.#head.next;
    this.#size--;
    return current.value;
  }
  peek() {
    if (!this.#head) {
      return;
    }
    return this.#head.value;
  }
  clear() {
    this.#head = void 0;
    this.#tail = void 0;
    this.#size = 0;
  }
  get size() {
    return this.#size;
  }
  *[Symbol.iterator]() {
    let current = this.#head;
    while (current) {
      yield current.value;
      current = current.next;
    }
  }
};

// ../../node_modules/.pnpm/p-limit@6.1.0/node_modules/p-limit/index.js
function pLimit(concurrency) {
  validateConcurrency(concurrency);
  const queue = new Queue();
  let activeCount = 0;
  const resumeNext = () => {
    if (activeCount < concurrency && queue.size > 0) {
      queue.dequeue()();
      activeCount++;
    }
  };
  const next = () => {
    activeCount--;
    resumeNext();
  };
  const run = async (function_, resolve, arguments_) => {
    const result = (async () => function_(...arguments_))();
    resolve(result);
    try {
      await result;
    } catch {
    }
    next();
  };
  const enqueue = (function_, resolve, arguments_) => {
    new Promise((internalResolve) => {
      queue.enqueue(internalResolve);
    }).then(
      run.bind(void 0, function_, resolve, arguments_)
    );
    (async () => {
      await Promise.resolve();
      if (activeCount < concurrency) {
        resumeNext();
      }
    })();
  };
  const generator = (function_, ...arguments_) => new Promise((resolve) => {
    enqueue(function_, resolve, arguments_);
  });
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.size
    },
    clearQueue: {
      value() {
        queue.clear();
      }
    },
    concurrency: {
      get: () => concurrency,
      set(newConcurrency) {
        validateConcurrency(newConcurrency);
        concurrency = newConcurrency;
        queueMicrotask(() => {
          while (activeCount < concurrency && queue.size > 0) {
            resumeNext();
          }
        });
      }
    }
  });
  return generator;
}
function validateConcurrency(concurrency) {
  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  }
}

// ../../node_modules/.pnpm/simple-web-audio@0.7.0_postcss@8.4.32/node_modules/simple-web-audio/dist/index.mjs
var waitForInteraction = (() => {
  const { promise, resolve } = Promise.withResolvers();
  const onUserInteraction = () => {
    resolve();
  };
  document.addEventListener("touchstart", onUserInteraction, { once: true });
  document.addEventListener("touchend", onUserInteraction, { once: true });
  document.addEventListener("click", onUserInteraction, { once: true });
  document.addEventListener("keydown", onUserInteraction, { once: true });
  return () => {
    return promise;
  };
})();
var BLUR_HANDLERS = /* @__PURE__ */ new Set();
var FOCUS_HANDLERS = /* @__PURE__ */ new Set();
var registerEventListeners = (listeners) => {
  BLUR_HANDLERS.add(listeners.blur);
  FOCUS_HANDLERS.add(listeners.focus);
  return () => {
    BLUR_HANDLERS.delete(listeners.blur);
    FOCUS_HANDLERS.delete(listeners.focus);
  };
};
addEventListener("focus", function(event) {
  for (const handler of FOCUS_HANDLERS) {
    try {
      handler.call(this.document, event);
    } catch {
    }
  }
});
addEventListener("blur", function(event) {
  for (const handler of BLUR_HANDLERS) {
    try {
      handler.call(this.document, event);
    } catch {
    }
  }
});
var createQueue = (queue, stopped = false) => {
  const limit = pLimit(1);
  const run = async () => {
    const items = queue.slice();
    for await (const item of items) {
      if (stopped) break;
      try {
        await item();
      } catch (error) {
        console.error(error);
        stopped = true;
      }
    }
    queue = queue.filter((item) => !items.includes(item));
    stopped = false;
  };
  return {
    get queue() {
      return queue;
    },
    set queue(value) {
      queue = value;
    },
    stop() {
      stopped = true;
    },
    execute: () => {
      return limit(run);
    }
  };
};
var createMemo2 = () => {
  const cache = /* @__PURE__ */ new Map();
  return (key, fn) => {
    return () => {
      const preserved = cache.get(key);
      if (preserved) {
        return preserved;
      }
      const promise = fn();
      cache.set(key, promise);
      return promise;
    };
  };
};
var fetcherMemo = createMemo2();
var decoderMemo = createMemo2();
var createAudio = (options) => {
  let audioContext;
  let gainNode;
  let bufferSource;
  let arrayBuffer;
  let audioBuffer;
  let pendingVolume = options.volume || 1;
  let pendingLoop = options.loop || false;
  const createAudioContext = () => {
    audioContext = new AudioContext();
  };
  const getGainNode = () => {
    return gainNode;
  };
  const createGainNode = () => {
    gainNode = audioContext.createGain();
    const node = (options.extendAudioGraph || getGainNode)({
      context: audioContext,
      node: gainNode
    });
    node.connect(audioContext.destination);
  };
  const createBufferSource = () => {
    bufferSource = audioContext.createBufferSource();
  };
  const interruptQueueThenDestroy = (cause) => {
    queue.stop();
    instance.destroy();
    return new Error("", { cause });
  };
  const fetchArrayBuffer = fetcherMemo(options.src, async () => {
    try {
      return await fetch(options.src).then((response) => response.arrayBuffer());
    } catch (error) {
      throw interruptQueueThenDestroy(error);
    }
  });
  const setArrayBuffer = async () => {
    arrayBuffer = await fetchArrayBuffer();
  };
  const decodeAudioData = decoderMemo(options.src, async () => {
    try {
      return await audioContext.decodeAudioData(arrayBuffer);
    } catch (error) {
      throw interruptQueueThenDestroy(error);
    }
  });
  const setAudioData = async () => {
    audioBuffer = await decodeAudioData();
  };
  const connectSources = () => {
    if (bufferSource && bufferSource.buffer === null) {
      bufferSource.buffer = audioBuffer;
      bufferSource.connect(gainNode);
    }
  };
  const setVolume = () => {
    gainNode.gain.value = pendingVolume;
  };
  const setLoop = () => {
    bufferSource.loop = pendingLoop;
  };
  const queue = createQueue([
    waitForInteraction,
    createAudioContext,
    createGainNode,
    setVolume,
    createBufferSource,
    setLoop,
    fetchArrayBuffer,
    setArrayBuffer,
    decodeAudioData,
    setAudioData,
    connectSources
  ]);
  let resume = false;
  const unregister = registerEventListeners({
    focus: () => {
      if (!options.pauseOnBlur || !resume || state.destroyed) return;
      resume = false;
      queue.queue.push(playAudio);
      queue.execute();
    },
    blur: () => {
      if (!options.pauseOnBlur || !state.playing || state.destroyed) return;
      resume = true;
      queue.queue.push(pauseAudio);
      queue.execute();
    }
  });
  const state = {
    started: false,
    playing: false,
    destroyed: false
  };
  const playAudio = async () => {
    if (state.destroyed) return;
    if (audioContext.state === "suspended") {
      await audioContext.resume();
      if (state.started) {
        state.playing = true;
      }
    }
    if (!state.started) {
      bufferSource.start();
      state.started = true;
      state.playing = true;
    }
  };
  const pauseAudio = async () => {
    if (state.destroyed) return;
    if (audioContext.state === "suspended" && queue.queue.at(-1) === playAudio) {
      queue.queue.pop();
    }
    if (audioContext.state === "running") {
      await audioContext.suspend();
      state.playing = false;
    }
  };
  const disconnectAudio = async () => {
    bufferSource && bufferSource.disconnect();
    state.started = false;
  };
  const instance = {
    async play() {
      if (state.destroyed) return;
      queue.queue.push(playAudio);
      return queue.execute();
    },
    async pause() {
      if (state.destroyed) return;
      queue.queue.push(pauseAudio);
      return queue.execute();
    },
    async reset() {
      if (state.destroyed) return;
      if (state.playing) {
        queue.queue.push(pauseAudio);
      }
      queue.queue.push(
        disconnectAudio,
        createBufferSource,
        setLoop,
        connectSources
      );
      if (state.playing) {
        queue.queue.push(playAudio);
      }
      return queue.execute();
    },
    async stop() {
      if (state.destroyed) return;
      queue.queue.push(
        pauseAudio,
        disconnectAudio,
        createBufferSource,
        setLoop,
        connectSources
      );
      return queue.execute();
    },
    async destroy() {
      if (state.destroyed) return;
      unregister();
      queue.queue = [
        pauseAudio,
        disconnectAudio
      ];
      await queue.execute();
      state.destroyed = true;
      audioContext = null;
      gainNode = null;
      bufferSource = null;
      arrayBuffer = null;
      audioBuffer = null;
    },
    async fetch() {
      if (state.destroyed) return;
      await fetchArrayBuffer();
    },
    get playing() {
      return state.playing;
    },
    get destroyed() {
      return state.destroyed;
    },
    get volume() {
      return pendingVolume;
    },
    set volume(value) {
      if (state.destroyed) return;
      pendingVolume = value;
      queue.queue.push(setVolume);
      queue.execute();
    },
    get loop() {
      return pendingLoop;
    },
    set loop(value) {
      if (state.destroyed) return;
      pendingLoop = value;
      queue.queue.push(setLoop);
      queue.execute();
    }
  };
  if (options.autoplay) {
    queue.queue.push(playAudio);
    queue.execute();
  }
  return instance;
};
var prefetchAudio = (src) => {
  const fetcher = fetcherMemo(src, () => fetch(src).then((res) => res.arrayBuffer()));
  return fetcher();
};

// ../renderer-toolkit/dist/index.js
var memo = (input, cb) => {
  const $memoized = atom(cb(input.get()));
  const unsubscribe = input.subscribe((value) => {
    const comparable = cb(value);
    if (!dequal($memoized.get(), comparable)) {
      $memoized.set(typeof comparable === "object" ? { ...comparable } : Array.isArray(comparable) ? [...comparable] : comparable);
    }
  });
  onMount2($memoized, () => {
    return unsubscribe;
  });
  return $memoized;
};
var usePath = (atomValue, getPath2) => {
  const targets = /* @__PURE__ */ new Set();
  const path = [];
  let current;
  const proxyHandler = {
    get(target, prop, receiver) {
      if (targets.has(target)) {
        throw new ReferenceError(`Attempted to access property on the same target multiple times.`);
      }
      const value = Reflect.get(target, prop, receiver);
      targets.add(target);
      path.push(prop);
      current = value;
      if (value === void 0) {
        return new Proxy({}, proxyHandler);
      }
      if (value && typeof value === "object") {
        return new Proxy(value, proxyHandler);
      }
      return value;
    }
  };
  getPath2(new Proxy(atomValue, proxyHandler));
  if (path.length === 0) {
    throw new Error("No valid path extracted from the provided getPath function.");
  }
  return {
    path,
    value: current
  };
};
var deepAtom = (init) => {
  const $atom = deepMap(init);
  $atom.mutate = (getPath2, setter) => {
    const { path, value } = usePath($atom.get(), getPath2);
    const newValue = typeof setter === "function" ? setter(value) : setter;
    if (newValue === value) {
      return newValue;
    }
    const oldValue = $atom.value;
    $atom.value = setByKey($atom.value, path, newValue);
    $atom.notify(oldValue, path.join("."));
    return newValue;
  };
  return $atom;
};
var getDefaultContextState = () => {
  return {
    background: {
      background: "#000"
    },
    characters: {},
    choice: {
      label: "",
      visible: false,
      choices: []
    },
    dialog: {
      content: "",
      name: "",
      visible: false,
      miniature: {}
    },
    input: {
      element: null,
      label: "",
      error: "",
      visible: false
    },
    text: {
      content: ""
    },
    custom: {},
    meta: {
      restoring: false,
      goingBack: false,
      preview: false
    }
  };
};
var createContextStateRoot = (getExtension = () => ({})) => {
  const CACHE = /* @__PURE__ */ new Map();
  const make = () => {
    const contextState = deepAtom({
      ...getDefaultContextState(),
      ...getExtension()
    });
    return contextState;
  };
  const remove = (id) => {
    const contextState = CACHE.get(id);
    if (contextState) {
      cleanStores(contextState);
    }
    CACHE.delete(id);
  };
  const use2 = (id) => {
    const cached = CACHE.get(id);
    if (cached) {
      return cached;
    }
    const contextState = make();
    CACHE.set(id, contextState);
    onMount2(contextState, () => {
      return () => {
        CACHE.delete(id);
      };
    });
    return contextState;
  };
  return {
    useContextState: use2,
    removeContextState: remove
  };
};
var defaultEmpty = {};
var createRendererState = (extension = defaultEmpty) => {
  const rendererState = deepAtom({
    screen: "mainmenu",
    loadingShown: false,
    exitPromptShown: false,
    ...extension
  });
  return rendererState;
};
var noop = () => {
};
var findLastIndex = (array, fn) => {
  for (let i = array.length - 1; i >= 0; i--) {
    if (fn.call(array, array[i], i, array)) {
      return i;
    }
  }
  return -1;
};
var findLast = (array, fn) => {
  return array[findLastIndex(array, fn)];
};
var escaped = {
  '"': "&quot;",
  "'": "&#39;",
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;"
};
var escapeHTML = (str) => {
  return String(str).replace(/["'&<>]/g, (match) => escaped[match]);
};
var createStartFunction = (fn) => {
  let unmount = noop;
  return () => {
    unmount();
    unmount = fn();
    return {
      unmount: () => {
        unmount();
        unmount = noop;
      }
    };
  };
};
var TYPE_META_MAP = {
  "music": 2,
  "sound": 3,
  "voice": 4
};
var createAudio2 = (storageData) => {
  const store = {
    music: {},
    sound: {},
    voices: {}
  };
  const getVolume = (type) => {
    return storageData.get().meta[TYPE_META_MAP[type]];
  };
  const getAudio = (type, src) => {
    const kind = type === "voice" ? "voices" : type;
    const cached = store[kind][src];
    if (cached) return cached;
    const audio = createAudio({
      src,
      volume: getVolume(type),
      pauseOnBlur: true
    });
    store[kind][src] = audio;
    return audio;
  };
  let unsubscribe = noop;
  const context = {
    music(src, method) {
      const resource = getAudio(method, src);
      this.start();
      return {
        pause() {
          resource.pause();
        },
        play(loop) {
          resource.loop = loop;
          resource.play();
        },
        stop() {
          resource.stop();
        }
      };
    },
    voice(source) {
      this.start();
      this.voiceStop();
      const resource = store.voice = getAudio("voice", source);
      resource.play();
    },
    voiceStop() {
      if (!store.voice) return;
      store.voice.stop();
      store.voice = void 0;
    },
    start() {
      if (unsubscribe !== noop) return;
      unsubscribe = storageData.subscribe(() => {
        for (const type of ["music", "sound", "voice"]) {
          const volume = getVolume(type);
          if (type === "music" || type === "sound") {
            for (const audio of Object.values(store[type])) {
              if (!audio) continue;
              audio.volume = volume;
            }
          }
          if (type === "voice" && store.voice) {
            store.voice.volume = volume;
          }
        }
      });
    },
    clear() {
      const musics = Object.values(store.music);
      const sounds = Object.values(store.sound);
      for (const music of [...musics, ...sounds]) {
        music?.stop();
      }
      this.voiceStop();
    },
    destroy() {
      unsubscribe();
      this.clear();
      unsubscribe = noop;
    }
  };
  const clear = (keepAudio) => {
    context.voiceStop();
    const musics = Object.entries(store.music).filter(([name]) => !keepAudio.music.has(name)).map(([_, a]) => a);
    const sounds = Object.entries(store.sound).filter(([name]) => !keepAudio.sounds.has(name)).map(([_, a]) => a);
    for (const music of [...musics, ...sounds]) {
      if (!music) continue;
      music.stop();
    }
  };
  return {
    context,
    clear,
    getVolume,
    getAudio
  };
};
var createAudioMisc = () => {
  const misc = {
    preloadAudioBlocking: async (src) => {
      await prefetchAudio(src);
    }
  };
  return misc;
};
var createShared = (get) => {
  const CACHE = /* @__PURE__ */ new Map();
  const use2 = (id) => {
    const cached = CACHE.get(id);
    if (cached) {
      return cached;
    }
    const shared = get();
    CACHE.set(id, shared);
    return shared;
  };
  const remove = (id) => {
    CACHE.delete(id);
  };
  return {
    useShared: use2,
    removeShared: remove
  };
};
var createGetContext = () => {
  const CACHE = /* @__PURE__ */ new Map();
  const getContextCached = (createContext2) => {
    return (key) => {
      const cached = CACHE.get(key);
      if (cached) {
        return cached;
      }
      const context = createContext2(key);
      CACHE.set(key, context);
      return context;
    };
  };
  const removeContext = (key) => {
    CACHE.delete(key);
  };
  return {
    getContextCached,
    removeContext
  };
};
var createRootSetter = (getContext2) => {
  let element;
  return {
    root() {
      return element;
    },
    setRoot(root) {
      element = root;
      const context = getContext2();
      if (!context.root) {
        context.root = root;
      }
    }
  };
};
var vibrationPossible = /* @__PURE__ */ (() => {
  let possible = false;
  const onPointerDown = () => {
    possible = true;
  };
  const isPossible = () => {
    return possible;
  };
  document.addEventListener("pointerdown", onPointerDown, { once: true });
  return isPossible;
})();
var vibrate = (pattern) => {
  if (vibrationPossible() && "vibrate" in navigator) {
    try {
      navigator.vibrate(pattern);
    } catch {
    }
  }
};
var useBackground = (backgrounds, set) => {
  const mediaQueries = Object.keys(backgrounds).map((media) => matchMedia(media));
  const allMedia = mediaQueries.find(({ media }) => media === "all");
  const handle = () => {
    const last = findLast(mediaQueries, ({ matches, media }) => matches && media !== "all");
    const bg = last ? backgrounds[last.media] : allMedia ? backgrounds["all"] : "";
    set(bg);
  };
  for (const mq of mediaQueries) {
    mq.onchange = handle;
  }
  let disposed = false;
  Promise.resolve().then(() => {
    if (disposed) return;
    handle();
  });
  return {
    /**
     * Remove all listeners
     */
    dispose() {
      for (const mq of mediaQueries) {
        mq.onchange = null;
      }
      disposed = true;
    }
  };
};
var allEmpty = (target) => {
  if (typeof target === "string") {
    return target == "";
  }
  if (typeof target === "number") {
    return target == 0;
  }
  if (!target) {
    return true;
  }
  if (Array.isArray(target) && target.length > 0) {
    for (const inner of target) {
      if (!allEmpty(inner)) {
        return false;
      }
    }
  }
  for (const value of Object.values(target)) {
    if (!allEmpty(value)) {
      return false;
    }
  }
  return true;
};
var handleBackgroundAction = ($contextState, background) => {
  $contextState.get().background.clear?.();
  const { dispose: dispose2 } = useBackground(background, (value) => {
    $contextState.mutate((s) => s.background, (prev) => {
      return {
        ...prev,
        background: value
      };
    });
  });
  $contextState.mutate((s) => s.background.clear, () => dispose2);
};
var handleDialogAction = ($contextState, content, name, character, emotion, resolve) => {
  $contextState.mutate(
    (s) => s.dialog,
    {
      content,
      name,
      miniature: {
        character,
        emotion
      },
      visible: true,
      resolve
    }
  );
};
var handleChoiceAction = ($contextState, label, choices, resolve) => {
  $contextState.mutate(
    (s) => s.choice,
    { choices, label, resolve, visible: true }
  );
};
var handleClearAction = ($rendererState, $contextState, options, context, keep, keepCharacters) => {
  $rendererState.mutate((s) => s.exitPromptShown, false);
  if (!keep.has("showBackground")) {
    $contextState.mutate((s) => s.background.background, "#000");
  }
  if (!keep.has("choice")) {
    $contextState.mutate(
      (s) => s.choice,
      {
        choices: [],
        visible: false,
        label: ""
      }
    );
  }
  const inputCleanup = $contextState.get().input.cleanup;
  if (inputCleanup) {
    inputCleanup();
  }
  if (!keep.has("input")) {
    $contextState.mutate(
      (s) => s.input,
      {
        element: null,
        label: "",
        visible: false,
        error: ""
      }
    );
  }
  if (!keep.has("dialog")) {
    $contextState.mutate(
      (s) => s.dialog,
      {
        visible: false,
        content: "",
        name: "",
        miniature: {}
      }
    );
  }
  if (!keep.has("text")) {
    $contextState.mutate((s) => s.text, { content: "" });
  }
  const { characters, custom } = $contextState.get();
  for (const character of Object.keys(characters)) {
    if (!keepCharacters.has(character)) {
      $contextState.mutate(
        (s) => s.characters[character],
        {
          style: void 0,
          visible: false
        }
      );
    }
  }
  for (const [id, obj] of Object.entries(custom)) {
    if (!obj) continue;
    if (context.meta.goingBack && obj.fn.skipClearOnGoingBack) continue;
    options.clearCustomAction(context, obj.fn);
    $contextState.mutate((s) => s.custom[id], void 0);
  }
};
var handleCustomAction = ($contextState, fn) => {
  if (!$contextState.get().custom[fn.key]) {
    $contextState.mutate(
      (s) => s.custom[fn.key],
      {
        fn,
        node: null,
        clear: noop
      }
    );
  }
  return {
    setMountElement(node) {
      $contextState.mutate(
        (s) => s.custom[fn.key],
        (state) => {
          return {
            ...state,
            node
          };
        }
      );
    },
    setClear(clear) {
      $contextState.mutate(
        (s) => s.custom[fn.key],
        (state) => {
          return {
            ...state,
            clear
          };
        }
      );
    },
    remove() {
      $contextState.mutate((s) => s.custom[fn.key], void 0);
    }
  };
};
var handleClearBlockingActions = ($contextState, preserve) => {
  const current = $contextState.get();
  if (preserve !== "choice" && !allEmpty(current.choice)) {
    $contextState.mutate(
      (s) => s.choice,
      {
        choices: [],
        visible: false,
        label: ""
      }
    );
  }
  if (preserve !== "input" && !allEmpty(current.input)) {
    $contextState.mutate(
      (s) => s.input,
      {
        element: null,
        label: "",
        visible: false,
        error: ""
      }
    );
  }
  if (preserve !== "text" && !allEmpty(current.text)) {
    $contextState.mutate((s) => s.text, { content: "" });
  }
  if (preserve !== "dialog" && !allEmpty(current.dialog)) {
    $contextState.mutate(
      (s) => s.dialog,
      {
        visible: false,
        content: "",
        name: "",
        miniature: {}
      }
    );
  }
};
var handleTextAction = ($contextState, content, resolve) => {
  $contextState.mutate((s) => s.text, { content, resolve });
};
var handleInputAction = ($contextState, options, context, label, onInput, setup, resolve) => {
  const error = (value) => {
    $contextState.mutate((s) => s.input.error, value);
  };
  const onInputHandler = (event) => {
    let value;
    onInput({
      lang: options.storageData.get().meta[0],
      input,
      event,
      error,
      state: options.getStateFunction(context.id),
      get value() {
        if (value) return value;
        return value = escapeHTML(input.value);
      }
    });
  };
  const input = document.createElement("input");
  input.setAttribute("type", "text");
  input.setAttribute("name", "novely-input");
  input.setAttribute("required", "true");
  input.setAttribute("autocomplete", "off");
  !context.meta.preview && input.addEventListener("input", onInputHandler);
  $contextState.mutate(
    (s) => s.input,
    {
      element: input,
      label,
      error: "",
      visible: true,
      cleanup: setup(input) || noop,
      resolve
    }
  );
  !context.meta.preview && input.dispatchEvent(new InputEvent("input", { bubbles: true }));
};
var handleVibrateAction = vibrate;

// src/emitter.ts
var createEmitter = () => {
  const listeners = /* @__PURE__ */ new Map();
  return {
    on(name, fn) {
      const set = listeners.get(name);
      if (!set) {
        listeners.set(name, /* @__PURE__ */ new Set());
        return this.on(name, fn);
      }
      set.add(fn);
    },
    once(name, fn) {
      const listener = (params) => {
        fn(params);
        this.off(name, listener);
      };
      this.on(name, listener);
    },
    off(name, fn) {
      const set = listeners.get(name);
      if (set) {
        set.delete(fn);
      }
    },
    emit(name, params) {
      const set = listeners.get(name);
      if (set) {
        set.forEach((fn) => fn(params));
      }
    }
  };
};

// src/context-state.ts
var { useContextState, removeContextState } = createContextStateRoot();

// src/shared.ts
var PRELOADED_IMAGE_MAP = /* @__PURE__ */ new Map();
var PRELOADING_IMAGE_MAP = /* @__PURE__ */ new Map();
var { useShared, removeShared } = createShared(() => {
  return {
    characters: {}
  };
});

// src/utils.ts
var capitalize = (str) => {
  return str[0].toUpperCase() + str.slice(1);
};
var isCSSImage = (str) => {
  const startsWith = String.prototype.startsWith.bind(str);
  return startsWith("http") || startsWith("/") || startsWith(".") || startsWith("data");
};
var createImage = (src) => {
  const img = document.createElement("img");
  Object.assign(img, {
    src
  });
  return img;
};
var imageLoaded = (image) => {
  const { promise, resolve } = Promise.withResolvers();
  if (image.complete && image.naturalHeight !== 0) {
    resolve(true);
    return promise;
  }
  image.addEventListener("load", async () => {
    if (image.decode) {
      await image.decode().catch(() => {
      });
    }
    resolve(true);
  });
  image.addEventListener("abort", () => {
    resolve(false);
  });
  image.addEventListener("error", () => {
    resolve(false);
  });
  return promise;
};
var imagePreloadWithCaching = async (src) => {
  if (PRELOADING_IMAGE_MAP.has(src)) {
    const image2 = PRELOADING_IMAGE_MAP.get(src);
    await imageLoaded(image2);
    PRELOADING_IMAGE_MAP.delete(src);
    PRELOADED_IMAGE_MAP.set(src, image2);
    return image2;
  }
  if (PRELOADED_IMAGE_MAP.has(src)) {
    const image2 = PRELOADED_IMAGE_MAP.get(src);
    return image2;
  }
  const image = createImage(src);
  PRELOADING_IMAGE_MAP.set(src, image);
  await imageLoaded(image);
  PRELOADING_IMAGE_MAP.delete(src);
  PRELOADED_IMAGE_MAP.set(src, image);
  return image;
};
var imagePreloadWithCachingNotComplete = (src) => {
  if (PRELOADING_IMAGE_MAP.has(src)) {
    PRELOADING_IMAGE_MAP.get(src);
  }
  if (PRELOADED_IMAGE_MAP.has(src)) {
    return PRELOADED_IMAGE_MAP.get(src);
  }
  const image = createImage(src);
  PRELOADING_IMAGE_MAP.set(src, image);
  return image;
};
var createCanvas = () => {
  return document.createElement("canvas");
};
var getContext = (canvas) => {
  return canvas.getContext("2d");
};
var canvasDrawImages = async (canvas = createCanvas(), ctx = getContext(canvas), images) => {
  await Promise.allSettled(images.map((image) => imageLoaded(image)));
  if (canvas.dataset.resized === "false" || !canvas.dataset.resized) {
    const sizesSorted = images.slice().sort((a, b) => b.width - a.width);
    const sizes = sizesSorted[0];
    const scaleBy = canvas.dataset.scaleBy ? Number(canvas.dataset.scaleBy) : 1;
    canvas.width = Math.min(sizes.naturalWidth * scaleBy * 2, sizes.naturalWidth) * devicePixelRatio;
    canvas.height = Math.min(sizes.naturalHeight * scaleBy * 2, sizes.naturalHeight) * devicePixelRatio;
    canvas.dataset.resized = "true";
  }
  for (const image of images) {
    ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
  }
  return [canvas, ctx];
};
var onKey = (cb, ...keys2) => {
  return (e) => {
    if (keys2.some((key) => key === e.key)) {
      cb(e);
    }
  };
};
var simple = (fn) => {
  return (...args) => {
    let result;
    batch(() => {
      untrack(() => {
        result = fn(...args);
      });
    });
    return result;
  };
};
var getDocumentStyles = () => {
  let css = "";
  for (const styleSheet of Array.from(document.styleSheets)) {
    if (!styleSheet.href || styleSheet.href.startsWith(location.origin)) {
      for (const { cssText } of Array.from(styleSheet.cssRules)) {
        css += cssText;
      }
    }
  }
  return css;
};
var once = (fn) => {
  let ran = false;
  return () => {
    if (ran) return;
    ran = true;
    fn();
  };
};

// src/hooks/useMedia.ts
var useMedia = (media) => {
  const mq = matchMedia(media);
  const [matches, setMatches] = createSignal(mq.matches);
  const handleChange = (e) => {
    setMatches(e.matches);
  };
  typeof mq.addEventListener === "function" ? mq.addEventListener("change", handleChange) : mq.addListener(handleChange);
  onCleanup(() => {
    typeof mq.removeEventListener === "function" ? mq.removeEventListener("change", handleChange) : mq.removeListener(handleChange);
  });
  return matches;
};

// src/context/index.tsx
var Context = createContext();
var Provider = (props) => {
  const storageData = from(props.storageData);
  const coreData = from(props.coreData);
  const value = {
    $rendererState: props.$rendererState,
    storageData,
    storageDataUpdate: props.storageData.update,
    coreData,
    coreDataUpdate: props.coreData.update,
    options: props.options,
    renderer: props.renderer,
    t(key) {
      return props.options.t(key, storageData().meta[0]);
    },
    emitter: props.emitter,
    media: {
      hyperWide: useMedia("(max-aspect-ratio: 0.26)")
    },
    getContext: props.getContext,
    removeContext: props.removeContext
  };
  return createComponent(Context.Provider, {
    value,
    get children() {
      return createComponent(Show, {
        get when() {
          return storageData();
        },
        get children() {
          return props.children;
        }
      });
    }
  });
};
var useData = () => {
  return useContext(Context);
};

// src/screens/custom-screen.tsx
var _tmpl$ = /* @__PURE__ */ template(`<div class="custom">`);
var CustomScreen = (props) => {
  const {
    $rendererState
  } = useData();
  const [dom, setDOM] = createSignal(null);
  const rendererState = from($rendererState);
  let unmount = noop;
  createEffect(() => {
    unmount();
    const screens = rendererState().screens;
    if (props.name in screens) {
      const current = screens[props.name]();
      setDOM(current.mount());
      unmount = current.unmount || noop;
      return;
    }
    setDOM(null);
    unmount = noop;
  });
  const onClick = ({
    target
  }) => {
    if (target instanceof HTMLElement && target.dataset.novelyGoto) {
      $rendererState.setKey("screen", target.dataset.novelyGoto);
    }
  };
  return createComponent(Show, {
    get when() {
      return dom();
    },
    get children() {
      const _el$ = _tmpl$();
      _el$.$$click = onClick;
      insert(_el$, dom);
      return _el$;
    }
  });
};
delegateEvents(["click"]);

// src/components/Character.tsx
var Character = (props) => {
  const canvas = () => props.characters[props.character].canvas;
  createRenderEffect(() => setAttribute(canvas(), "style", props.data.style || ""));
  return createMemo(canvas);
};

// src/components/ControlPanelButtons.tsx
var _tmpl$2 = /* @__PURE__ */ template(`<button role="menuitem" type="button" class="button control-panel__button"><span class="control-panel__button__content">`);
var _tmpl$22 = /* @__PURE__ */ template(`<button role="menuitem" type="button" class="button control-panel__button control-panel__button--auto-mode"><span class="control-panel__button__content">`);
var _tmpl$3 = /* @__PURE__ */ template(`<button role="menuitem" type="button" class="button control-panel__button">`);
var ControlPanelButtons = (props) => {
  const data = useData();
  return [(() => {
    const _el$ = _tmpl$2(), _el$2 = _el$.firstChild;
    addEventListener2(_el$, "click", data.options.back, true);
    insert(_el$2, () => data.t("GoBack"));
    insert(_el$, createComponent(Icon, {
      "class": "control-panel__button__icon",
      children: Icon.Back()
    }), null);
    createRenderEffect(() => setAttribute(_el$, "title", data.t("GoBack")));
    return _el$;
  })(), (() => {
    const _el$3 = _tmpl$2(), _el$4 = _el$3.firstChild;
    _el$3.$$click = () => {
      data.options.save("manual");
    };
    insert(_el$4, () => data.t("DoSave"));
    insert(_el$3, createComponent(Icon, {
      "class": "control-panel__button__icon",
      children: Icon.Save()
    }), null);
    createRenderEffect(() => setAttribute(_el$3, "title", data.t("DoSave")));
    return _el$3;
  })(), (() => {
    const _el$5 = _tmpl$22(), _el$6 = _el$5.firstChild;
    _el$5.$$click = () => {
      props.setAuto((prev) => !prev);
    };
    insert(_el$6, () => data.t(props.auto() ? "Stop" : "Auto"));
    insert(_el$5, createComponent(Icon, {
      "class": "control-panel__button__icon",
      get children() {
        return createMemo(() => !!props.auto())() ? createComponent(Icon.Stop, {}) : createComponent(Icon.Play, {});
      }
    }), null);
    createRenderEffect(() => setAttribute(_el$5, "title", data.t(props.auto() ? "Stop" : "Auto")));
    return _el$5;
  })(), (() => {
    const _el$7 = _tmpl$2(), _el$8 = _el$7.firstChild;
    _el$7.$$click = () => {
      data.options.save("auto");
      data.options.exit(true);
      props.openSettings();
    };
    insert(_el$8, () => data.t("Settings"));
    insert(_el$7, createComponent(Icon, {
      "class": "control-panel__button__icon",
      children: Icon.Settings()
    }), null);
    createRenderEffect(() => setAttribute(_el$7, "title", data.t("Settings")));
    return _el$7;
  })(), (() => {
    const _el$9 = _tmpl$2(), _el$10 = _el$9.firstChild;
    _el$9.$$click = () => {
      data.options.exit();
    };
    insert(_el$10, () => data.t("Exit"));
    insert(_el$9, createComponent(Icon, {
      "class": "control-panel__button__icon",
      children: Icon.Exit()
    }), null);
    createRenderEffect(() => setAttribute(_el$9, "title", data.t("Exit")));
    return _el$9;
  })(), createComponent(Show, {
    get when() {
      return data.media.hyperWide();
    },
    get children() {
      const _el$11 = _tmpl$3();
      _el$11.$$click = () => {
        props.closeDropdown();
      };
      insert(_el$11, createComponent(Icon, {
        children: Icon.Close()
      }));
      createRenderEffect(() => setAttribute(_el$11, "title", data.t("CloseMenu")));
      return _el$11;
    }
  })];
};
delegateEvents(["click"]);

// src/components/DialogName.tsx
var _tmpl$4 = /* @__PURE__ */ template(`<span class="action-dialog-name">`);
var DialogName = (props) => {
  const data = useData();
  const color = () => {
    return props.character ? data.options.getCharacterColor(props.character) : "#000";
  };
  return (() => {
    const _el$ = _tmpl$4();
    insert(_el$, () => props.name || " ");
    createRenderEffect((_p$) => {
      const _v$ = color(), _v$2 = props.character ? 1 : 0, _v$3 = props.character ? "visible" : "hidden";
      _v$ !== _p$._v$ && ((_p$._v$ = _v$) != null ? _el$.style.setProperty("color", _v$) : _el$.style.removeProperty("color"));
      _v$2 !== _p$._v$2 && ((_p$._v$2 = _v$2) != null ? _el$.style.setProperty("opacity", _v$2) : _el$.style.removeProperty("opacity"));
      _v$3 !== _p$._v$3 && ((_p$._v$3 = _v$3) != null ? _el$.style.setProperty("visibility", _v$3) : _el$.style.removeProperty("visibility"));
      return _p$;
    }, {
      _v$: void 0,
      _v$2: void 0,
      _v$3: void 0
    });
    return _el$;
  })();
};

// src/components/Icon.tsx
var _tmpl$5 = /* @__PURE__ */ template(`<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5">`);
var _tmpl$23 = /* @__PURE__ */ template(`<svg><path d="m9.75 12 8.5-6.25v12.5L9.75 12ZM5.75 5.75v12.5"></svg>`, false, true);
var _tmpl$32 = /* @__PURE__ */ template(`<svg><path d="M6.75 19.25h10.5a2 2 0 0 0 2-2V9.828a2 2 0 0 0-.586-1.414l-3.078-3.078a2 2 0 0 0-1.414-.586H6.75a2 2 0 0 0-2 2v10.5a2 2 0 0 0 2 2Z"></svg>`, false, true);
var _tmpl$42 = /* @__PURE__ */ template(`<svg><path d="M8.75 19v-3.25a1 1 0 0 1 1-1h4.5a1 1 0 0 1 1 1V19M8.75 5v3.25"></svg>`, false, true);
var _tmpl$52 = /* @__PURE__ */ template(`<svg><path d="M13.12 5.613a1 1 0 0 0-.991-.863h-.258a1 1 0 0 0-.99.863l-.087.632c-.056.403-.354.724-.732.874a5.225 5.225 0 0 0-.167.07c-.373.163-.81.15-1.136-.095l-.308-.23a1 1 0 0 0-1.307.092l-.188.188a1 1 0 0 0-.092 1.307l.23.308c.244.325.258.763.095 1.136a5.225 5.225 0 0 0-.07.167c-.15.378-.47.676-.874.732l-.632.087a1 1 0 0 0-.863.99v.258a1 1 0 0 0 .863.99l.632.087c.403.056.724.354.874.732l.07.167c.163.373.15.81-.095 1.136l-.23.308a1 1 0 0 0 .092 1.307l.188.188a1 1 0 0 0 1.307.093l.308-.231c.325-.244.763-.258 1.136-.095a5.4 5.4 0 0 0 .167.07c.378.15.676.47.732.874l.087.632a1 1 0 0 0 .99.863h.258a1 1 0 0 0 .99-.863l.087-.632c.056-.403.354-.724.732-.874a5.12 5.12 0 0 0 .167-.07c.373-.163.81-.15 1.136.095l.308.23a1 1 0 0 0 1.307-.092l.188-.188a1 1 0 0 0 .093-1.307l-.231-.308c-.244-.325-.258-.763-.095-1.136l.07-.167c.15-.378.47-.676.874-.732l.632-.087a1 1 0 0 0 .863-.99v-.258a1 1 0 0 0-.863-.99l-.632-.087c-.403-.056-.724-.354-.874-.732a5.168 5.168 0 0 0-.07-.167c-.163-.373-.15-.81.095-1.136l.23-.308a1 1 0 0 0-.092-1.307l-.188-.188a1 1 0 0 0-1.307-.092l-.308.23c-.325.244-.763.258-1.136.095a5.185 5.185 0 0 0-.167-.07c-.378-.15-.676-.47-.732-.874l-.087-.632Z"></svg>`, false, true);
var _tmpl$6 = /* @__PURE__ */ template(`<svg><path d="M13.25 12a1.25 1.25 0 1 1-2.5 0 1.25 1.25 0 0 1 2.5 0Z"></svg>`, false, true);
var _tmpl$7 = /* @__PURE__ */ template(`<svg><path d="m15.75 8.75 3.5 3.25-3.5 3.25M19 12h-8.25M15.25 4.75h-8.5a2 2 0 0 0-2 2v10.5a2 2 0 0 0 2 2h8.5"></svg>`, false, true);
var _tmpl$8 = /* @__PURE__ */ template(`<svg><path d="M4.75 5.75h14.5M4.75 18.25h14.5M4.75 12h14.5"></svg>`, false, true);
var _tmpl$9 = /* @__PURE__ */ template(`<svg><path d="m17.25 6.75-10.5 10.5M6.75 6.75l10.5 10.5"></svg>`, false, true);
var _tmpl$10 = /* @__PURE__ */ template(`<svg><path d="M4.75 6.75a2 2 0 0 1 2-2h10.5a2 2 0 0 1 2 2v10.5a2 2 0 0 1-2 2H6.75a2 2 0 0 1-2-2V6.75Z"></svg>`, false, true);
var _tmpl$11 = /* @__PURE__ */ template(`<svg><path d="m15.25 12-5.5-3.25v6.5l5.5-3.25Z"></svg>`, false, true);
var _tmpl$12 = /* @__PURE__ */ template(`<svg><rect width="12.5" height="12.5" x="5.75" y="5.75" rx="1"></svg>`, false, true);
var _tmpl$13 = /* @__PURE__ */ template(`<svg><path d="M11.25 19.25h-3.5a2 2 0 0 1-2-2V6.75a2 2 0 0 1 2-2H14L18.25 9v2.25M17 14.75v4.5M19.25 17h-4.5"></svg>`, false, true);
var _tmpl$14 = /* @__PURE__ */ template(`<svg><path d="M18 9.25h-4.25V5"></svg>`, false, true);
var _tmpl$15 = /* @__PURE__ */ template(`<svg><path d="M9.75 6.75h-3a2 2 0 0 0-2 2v8.5a2 2 0 0 0 2 2h6.5a2 2 0 0 0 2-2v-5m-5.5-5.5 5.5 5.5m-5.5-5.5v3.5a2 2 0 0 0 2 2h3.5m-3.5-7.5h2l5.5 5.5v5a2 2 0 0 1-2 2H15.5"></svg>`, false, true);
var _tmpl$16 = /* @__PURE__ */ template(`<svg><path d="M15.25 10.75 12 14.25l-3.25-3.5"></svg>`, false, true);
var _tmpl$17 = /* @__PURE__ */ template(`<svg><path d="M15.25 14.25 12 10.75l-3.25 3.5"></svg>`, false, true);
var Icon = (props) => {
  return (() => {
    const _el$ = _tmpl$5();
    spread(_el$, props, true, true);
    insert(_el$, () => props.children);
    return _el$;
  })();
};
Icon.Back = () => {
  return _tmpl$23();
};
Icon.Save = () => {
  return [_tmpl$32(), _tmpl$42()];
};
Icon.Settings = () => {
  return [_tmpl$52(), _tmpl$6()];
};
Icon.Exit = () => {
  return _tmpl$7();
};
Icon.Menu = () => {
  return _tmpl$8();
};
Icon.Close = () => {
  return _tmpl$9();
};
Icon.Play = () => {
  return [_tmpl$10(), _tmpl$11()];
};
Icon.Stop = () => {
  return _tmpl$12();
};
Icon.FilePlus = () => {
  return [_tmpl$13(), _tmpl$14()];
};
Icon.Files = () => {
  return _tmpl$15();
};
Icon.ChevronDown = () => {
  return _tmpl$16();
};
Icon.ChevronUp = () => {
  return _tmpl$17();
};

// src/actions.ts
var clickOutside = (node, handler) => {
  const handleClick = (event) => node && !node.contains(event.target) && !event.defaultPrevented && handler && handler();
  document.addEventListener("click", handleClick, true);
  onCleanup(() => document.removeEventListener("click", handleClick, true));
};

// src/components/Modal.tsx
var _tmpl$18 = /* @__PURE__ */ template(`<div role="dialog" class="dialog">`);
var Modal = (props) => {
  let modalWindow;
  const handleKeydown = (event) => {
    if (untrack(props.isOpen) && event.key === "Tab") {
      if (!untrack(props.trapFocus)) {
        return;
      }
      if (!modalWindow) {
        return;
      }
      const nodes = modalWindow.querySelectorAll("*");
      const tabbable = Array.from(nodes).filter((node) => node.tabIndex >= 0);
      let index = tabbable.indexOf(document.activeElement);
      if (index === -1 && event.shiftKey) index = 0;
      index += tabbable.length + (event.shiftKey ? -1 : 1);
      index %= tabbable.length;
      tabbable[index].focus();
      event.preventDefault();
    }
  };
  const close = () => {
    props.setIsOpen && props.setIsOpen(false);
    props.onClose && untrack(props.onClose);
  };
  createEffect(on(props.isOpen, (isOpen) => isOpen && props.onClose && untrack(props.onClose), {
    defer: true
  }));
  addEventListener("keydown", handleKeydown);
  onCleanup(() => removeEventListener("keydown", handleKeydown));
  return createComponent(Show, {
    get when() {
      return props.isOpen();
    },
    get children() {
      const _el$ = _tmpl$18();
      use((element) => {
        modalWindow = element;
        clickOutside(element, close);
      }, _el$);
      setAttribute(_el$, "aria-modal", true);
      insert(_el$, () => props.children);
      return _el$;
    }
  });
};

// ../../node_modules/.pnpm/@solid-primitives+transition-group@1.0.5_solid-js@1.8.19/node_modules/@solid-primitives/transition-group/dist/index.js
var noop2 = () => {
};
var noopTransition = (el, done) => done();
function createSwitchTransition(source, options) {
  const initSource = untrack(source);
  const initReturned = initSource ? [initSource] : [];
  if (isServer) {
    return () => initReturned;
  }
  const { onEnter = noopTransition, onExit = noopTransition } = options;
  const [returned, setReturned] = createSignal(
    options.appear ? [] : initReturned
  );
  const [isTransitionPending] = useTransition();
  let next;
  let isExiting = false;
  function exitTransition2(el, after) {
    if (!el)
      return after && after();
    isExiting = true;
    onExit(el, () => {
      batch(() => {
        isExiting = false;
        setReturned((p) => p.filter((e) => e !== el));
        after && after();
      });
    });
  }
  function enterTransition2(after) {
    const el = next;
    if (!el)
      return after && after();
    next = void 0;
    setReturned((p) => [el, ...p]);
    onEnter(el, after ?? noop2);
  }
  const triggerTransitions = options.mode === "out-in" ? (
    // exit -> enter
    (prev) => isExiting || exitTransition2(prev, enterTransition2)
  ) : options.mode === "in-out" ? (
    // enter -> exit
    (prev) => enterTransition2(() => exitTransition2(prev))
  ) : (
    // exit & enter
    (prev) => {
      exitTransition2(prev);
      enterTransition2();
    }
  );
  createComputed(
    (prev) => {
      const el = source();
      if (untrack(isTransitionPending)) {
        isTransitionPending();
        return prev;
      }
      if (el !== prev) {
        next = el;
        batch(() => untrack(() => triggerTransitions(prev)));
      }
      return el;
    },
    options.appear ? void 0 : initSource
  );
  return returned;
}

// ../../node_modules/.pnpm/@solid-primitives+utils@6.2.3_solid-js@1.8.19/node_modules/@solid-primitives/utils/dist/chunk/R5675YMU.js
var access = (v) => typeof v === "function" && !v.length ? v() : v;

// ../../node_modules/.pnpm/@solid-primitives+refs@1.0.8_solid-js@1.8.19/node_modules/@solid-primitives/refs/dist/index.js
var defaultElementPredicate = isServer ? (item) => item != null && typeof item === "object" && "t" in item : (item) => item instanceof Element;
function getFirstChild(value, predicate) {
  if (predicate(value))
    return value;
  if (typeof value === "function" && !value.length)
    return getFirstChild(value(), predicate);
  if (Array.isArray(value)) {
    for (const item of value) {
      const result = getFirstChild(item, predicate);
      if (result)
        return result;
    }
  }
  return null;
}
function resolveFirst(fn, predicate = defaultElementPredicate, serverPredicate = defaultElementPredicate) {
  const children2 = createMemo(fn);
  return createMemo(() => getFirstChild(children2(), isServer ? serverPredicate : predicate));
}

// ../../node_modules/.pnpm/solid-transition-group@0.2.3_solid-js@1.8.19/node_modules/solid-transition-group/dist/index.js
function createClassnames(props) {
  return createMemo(() => {
    const name = props.name || "s";
    return {
      enterActive: (props.enterActiveClass || name + "-enter-active").split(" "),
      enter: (props.enterClass || name + "-enter").split(" "),
      enterTo: (props.enterToClass || name + "-enter-to").split(" "),
      exitActive: (props.exitActiveClass || name + "-exit-active").split(" "),
      exit: (props.exitClass || name + "-exit").split(" "),
      exitTo: (props.exitToClass || name + "-exit-to").split(" "),
      move: (props.moveClass || name + "-move").split(" ")
    };
  });
}
function nextFrame(fn) {
  requestAnimationFrame(() => requestAnimationFrame(fn));
}
function enterTransition(classes, events, el, done) {
  const { onBeforeEnter, onEnter, onAfterEnter } = events;
  onBeforeEnter?.(el);
  el.classList.add(...classes.enter);
  el.classList.add(...classes.enterActive);
  queueMicrotask(() => {
    if (!el.parentNode)
      return done?.();
    onEnter?.(el, () => endTransition());
  });
  nextFrame(() => {
    el.classList.remove(...classes.enter);
    el.classList.add(...classes.enterTo);
    if (!onEnter || onEnter.length < 2) {
      el.addEventListener("transitionend", endTransition);
      el.addEventListener("animationend", endTransition);
    }
  });
  function endTransition(e) {
    if (!e || e.target === el) {
      done?.();
      el.removeEventListener("transitionend", endTransition);
      el.removeEventListener("animationend", endTransition);
      el.classList.remove(...classes.enterActive);
      el.classList.remove(...classes.enterTo);
      onAfterEnter?.(el);
    }
  }
}
function exitTransition(classes, events, el, done) {
  const { onBeforeExit, onExit, onAfterExit } = events;
  if (!el.parentNode)
    return done?.();
  onBeforeExit?.(el);
  el.classList.add(...classes.exit);
  el.classList.add(...classes.exitActive);
  onExit?.(el, () => endTransition());
  nextFrame(() => {
    el.classList.remove(...classes.exit);
    el.classList.add(...classes.exitTo);
    if (!onExit || onExit.length < 2) {
      el.addEventListener("transitionend", endTransition);
      el.addEventListener("animationend", endTransition);
    }
  });
  function endTransition(e) {
    if (!e || e.target === el) {
      done?.();
      el.removeEventListener("transitionend", endTransition);
      el.removeEventListener("animationend", endTransition);
      el.classList.remove(...classes.exitActive);
      el.classList.remove(...classes.exitTo);
      onAfterExit?.(el);
    }
  }
}
var TRANSITION_MODE_MAP = {
  inout: "in-out",
  outin: "out-in"
};
var Transition2 = (props) => {
  const classnames = createClassnames(props);
  return createSwitchTransition(
    resolveFirst(() => props.children),
    {
      mode: TRANSITION_MODE_MAP[props.mode],
      appear: props.appear,
      onEnter(el, done) {
        enterTransition(classnames(), props, el, done);
      },
      onExit(el, done) {
        exitTransition(classnames(), props, el, done);
      }
    }
  );
};

// ../../node_modules/.pnpm/retrieved@0.1.0/node_modules/retrieved/index.js
var createRetrieved = (fn) => {
  const key = Symbol();
  let value = key;
  return () => {
    if (value === key) {
      value = fn();
    }
    return value;
  };
};

// src/components/Save.tsx
var _tmpl$19 = /* @__PURE__ */ template(`<div class="saves__list-item__overlay">`);
var _tmpl$24 = /* @__PURE__ */ template(`<iframe tabindex="-1" class="saves__list-item__iframe" src="about:blank">`);
var _tmpl$33 = /* @__PURE__ */ template(`<li class="saves__list-item"><div class="saves__list-item__load" role="button" tabindex="0"></div><div class="saves__list-item__description"><div></div><div></div></div><button type="reset" class="button saves__button-reset"><span>`);
var _tmpl$43 = /* @__PURE__ */ template(`<div class="saves__list-item__iframe">`);
var CURRENT_DATE = /* @__PURE__ */ new Date();
var CURRENT_YEAR = CURRENT_DATE.getFullYear();
var stylesheet = createRetrieved(getDocumentStyles);
var Save = (props) => {
  const {
    t,
    options,
    getContext: getContext2,
    storageData,
    storageDataUpdate,
    removeContext
  } = useData();
  const [iframe, setIframe] = createSignal();
  const [iframeLoaded, setIframeLoaded] = createSignal(false);
  const [previewStarted, setPreviewStarted] = createSignal(false);
  let previewDoneTimeoutId;
  const previewDone = once(() => {
    previewDoneTimeoutId = setTimeout(() => {
      untrack(props.onPreviewDone);
    }, 150);
  });
  const [timestamp, type] = props.save[2];
  const date = new Date(timestamp);
  const KEY = `save-${timestamp}-${type}`;
  const $contextState = useContextState(KEY);
  const context = getContext2(KEY);
  const year = date.getFullYear();
  const stringDate = () => capitalize(date.toLocaleDateString(props.language, {
    year: year === CURRENT_YEAR ? void 0 : "numeric",
    month: "long",
    day: "numeric",
    dayPeriod: "narrow",
    hour: "numeric",
    minute: "numeric"
  }));
  const stringType = t(type === "auto" ? "Automatic" : "Manual");
  const loadSave = () => {
    options.set(props.save);
  };
  const removeSave = (date2) => {
    storageDataUpdate((prev) => {
      prev.saves = untrack(storageData).saves.filter((save) => save[2][0] !== date2);
      return prev;
    });
  };
  const onIframeLoaded = () => {
    const {
      contentDocument
    } = iframe();
    if (!contentDocument) return;
    contentDocument.head.insertAdjacentHTML("beforeend", `<style>:root { font-size: 30%; background: black; cursor: pointer; } * { pointer-events: none; } *, *::before, *::after { animation-play-state: paused !important; }</style><style>${stylesheet()}</style>`);
    context.root = contentDocument.body;
    setIframeLoaded(true);
  };
  createEffect(async () => {
    const ready = props.observed && iframeLoaded() && !previewStarted();
    if (!ready) return;
    setPreviewStarted(true);
    setTimeout(() => {
      previewDone();
    }, 1e3);
    try {
      const {
        assets
      } = await options.preview(props.save, KEY);
      if (assets.length === 0) {
        return previewDone();
      }
      const promises = assets.map(async (asset) => {
        const type2 = await options.getResourseType(asset);
        if (type2 === "image") {
          await imagePreloadWithCaching(asset);
        }
      });
      await Promise.allSettled(promises);
      previewDone();
    } catch {
      previewDone();
    }
  });
  onCleanup(() => {
    const state = useContextState(KEY);
    for (const custom of Object.values(state.get().custom)) {
      if (!custom) continue;
      try {
        options.clearCustomAction(context, custom.fn);
      } catch {
      }
    }
    removeContextState(KEY);
    removeContext(KEY);
    options.removeContext(KEY);
    removeShared(KEY);
  });
  onCleanup(() => {
    clearTimeout(previewDoneTimeoutId);
  });
  return (() => {
    const _el$ = _tmpl$33(), _el$2 = _el$.firstChild, _el$5 = _el$2.nextSibling, _el$6 = _el$5.firstChild, _el$7 = _el$6.nextSibling, _el$8 = _el$5.nextSibling, _el$9 = _el$8.firstChild;
    setAttribute(_el$, "data-timestamp", timestamp);
    _el$2.$$keyup = (event) => {
      if (event.code === "Space") {
        loadSave();
      }
    };
    _el$2.$$keydown = (event) => {
      if (event.code === "Enter") {
        loadSave();
      }
    };
    _el$2.$$click = loadSave;
    insert(_el$2, createComponent(Transition2, {
      name: "saves__list-item__overlay",
      get children() {
        return createComponent(Show, {
          get when() {
            return props.overlayShown;
          },
          get children() {
            return _tmpl$19();
          }
        });
      }
    }), null);
    insert(_el$2, createComponent(Show, {
      get when() {
        return props.observed;
      },
      get fallback() {
        return _tmpl$43();
      },
      get children() {
        return [(() => {
          const _el$4 = _tmpl$24();
          _el$4.addEventListener("load", () => {
            onIframeLoaded();
          });
          use(setIframe, _el$4);
          setAttribute(
            _el$4,
            "loading",
            void 0
            /** "lazy" is broken on Firefox Mobile as of now (06.05.2024) */
          );
          return _el$4;
        })(), createComponent(Show, {
          get when() {
            return iframeLoaded();
          },
          get children() {
            return createComponent(Portal, {
              get mount() {
                return context.root;
              },
              get children() {
                return createComponent(Game, {
                  controls: "outside",
                  skipTypewriterWhenGoingBack: true,
                  $contextState,
                  context,
                  get store() {
                    return useShared(KEY);
                  },
                  isPreview: true
                });
              }
            });
          }
        })];
      }
    }), null);
    setAttribute(_el$6, "aria-hidden", true);
    insert(_el$6, stringDate);
    insert(_el$7, stringType);
    _el$8.$$click = removeSave;
    _el$8.$$clickData = timestamp;
    insert(_el$9, () => t("Remove"));
    createRenderEffect((_p$) => {
      const _v$ = t("LoadASaveFrom") + " " + stringDate(), _v$2 = t("DeleteASaveFrom") + " " + stringDate();
      _v$ !== _p$._v$ && setAttribute(_el$2, "aria-label", _p$._v$ = _v$);
      _v$2 !== _p$._v$2 && setAttribute(_el$8, "aria-label", _p$._v$2 = _v$2);
      return _p$;
    }, {
      _v$: void 0,
      _v$2: void 0
    });
    return _el$;
  })();
};
delegateEvents(["click", "keydown", "keyup"]);

// ../typewriter/dist/index.js
var defaultSpeed = () => {
  return Math.min(90 * Math.random() + 100, 90);
};
var collectTextNodes = (el) => {
  const items = [];
  el.childNodes.forEach((child) => {
    if (child.nodeName === "#text") items.push(child);
    else items.push(...collectTextNodes(child));
  });
  return items;
};
var map = (it, cb) => {
  const result = [];
  for (const value of it) {
    const val = cb(value, result.at(-1));
    if (val) {
      result.push(val);
    }
  }
  return result;
};
var typewriter = ({ node, text, ended, speed = defaultSpeed }) => {
  node.innerHTML = text;
  const nodes = collectTextNodes(node).map((child) => {
    const letters = map(child.textContent, (char, prev) => {
      if (char === " " && prev) {
        prev.textContent += " ";
        return void 0;
      } else {
        const text2 = document.createElement("span");
        text2.textContent = char;
        text2.style.opacity = "0";
        return text2;
      }
    });
    child.replaceWith(...letters);
    return letters;
  });
  let current = 0;
  let pos = 0;
  let end = false;
  let frame;
  const enqueue = () => {
    frame = requestAnimationFrame(queue);
  };
  const dequeue = () => {
    cancelAnimationFrame(frame);
  };
  let timeout = 0;
  let start = 0;
  let container;
  const queue = (time) => {
    if (time >= start + timeout) {
      start = time;
      timeout = speed();
      process2();
    } else if (end) {
      dequeue();
    } else {
      enqueue();
    }
  };
  const process2 = () => {
    const block = nodes[current];
    if (block?.length > pos) {
      const span = block[pos];
      const text2 = span.textContent;
      if (pos++ === 0) {
        span.replaceWith(container = document.createTextNode(text2));
      } else {
        container.textContent += text2;
        span.remove();
      }
      enqueue();
    } else if (current++ < nodes.length) {
      pos = 0;
      enqueue();
    } else {
      end = true;
      dequeue();
      ended && ended();
    }
  };
  process2();
  return {
    /**
     * End
     */
    end() {
      dequeue();
      if (end) {
        node.innerHTML = "";
        return end;
      }
      node.innerHTML = text;
      end = true;
      return false;
    },
    /**
     * Destroy
     */
    destroy() {
      dequeue();
      node.innerHTML = "";
    }
  };
};

// src/constants.ts
var TEXT_SPEED_MAP = {
  Slow: () => 120,
  Medium: () => 90,
  Fast: () => 60,
  Auto: void 0
};
var svg = (children2) => {
  return `<svg width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5">${children2}</svg>`;
};
var settingsIcons = {
  language: svg('<circle cx="12" cy="12" r="7.25" /><path d="M15.25 12c0 4.5-2.007 7.25-3.25 7.25-1.243 0-3.25-2.75-3.25-7.25S10.757 4.75 12 4.75c1.243 0 3.25 2.75 3.25 7.25ZM5 12h14" />'),
  typewriter_speed: svg('<path d="M4.75 17.25 8 6.75l3.25 10.5M6 14.25h4M19.25 14.5a2.75 2.75 0 1 1-5.5 0 2.75 2.75 0 0 1 5.5 0ZM19.25 11.75v5.5" />'),
  music_volume: svg('<circle cx="7" cy="17" r="2.25" /><path d="M9.25 17V6.75a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2V14"/><circle cx="17" cy="14" r="2.25" />'),
  sound_volume: svg('<path d="M15.75 10.75s.5.484.5 1.25-.5 1.25-.5 1.25M17.75 7.75s1.5 1.25 1.5 4.249c0 2.998-1.5 4.25-1.5 4.25M13.25 4.75l-4.75 4H5.75a1 1 0 0 0-1 1v4.5a1 1 0 0 0 1 1H8.5l4.75 4V4.75Z"/>'),
  voice_volume: svg('<path d="M5.75 19.25v-.509a2 2 0 0 1 1.588-1.957l1.521-.32a1.752 1.752 0 0 0 1.391-1.714m8 4.5v-.509a2 2 0 0 0-1.588-1.957l-1.521-.32a1.751 1.751 0 0 1-1.391-1.714m-3.905-.467c-1.255-1.27-2.23-3.138-2.08-4.947C7.977 6.808 9.035 4.75 12 4.75c2.963 0 4.022 2.058 4.233 4.586.156 1.865-.706 3.792-2.017 5.062-1.234 1.197-3.161 1.109-4.37-.115Z"/>')
};

// src/components/Typewriter.tsx
var _tmpl$20 = /* @__PURE__ */ template(`<span>`);
var PRM = matchMedia("(prefers-reduced-motion: reduce)");
var createTypewriter = ({
  resolve
}) => {
  let bypassed = false;
  let typewriter2;
  const [state, setState] = createSignal("idle");
  const Typewriter = (props) => {
    let node;
    createEffect(() => {
      const text = props.content;
      typewriter2?.destroy();
      setState("idle");
      if (!text) return;
      if (!node) return;
      if (PRM.matches || untrack(() => props.ignore)) {
        node.innerHTML = text;
        bypassed = true;
        setState("done");
        return;
      }
      setState("processing");
      typewriter2 = typewriter({
        node,
        text,
        ended() {
          setState("done");
          untrack(() => props.ended(PRM.matches));
        },
        speed: TEXT_SPEED_MAP[untrack(() => props.speed)]
      });
      bypassed = false;
    });
    onCleanup(() => {
      setState("idle");
      typewriter2?.destroy();
      bypassed = false;
    });
    return (() => {
      const _el$ = _tmpl$20();
      const _ref$ = node;
      typeof _ref$ === "function" ? use(_ref$, _el$) : node = _el$;
      spread(_el$, mergeProps(() => props.attributes), false, false);
      return _el$;
    })();
  };
  const clear = () => {
    const reduced = PRM.matches;
    const written = typewriter2 && typewriter2.end();
    if (reduced || written || bypassed) {
      bypassed = false;
      setState("idle");
      resolve();
    } else {
      setState("done");
    }
  };
  return {
    Typewriter,
    clear,
    state
  };
};

// src/components/Canvas.tsx
var _tmpl$21 = /* @__PURE__ */ template(`<canvas>`);
var Canvas = (props) => {
  const [local, rest] = splitProps(props, ["resize", "render"]);
  const [canvas, setCanvas] = createSignal();
  const ctx = createMemo(() => {
    const canvasElement = canvas();
    if (!canvasElement) {
      return null;
    }
    return canvasElement.getContext("2d");
  });
  createEffect(() => {
    const canvasElement = canvas();
    const canvasContext = ctx();
    if (canvasElement && canvasContext) {
      try {
        local.render(canvasElement, canvasContext);
      } catch {
      }
    }
  });
  const onResize = () => {
    if (!local.resize) return;
    const canvasElement = untrack(canvas);
    const canvasContext = untrack(ctx);
    if (canvasElement) {
      canvasElement.width = window.innerWidth * devicePixelRatio;
      canvasElement.height = window.innerHeight * devicePixelRatio;
      if (canvasContext) {
        untrack(() => {
          try {
            local.render(canvasElement, canvasContext);
          } catch {
          }
        });
      }
    }
  };
  onMount(onResize);
  addEventListener("resize", onResize);
  onCleanup(() => {
    removeEventListener("resize", onResize);
  });
  return (() => {
    const _el$ = _tmpl$21();
    use(setCanvas, _el$);
    spread(_el$, rest, false, false);
    return _el$;
  })();
};

// src/components/Select.tsx
var _tmpl$25 = /* @__PURE__ */ template(`<div class="select"><label class="select__label"><span class="select__label__icon"></span> </label><div class="select__select-container"><select>`);
var Select = (props) => {
  const [local, rest] = splitProps(props, ["icon", "label"]);
  const id = createUniqueId();
  return (() => {
    const _el$ = _tmpl$25(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.nextSibling, _el$5 = _el$2.nextSibling, _el$6 = _el$5.firstChild;
    setAttribute(_el$2, "for", id);
    setAttribute(_el$3, "aria-hidden", true);
    insert(_el$2, () => local.label, null);
    spread(_el$6, mergeProps(rest, {
      "class": "select__select",
      "id": id
    }), false, true);
    insert(_el$6, () => props.children);
    insert(_el$5, createComponent(Icon, {
      "class": "select__icon",
      "aria-hidden": true,
      get children() {
        return createComponent(Icon.ChevronDown, {});
      }
    }), null);
    createRenderEffect(() => _el$3.innerHTML = local.icon);
    return _el$;
  })();
};

// src/components/Range.tsx
var _tmpl$26 = /* @__PURE__ */ template(`<div class="range"><label class="range__label"><span class="range__label__icon"></span> </label><input>`);
var Range = (props) => {
  const [local, rest] = splitProps(props, ["icon", "label"]);
  const id = createUniqueId();
  return (() => {
    const _el$ = _tmpl$26(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.nextSibling, _el$5 = _el$2.nextSibling;
    setAttribute(_el$2, "for", id);
    setAttribute(_el$3, "aria-hidden", true);
    insert(_el$2, () => local.label, null);
    spread(_el$5, mergeProps(rest, {
      "class": "range__range",
      "type": "range",
      "id": id
    }), false, false);
    createRenderEffect(() => _el$3.innerHTML = local.icon);
    return _el$;
  })();
};

// ../../node_modules/.pnpm/@solid-primitives+destructure@0.1.17_solid-js@1.8.19/node_modules/@solid-primitives/destructure/dist/index.js
var isReactiveObject = (value) => typeof value === "object" && value !== null;
function createProxyCache(obj, get) {
  return new Proxy(
    {},
    {
      get: (target, key) => {
        if (key === Symbol.iterator || key === "length")
          return Reflect.get(obj, key);
        const saved = Reflect.get(target, key);
        if (saved)
          return saved;
        const value = get(key);
        Reflect.set(target, key, value);
        return value;
      },
      set: () => false
    }
  );
}
function destructure(source, options) {
  const config = options ?? {};
  const memo2 = config.memo ?? typeof source === "function";
  const getter = typeof source === "function" ? (key) => () => source()[key] : (key) => () => source[key];
  const obj = access(source);
  if (config.lazy) {
    const owner = getOwner();
    return createProxyCache(obj, (key) => {
      const calc = getter(key);
      if (config.deep && isReactiveObject(obj[key]))
        return runWithOwner(owner, () => destructure(calc, { ...config, memo: memo2 }));
      return memo2 ? runWithOwner(owner, () => createMemo(calc, void 0, options)) : calc;
    });
  }
  const result = Array.isArray(obj) ? [] : {};
  for (const [key, value] of Object.entries(obj)) {
    const calc = getter(key);
    if (config.deep && isReactiveObject(value))
      result[key] = destructure(calc, { ...config, memo: memo2 });
    else
      result[key] = memo2 ? createMemo(calc, void 0, options) : calc;
  }
  return result;
}

// src/screens/game.tsx
var _tmpl$27 = /* @__PURE__ */ template(`<div class="action-dialog-person">`);
var _tmpl$28 = /* @__PURE__ */ template(`<div class="dialog-container"><span class="dialog-fix" aria-hidden="true">&#8203;</span><div class="dialog-panel"><span class="dialog-panel-label">`);
var _tmpl$34 = /* @__PURE__ */ template(`<div class="dialog-container"><span class="dialog-fix" aria-hidden="true">&#8203;</span><div class="dialog-panel input-dialog-panel"><label for="novely-input" class="input-dialog-label"><span class="input-dialog-label-text"></span></label><span class="input-dialog-label-text input-dialog-label__error" aria-live="polite" aria-atomic="true"></span><button type="submit" class="button dialog-input__button">`);
var _tmpl$44 = /* @__PURE__ */ template(`<div class="dialog-container"><span class="dialog-fix" aria-hidden="true">&#8203;</span><div class="dialog-backdrop"></div><div class="dialog-panel exit-dialog-panel"><span class="dialog-panel-label"></span><div class="exit-dialog-panel-buttons"><button type="button" class="button"></button><button type="button" class="button">`);
var _tmpl$53 = /* @__PURE__ */ template(`<button type="button" class="button control-panel__button">`);
var _tmpl$62 = /* @__PURE__ */ template(`<span class="control-panel-container-fix" aria-hidden="true">&#8203;`);
var _tmpl$72 = /* @__PURE__ */ template(`<div class="control-panel-container-backdrop">`);
var _tmpl$82 = /* @__PURE__ */ template(`<div class="control-panel"><div role="menubar" class="control-panel-container">`);
var _tmpl$92 = /* @__PURE__ */ template(`<div><div class="characters"></div><div class="action-dialog"><div class="action-dialog-container" role="button" tabindex="0"><div class="action-dialog-content"></div></div></div><div></div><div class="action-text" role="button" tabindex="0">`);
var _tmpl$102 = /* @__PURE__ */ template(`<button type="button" class="button">`);
var Game = (props) => {
  const data = useData();
  const {
    $contextState
  } = props;
  const contextState = () => {
    const accessor = from($contextState);
    return () => {
      return accessor();
    };
  };
  const {
    text,
    dialog,
    characters,
    choice,
    input,
    background,
    custom
  } = destructure(contextState());
  const rendererState = from(data.$rendererState);
  const {
    store,
    context,
    controls,
    skipTypewriterWhenGoingBack
  } = props;
  const [auto, setAuto] = createSignal(false);
  const onChoicesButtonClick = ([disabled, i]) => {
    if (disabled) return;
    choice().resolve?.(i);
  };
  const onInputButtonClick = () => {
    if (input().error) return;
    const {
      resolve,
      cleanup
    } = input();
    cleanup?.();
    resolve?.();
  };
  const customs = () => {
    return Object.values(custom());
  };
  const speed = () => data.storageData().meta[1];
  const onWriterEnd = (cb) => {
    return (prm) => {
      const next = untrack(auto);
      if (!next) return;
      if (prm) {
        setAuto(false);
      } else {
        untrack(cb);
      }
    };
  };
  const TextWriter = createTypewriter({
    resolve() {
      text().resolve?.();
    }
  });
  const DialogWriter = createTypewriter({
    resolve() {
      dialog().resolve?.();
    }
  });
  const controlPanelMenuID = createUniqueId();
  const [controlPanelMenuExpanded, setControlPanelMenuExpanded] = createSignal(false);
  createEffect(() => {
    if (!data.media.hyperWide()) {
      setControlPanelMenuExpanded(false);
    }
  });
  const charactersCount = createMemo(() => {
    return Object.values(characters()).reduce((acc, c) => {
      if (c && c.visible) {
        return acc + 1;
      }
      return acc;
    }, 0);
  });
  return (() => {
    const _el$ = _tmpl$92(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling, _el$4 = _el$3.firstChild, _el$6 = _el$4.firstChild, _el$26 = _el$3.nextSibling, _el$27 = _el$26.nextSibling;
    insert(_el$, createComponent(Canvas, {
      "class": "background",
      resize: false,
      render: async (canvas, ctx) => {
        const bg = background().background;
        const isColor = !isCSSImage(bg);
        if (isColor) {
          ctx.fillStyle = bg;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        } else {
          const img = await imagePreloadWithCaching(bg);
          if (bg !== background().background) {
            return;
          }
          const {
            clientWidth,
            clientHeight
          } = context.root;
          const maxFactor = 1 / Math.ceil(Math.max(img.width / clientWidth, img.height / clientHeight));
          canvas.width = Math.min(img.width * maxFactor, img.width) * devicePixelRatio;
          canvas.height = Math.min(img.height * maxFactor, img.height) * devicePixelRatio;
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        }
      }
    }), _el$2);
    setAttribute(_el$2, "data-characters", true);
    insert(_el$2, createComponent(For, {
      get each() {
        return Object.entries(characters());
      },
      children: ([character, data2]) => createComponent(Show, {
        get when() {
          return data2 && data2.visible;
        },
        get children() {
          return createComponent(Character, {
            character,
            data: data2,
            get characters() {
              return store.characters;
            }
          });
        }
      })
    }));
    insert(_el$3, createComponent(DialogName, {
      get character() {
        return dialog().miniature.character;
      },
      get name() {
        return dialog().name;
      }
    }), _el$4);
    addEventListener2(_el$4, "keydown", onKey(DialogWriter.clear, " "), true);
    addEventListener2(_el$4, "keypress", onKey(DialogWriter.clear, "Enter"));
    addEventListener2(_el$4, "click", DialogWriter.clear, true);
    insert(_el$4, createComponent(Show, {
      get when() {
        return dialog().miniature.emotion;
      },
      get children() {
        const _el$5 = _tmpl$27();
        insert(_el$5, createComponent(Show, {
          get when() {
            return dialog().miniature.emotion;
          },
          keyed: true,
          children: (emotion) => {
            const character = dialog().miniature.character;
            if (!character) return null;
            if (!store.characters[character] || !store.characters[character].emotions[emotion]) {
              context.character(character).emotion(emotion, false);
            }
            const image = store.characters[character].emotions[emotion];
            if ("src" in image) return image;
            const canvas = document.createElement("canvas");
            canvasDrawImages(canvas, void 0, Object.values(image));
            return canvas;
          }
        }));
        return _el$5;
      }
    }), _el$6);
    insert(_el$6, createComponent(DialogWriter.Typewriter, {
      get attributes() {
        return {
          title: DialogWriter.state() === "idle" ? void 0 : data.t(DialogWriter.state() === "processing" ? "CompleteText" : "GoForward")
        };
      },
      get content() {
        return dialog().content;
      },
      get ignore() {
        return skipTypewriterWhenGoingBack && context.meta.goingBack || Boolean(props.isPreview);
      },
      get speed() {
        return speed();
      },
      get ended() {
        return onWriterEnd(DialogWriter.clear);
      }
    }));
    insert(_el$, createComponent(Modal, {
      isOpen: () => choice().visible,
      trapFocus: () => !props.isPreview && !rendererState().exitPromptShown,
      get children() {
        const _el$7 = _tmpl$28(), _el$8 = _el$7.firstChild, _el$9 = _el$8.nextSibling, _el$10 = _el$9.firstChild;
        insert(_el$10, () => choice().label || " ");
        insert(_el$9, createComponent(For, {
          get each() {
            return choice().choices;
          },
          children: ([text2, active], i) => {
            const disabled = !active;
            const index = i();
            return (() => {
              const _el$33 = _tmpl$102();
              _el$33.$$click = onChoicesButtonClick;
              _el$33.$$clickData = [disabled, index];
              setAttribute(_el$33, "aria-disabled", disabled);
              insert(_el$33, text2);
              return _el$33;
            })();
          }
        }), null);
        createRenderEffect((_p$) => {
          const _v$ = Boolean(choice().label), _v$2 = !choice().label;
          _v$ !== _p$._v$ && setAttribute(_el$10, "data-used", _p$._v$ = _v$);
          _v$2 !== _p$._v$2 && setAttribute(_el$10, "aria-hidden", _p$._v$2 = _v$2);
          return _p$;
        }, {
          _v$: void 0,
          _v$2: void 0
        });
        return _el$7;
      }
    }), _el$26);
    insert(_el$, createComponent(Modal, {
      isOpen: () => input().visible,
      trapFocus: () => !props.isPreview && !rendererState().exitPromptShown,
      get children() {
        const _el$11 = _tmpl$34(), _el$12 = _el$11.firstChild, _el$13 = _el$12.nextSibling, _el$14 = _el$13.firstChild, _el$15 = _el$14.firstChild, _el$16 = _el$14.nextSibling, _el$17 = _el$16.nextSibling;
        insert(_el$15, () => input().label);
        insert(_el$14, () => input().element, null);
        insert(_el$16, () => input().error);
        _el$17.$$click = onInputButtonClick;
        insert(_el$17, () => data.t("Sumbit"));
        createRenderEffect(() => setAttribute(_el$17, "aria-disabled", Boolean(input().error)));
        return _el$11;
      }
    }), _el$26);
    insert(_el$, createComponent(Modal, {
      isOpen: () => rendererState().exitPromptShown && !props.isPreview,
      trapFocus: () => !props.isPreview && rendererState().exitPromptShown,
      get children() {
        const _el$18 = _tmpl$44(), _el$19 = _el$18.firstChild, _el$20 = _el$19.nextSibling, _el$21 = _el$20.nextSibling, _el$22 = _el$21.firstChild, _el$23 = _el$22.nextSibling, _el$24 = _el$23.firstChild, _el$25 = _el$24.nextSibling;
        insert(_el$22, () => data.t("ExitDialogWarning"));
        _el$24.$$click = () => {
          data.$rendererState.setKey("exitPromptShown", false);
        };
        insert(_el$24, () => data.t("ExitDialogBack"));
        _el$25.$$click = () => {
          data.options.exit(true);
        };
        insert(_el$25, () => data.t("ExitDialogExit"));
        return _el$18;
      }
    }), _el$26);
    setAttribute(_el$26, "data-custom", true);
    insert(_el$26, createComponent(For, {
      get each() {
        return customs();
      },
      children: (value) => value.node
    }));
    addEventListener2(_el$27, "keydown", onKey(TextWriter.clear, " "), true);
    addEventListener2(_el$27, "keypress", onKey(TextWriter.clear, "Enter"));
    addEventListener2(_el$27, "click", TextWriter.clear, true);
    insert(_el$27, createComponent(TextWriter.Typewriter, {
      get attributes() {
        return {
          title: TextWriter.state() === "idle" ? void 0 : data.t(TextWriter.state() === "processing" ? "CompleteText" : "GoForward")
        };
      },
      get content() {
        return text().content;
      },
      get ignore() {
        return skipTypewriterWhenGoingBack && context.meta.goingBack || Boolean(props.isPreview);
      },
      get speed() {
        return speed();
      },
      get ended() {
        return onWriterEnd(TextWriter.clear);
      }
    }));
    insert(_el$, createComponent(Show, {
      get when() {
        return !props.isPreview;
      },
      get children() {
        const _el$28 = _tmpl$82(), _el$32 = _el$28.firstChild;
        insert(_el$28, createComponent(Show, {
          get when() {
            return data.media.hyperWide();
          },
          get children() {
            return createComponent(Show, {
              get when() {
                return !controlPanelMenuExpanded();
              },
              get children() {
                const _el$29 = _tmpl$53();
                _el$29.$$click = () => {
                  setControlPanelMenuExpanded((prev) => !prev);
                };
                setAttribute(_el$29, "aria-controls", controlPanelMenuID);
                insert(_el$29, createComponent(Icon, {
                  get children() {
                    return Icon.Menu();
                  }
                }));
                createRenderEffect((_p$) => {
                  const _v$3 = data.t("OpenMenu"), _v$4 = controlPanelMenuExpanded();
                  _v$3 !== _p$._v$3 && setAttribute(_el$29, "title", _p$._v$3 = _v$3);
                  _v$4 !== _p$._v$4 && setAttribute(_el$29, "aria-expanded", _p$._v$4 = _v$4);
                  return _p$;
                }, {
                  _v$3: void 0,
                  _v$4: void 0
                });
                return _el$29;
              }
            });
          }
        }), _el$32);
        insert(_el$28, createComponent(Show, {
          get when() {
            return createMemo(() => !!(data.media.hyperWide() && controlPanelMenuExpanded()))() && !rendererState().exitPromptShown;
          },
          get children() {
            return [_tmpl$62(), _tmpl$72()];
          }
        }), _el$32);
        use((element) => {
          clickOutside(element, () => {
            if (untrack(data.media.hyperWide) && untrack(controlPanelMenuExpanded)) {
              setControlPanelMenuExpanded(false);
            }
          });
        }, _el$32);
        setAttribute(_el$32, "id", controlPanelMenuID);
        _el$32.classList.toggle("control-panel-container--center", !!(controls === "inside"));
        insert(_el$32, createComponent(ControlPanelButtons, {
          openSettings: () => {
            data.$rendererState.setKey("screen", "settings");
          },
          closeDropdown: () => {
            setControlPanelMenuExpanded(false);
          },
          auto,
          setAuto
        }));
        createRenderEffect((_p$) => {
          const _v$5 = !!(data.media.hyperWide() && !controlPanelMenuExpanded()), _v$6 = !!(data.media.hyperWide() && controlPanelMenuExpanded());
          _v$5 !== _p$._v$5 && _el$32.classList.toggle("control-panel-container--wide-closed", _p$._v$5 = _v$5);
          _v$6 !== _p$._v$6 && _el$32.classList.toggle("control-panel-container--wide-open", _p$._v$6 = _v$6);
          return _p$;
        }, {
          _v$5: void 0,
          _v$6: void 0
        });
        return _el$28;
      }
    }), null);
    createRenderEffect((_p$) => {
      const _v$7 = `${props.className || ""} game`, _v$8 = !!props.isPreview, _v$9 = charactersCount(), _v$10 = !!dialog().visible, _v$11 = !dialog().visible, _v$12 = !(dialog().miniature.character && dialog().miniature.emotion), _v$13 = !dialog().content, _v$14 = !!props.isPreview, _v$15 = !!Boolean(text().content), _v$16 = !text().content;
      _v$7 !== _p$._v$7 && className(_el$, _p$._v$7 = _v$7);
      _v$8 !== _p$._v$8 && _el$.classList.toggle("preview", _p$._v$8 = _v$8);
      _v$9 !== _p$._v$9 && ((_p$._v$9 = _v$9) != null ? _el$2.style.setProperty("--shown-characters-count", _v$9) : _el$2.style.removeProperty("--shown-characters-count"));
      _v$10 !== _p$._v$10 && _el$3.classList.toggle("action-dialog--visible", _p$._v$10 = _v$10);
      _v$11 !== _p$._v$11 && _el$3.classList.toggle("action-dialog--hidden", _p$._v$11 = _v$11);
      _v$12 !== _p$._v$12 && setAttribute(_el$4, "data-no-person", _p$._v$12 = _v$12);
      _v$13 !== _p$._v$13 && setAttribute(_el$4, "aria-disabled", _p$._v$13 = _v$13);
      _v$14 !== _p$._v$14 && _el$6.classList.toggle("action-dialog-content--disable-shadow", _p$._v$14 = _v$14);
      _v$15 !== _p$._v$15 && _el$27.classList.toggle("action-text--shown", _p$._v$15 = _v$15);
      _v$16 !== _p$._v$16 && setAttribute(_el$27, "aria-disabled", _p$._v$16 = _v$16);
      return _p$;
    }, {
      _v$7: void 0,
      _v$8: void 0,
      _v$9: void 0,
      _v$10: void 0,
      _v$11: void 0,
      _v$12: void 0,
      _v$13: void 0,
      _v$14: void 0,
      _v$15: void 0,
      _v$16: void 0
    });
    return _el$;
  })();
};
delegateEvents(["click", "keydown"]);

// src/screens/loading.tsx
var _tmpl$29 = /* @__PURE__ */ template(`<div class="loading"><div class="loading__animation"><div></div><div></div><div></div><div>`);
var Loading = (props) => {
  return (() => {
    const _el$ = _tmpl$29();
    createRenderEffect(() => _el$.classList.toggle("overlay", !!props.overlay));
    return _el$;
  })();
};

// src/screens/mainmenu.tsx
var _tmpl$30 = /* @__PURE__ */ template(`<div class="main-menu"><div class="main-menu__controls"><button type="button" class="button main-menu__button"><span class="main-menu__button__text"></span></button><button type="button" class="button main-menu__button"><span class="main-menu__button__text"></span></button><button type="button" class="button main-menu__button"><span class="main-menu__button__text"></span></button><button type="button" class="button main-menu__button"><span class="main-menu__button__text">`);
var _tmpl$210 = /* @__PURE__ */ template(`<button>`);
var MainMenu = () => {
  const {
    t,
    storageData,
    coreData,
    options,
    $rendererState
  } = useData();
  const language = () => storageData().meta[0];
  const rendererStore = from($rendererState);
  const goto = simple((screen) => {
    if (!coreData().dataLoaded) return;
    $rendererState.mutate((s) => s.screen, screen);
  });
  return (() => {
    const _el$ = _tmpl$30(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.firstChild, _el$5 = _el$3.nextSibling, _el$6 = _el$5.firstChild, _el$7 = _el$5.nextSibling, _el$8 = _el$7.firstChild, _el$9 = _el$7.nextSibling, _el$10 = _el$9.firstChild;
    _el$3.$$click = () => {
      options.newGame();
    };
    insert(_el$4, () => t("NewGame"));
    insert(_el$3, createComponent(Icon, {
      children: Icon.FilePlus()
    }), null);
    _el$5.$$click = () => {
      options.restore();
    };
    insert(_el$6, () => t("LoadSave"));
    insert(_el$5, createComponent(Icon, {
      children: Icon.Play()
    }), null);
    _el$7.$$click = () => {
      goto("saves");
    };
    insert(_el$8, () => t("Saves"));
    insert(_el$7, createComponent(Icon, {
      children: Icon.Files()
    }), null);
    _el$9.$$click = () => {
      goto("settings");
    };
    insert(_el$10, () => t("Settings"));
    insert(_el$9, createComponent(Icon, {
      children: Icon.Settings()
    }), null);
    insert(_el$2, createComponent(Show, {
      get when() {
        return language();
      },
      keyed: true,
      children: (_) => createComponent(For, {
        get each() {
          return rendererStore().mainmenu;
        },
        children: (item) => (() => {
          const _el$11 = _tmpl$210();
          spread(_el$11, mergeProps(() => item(goto)), false, false);
          return _el$11;
        })()
      })
    }), null);
    return _el$;
  })();
};
delegateEvents(["click"]);

// src/screens/saves.tsx
var _tmpl$31 = /* @__PURE__ */ template(`<ol class="saves__list">`);
var _tmpl$211 = /* @__PURE__ */ template(`<div class="saves"><div class="saves__controls"><button type="button" class="button saves__button"></button></div><div class="saves__list-container">`);
var _tmpl$35 = /* @__PURE__ */ template(`<div class="saves__list saves__list--empty">`);
var Saves = () => {
  const {
    t,
    storageData,
    $rendererState
  } = useData();
  const [list, setList] = createSignal();
  const [loadingAllowed, setLoadingAllowed] = createSignal([]);
  const [previewCompleted, setPreviewCompleted] = createSignal([]);
  const [observedTargets, setObservedTargets] = createSignal([]);
  const saves = () => storageData().saves.slice().reverse();
  const language = () => storageData().meta[0];
  const processed = /* @__PURE__ */ new Set();
  onMount(() => {
    const listElement = list();
    if (!listElement) return;
    const observer = new IntersectionObserver((entries2) => {
      const currentEntryTimestamps = [];
      entries2.forEach((entry) => {
        if (!entry.isIntersecting) return;
        if (processed.has(entry.target)) return;
        if (!(entry.target instanceof HTMLElement)) return;
        processed.add(entry.target);
        setLoadingAllowed((prev) => {
          if (entry.target instanceof HTMLElement) {
            const timestamp = entry.target.dataset.timestamp;
            if (timestamp) {
              const parsed = Number(timestamp);
              if (Number.isFinite(parsed)) {
                currentEntryTimestamps.push(parsed);
                return [...prev, Number(timestamp)];
              }
              return prev;
            }
          }
          return prev;
        });
      });
      if (currentEntryTimestamps.length > 0) {
        setObservedTargets((targets) => [...targets, currentEntryTimestamps]);
      }
    }, {
      root: listElement
    });
    listElement.childNodes.forEach((childNode) => {
      if (childNode instanceof HTMLElement) {
        observer.observe(childNode);
        onCleanup(() => {
          observer.unobserve(childNode);
        });
      }
    });
    onCleanup(() => {
      observer.disconnect();
    });
  });
  const isOverlayShown = (timestamp) => {
    const observed = observedTargets();
    const completed = previewCompleted();
    const targets = observed.find((array) => array.includes(timestamp));
    if (!targets) {
      return true;
    }
    return !targets.every((item) => completed.includes(item));
  };
  return (() => {
    const _el$ = _tmpl$211(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$2.nextSibling;
    _el$3.$$click = () => {
      $rendererState.setKey("screen", "mainmenu");
    };
    insert(_el$3, () => t("GoBack"));
    insert(_el$4, createComponent(Show, {
      get when() {
        return saves().length > 0;
      },
      get fallback() {
        return (() => {
          const _el$6 = _tmpl$35();
          insert(_el$6, () => t("NoSaves"));
          return _el$6;
        })();
      },
      get children() {
        const _el$5 = _tmpl$31();
        use(setList, _el$5);
        insert(_el$5, createComponent(For, {
          get each() {
            return saves();
          },
          children: (save) => createComponent(Save, {
            save,
            get language() {
              return language();
            },
            get observed() {
              return loadingAllowed().includes(save[2][0]);
            },
            get overlayShown() {
              return isOverlayShown(save[2][0]);
            },
            onPreviewDone: () => {
              setPreviewCompleted((completed) => [...completed, save[2][0]]);
            }
          })
        }));
        return _el$5;
      }
    }));
    return _el$;
  })();
};
delegateEvents(["click"]);

// src/screens/settings.tsx
var _tmpl$36 = /* @__PURE__ */ template(`<div class="root settings"><div class="settings__controls"><button type="button" class="button settings__button"></button><button type="button" class="button settings__button"></button></div><div class="settings__options"><div></div><div>`);
var _tmpl$212 = /* @__PURE__ */ template(`<option>`);
var Settings = (props) => {
  const {
    t,
    storageData,
    storageDataUpdate,
    options,
    $rendererState
  } = useData();
  const language = () => storageData().meta[0];
  const textSpeed = () => storageData().meta[1];
  const volume = (kind) => storageData().meta[kind];
  const onLanguageSelect = ({
    currentTarget: {
      value
    }
  }) => {
    storageDataUpdate((prev) => {
      prev.meta[0] = value;
      return prev;
    });
  };
  const onSpeedSelect = ({
    currentTarget: {
      value
    }
  }) => {
    storageDataUpdate((prev) => {
      prev.meta[1] = value;
      return prev;
    });
  };
  const volumeChange = (kind) => {
    const fn = ({
      currentTarget: {
        valueAsNumber
      }
    }) => {
      storageDataUpdate((prev) => {
        prev.meta[kind] = valueAsNumber;
        return prev;
      });
    };
    return fn;
  };
  return (() => {
    const _el$ = _tmpl$36(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.nextSibling, _el$5 = _el$2.nextSibling, _el$6 = _el$5.firstChild, _el$7 = _el$6.nextSibling;
    _el$3.$$click = () => {
      $rendererState.setKey("screen", "mainmenu");
    };
    insert(_el$3, () => t("HomeScreen"));
    _el$4.$$click = () => {
      options.restore();
    };
    insert(_el$4, () => t("ToTheGame"));
    insert(_el$6, createComponent(Select, {
      get icon() {
        return props.icons.language;
      },
      get label() {
        return t("Language");
      },
      onChange: onLanguageSelect,
      get children() {
        return createComponent(For, {
          get each() {
            return options.languages;
          },
          children: (lang) => (() => {
            const _el$8 = _tmpl$212();
            _el$8.value = lang;
            insert(_el$8, () => options.getLanguageDisplayName(lang));
            createRenderEffect(() => _el$8.selected = lang === language());
            return _el$8;
          })()
        });
      }
    }), null);
    insert(_el$6, createComponent(Select, {
      get icon() {
        return props.icons.typewriter_speed;
      },
      get label() {
        return t("TextSpeed");
      },
      onChange: onSpeedSelect,
      get children() {
        return createComponent(For, {
          each: ["Slow", "Medium", "Fast", "Auto"],
          children: (speed) => (() => {
            const _el$9 = _tmpl$212();
            _el$9.value = speed;
            insert(_el$9, () => t("TextSpeed" + speed));
            createRenderEffect(() => _el$9.selected = speed === textSpeed());
            return _el$9;
          })()
        });
      }
    }), null);
    insert(_el$7, createComponent(Range, {
      get icon() {
        return props.icons.music_volume;
      },
      get label() {
        return t("MusicVolume");
      },
      min: 0,
      max: 1,
      step: 0.01,
      get value() {
        return volume(2);
      },
      get onChange() {
        return volumeChange(2);
      }
    }), null);
    insert(_el$7, createComponent(Range, {
      get icon() {
        return props.icons.sound_volume;
      },
      get label() {
        return t("SoundVolume");
      },
      min: 0,
      max: 1,
      step: 0.01,
      get value() {
        return volume(3);
      },
      get onChange() {
        return volumeChange(3);
      }
    }), null);
    insert(_el$7, createComponent(Range, {
      get icon() {
        return props.icons.voice_volume;
      },
      get label() {
        return t("VoiceVolume");
      },
      min: 0,
      max: 1,
      step: 0.01,
      get value() {
        return volume(4);
      },
      get onChange() {
        return volumeChange(4);
      }
    }), null);
    createRenderEffect(() => _el$7.classList.toggle("settings--hidden", !props.showAudioSettings));
    return _el$;
  })();
};
delegateEvents(["click"]);

// src/components/Root.tsx
var _tmpl$37 = /* @__PURE__ */ template(`<div class="root">`);
var createRootComponent = ({
  $rendererState,
  $contextState,
  coreOptions,
  setRoot,
  renderer,
  showAudioSettings,
  fullscreen,
  emitter,
  controls,
  skipTypewriterWhenGoingBack,
  settingsIcons: settingsIcons2,
  rendererContext
}) => {
  const Root = () => {
    const screen = from(memo($rendererState, (state) => state.screen));
    const loadingShown = from(memo($rendererState, (state) => state.loadingShown));
    createEffect(() => {
      const currentScreen = screen();
      if (fullscreen && document.fullscreenEnabled) {
        if (currentScreen === "game" && !document.fullscreenElement) {
          document.documentElement.requestFullscreen().catch(() => {
          });
        } else if (currentScreen === "mainmenu" && document.fullscreenElement && "exitFullscreen" in document) {
          document.exitFullscreen().catch(() => {
          });
        }
      }
      if (currentScreen !== "game" && currentScreen !== "settings" && !loadingShown()) {
        rendererContext.audio.destroy();
      }
      emitter.emit("screen:change", currentScreen);
    });
    return (() => {
      const _el$ = _tmpl$37();
      const _ref$ = setRoot;
      typeof _ref$ === "function" ? use(_ref$, _el$) : setRoot = _el$;
      insert(_el$, createComponent(Provider, {
        $rendererState,
        get storageData() {
          return coreOptions.storageData;
        },
        get coreData() {
          return coreOptions.coreData;
        },
        options: coreOptions,
        renderer,
        emitter,
        get getContext() {
          return renderer.getContext;
        },
        get removeContext() {
          return renderer.removeContext;
        },
        get children() {
          return [createComponent(Switch, {
            get children() {
              return [createComponent(Match, {
                get when() {
                  return screen() === "game";
                },
                get children() {
                  return createComponent(Game, {
                    $contextState,
                    context: rendererContext,
                    controls,
                    skipTypewriterWhenGoingBack,
                    get store() {
                      return useShared(coreOptions.mainContextKey);
                    }
                  });
                }
              }), createComponent(Match, {
                get when() {
                  return screen() === "mainmenu";
                },
                get children() {
                  return createComponent(MainMenu, {});
                }
              }), createComponent(Match, {
                get when() {
                  return screen() === "saves";
                },
                get children() {
                  return createComponent(Saves, {});
                }
              }), createComponent(Match, {
                get when() {
                  return screen() === "settings";
                },
                get children() {
                  return createComponent(Settings, {
                    icons: settingsIcons2,
                    showAudioSettings
                  });
                }
              })];
            }
          }), createComponent(Show, {
            get when() {
              return loadingShown();
            },
            get children() {
              return createComponent(Loading, {
                overlay: true
              });
            }
          }), createComponent(CustomScreen, {
            get name() {
              return screen();
            }
          })];
        }
      }));
      return _el$;
    })();
  };
  return Root;
};

// src/custom-actions/show-hide-image.ts
var SHOW_IMAGE = Symbol();
var showImage = (source, params = {}) => {
  const handler = ({ getDomNodes, clear, flags, data, rendererContext }) => {
    const { promise, resolve } = Promise.withResolvers();
    const { element } = getDomNodes(true);
    {
      element.style.cssText += `position: fixed; inset: 0;`;
      element.style.zIndex = String(params.z || 1);
    }
    const image = document.createElement("img");
    {
      image.src = source;
      image.className = params.class || "";
      image.style.cssText = params.style || "";
      image.style.cssText += `object-fit: cover; object-position: ${params.position || "50% 50%"}; width: 100vw; height: 100vh;`;
    }
    element.appendChild(image);
    data({
      image,
      in: params.in
    });
    let clearAnimation = noop;
    if (params.in && !flags.preview) {
      const classes = params.in.split(" ");
      image.classList.add(...classes);
      clearAnimation = () => {
        image.classList.remove(...classes);
        if (params.await) {
          rendererContext.clearBlockingActions(void 0);
          resolve();
        }
      };
      image.addEventListener("animationend", clearAnimation, { once: true });
    }
    clear(() => {
      data({});
      clearAnimation();
      image.remove();
    });
    if (!params.await) {
      resolve();
    }
    return promise;
  };
  handler.id = SHOW_IMAGE;
  handler.key = source;
  handler.assets = [source];
  handler.skipOnRestore = (getNext) => {
    return getNext().some(([name, fn]) => name === "custom" && fn.key === source);
  };
  return ["custom", handler];
};
var hideImage = (source, params = {}) => {
  const handler = async ({ data, rendererContext }) => {
    const { promise, resolve } = Promise.withResolvers();
    const { image, in: inClasses } = data();
    if (!image) {
      resolve();
      return promise;
    }
    if (inClasses) {
      const classes = inClasses.split(" ");
      image.classList.remove(...classes);
    }
    if (params.out) {
      const classes = params.out.split(" ");
      image.classList.add(...classes);
      const onAnimationEnd = () => {
        image.classList.remove(...classes);
        if (params.await) {
          rendererContext.clearBlockingActions(void 0);
          resolve();
        }
      };
      image.addEventListener("animationend", onAnimationEnd, { once: true });
      if (!params.await) {
        resolve();
      }
    } else {
      resolve();
    }
    return promise;
  };
  handler.id = SHOW_IMAGE;
  handler.key = source;
  handler.assets = [source];
  handler.skipOnRestore = (getNext) => {
    return getNext().some(([name, fn]) => name === "custom" && fn.key === source);
  };
  return ["custom", handler];
};

// src/renderer.tsx
var _tmpl$38 = /* @__PURE__ */ template(`<canvas>`);
var {
  preloadAudioBlocking
} = createAudioMisc();
var createSolidRenderer = ({
  fullscreen = false,
  controls = "outside",
  skipTypewriterWhenGoingBack = true,
  target = document.body,
  settingsIcons: settingsIcons2 = settingsIcons,
  showAudioSettings = true
} = {}) => {
  const emitter = createEmitter();
  const $rendererState = createRendererState({
    screens: {},
    mainmenu: []
  });
  const {
    getContextCached,
    removeContext
  } = createGetContext();
  return {
    emitter,
    renderer(options) {
      const {
        characterAssetSizes
      } = options;
      const {
        root,
        setRoot
      } = createRootSetter(() => renderer.getContext(options.mainContextKey));
      const renderer = {
        getContext: getContextCached((name) => {
          const audio = createAudio2(options.storageData);
          const $contextState = useContextState(name);
          const context = {
            id: name,
            root: root(),
            background(background) {
              handleBackgroundAction($contextState, background);
            },
            character(character) {
              const chars = useShared(name).characters;
              if (chars[character]) {
                return chars[character];
              }
              const canvas = (() => {
                const _el$ = _tmpl$38();
                setAttribute(_el$, "data-character", character);
                return _el$;
              })();
              const canvasContext = canvas.getContext("2d");
              const characterHandle = {
                canvas,
                ctx: canvasContext,
                emotions: {},
                async emotion(emotion, shouldRender) {
                  let stored = this.emotions[emotion];
                  if (!stored) {
                    stored = this.emotions[emotion] = options.getCharacterAssets(character, emotion).map((src) => imagePreloadWithCachingNotComplete(src));
                  }
                  if (shouldRender && stored) {
                    canvasContext.clearRect(0, 0, canvas.width, canvas.height);
                    canvas.dataset.resized = "false";
                    if (root() !== context.root) {
                      const {
                        clientWidth: mainClientWidth,
                        clientHeight: mainClientHeight
                      } = root();
                      const {
                        clientWidth: contextClientWidth,
                        clientHeight: contextClientHeight
                      } = context.root;
                      const widthFactor = mainClientWidth / contextClientWidth;
                      const heightFactor = mainClientHeight / contextClientHeight;
                      const maxFactor = Math.ceil(Math.max(widthFactor, heightFactor));
                      canvas.dataset.scaleBy = (1 / maxFactor).toFixed(3);
                    } else {
                      canvas.dataset.scalyBy = "1";
                    }
                    const sizes = characterAssetSizes[character];
                    if (sizes) {
                      const scaleBy = canvas.dataset.scaleBy ? Number(canvas.dataset.scaleBy) : 1;
                      canvas.width = Math.min(sizes.width * scaleBy * 2, sizes.width) * devicePixelRatio;
                      canvas.height = Math.min(sizes.height * scaleBy * 2, sizes.height) * devicePixelRatio;
                      canvas.dataset.resized = "true";
                    }
                    canvasDrawImages(canvas, canvasContext, stored);
                  }
                },
                append(className2, style2) {
                  clearTimeout($contextState.get().characters[character]?.hideTimeoutId);
                  $contextState.mutate((s) => s.characters[character], {
                    style: style2,
                    visible: true
                  });
                  const {
                    canvas: element
                  } = chars[character];
                  element.className = "";
                  if (className2) {
                    void element.offsetHeight;
                    element.className = className2;
                  }
                },
                remove(className2, style2, duration, restoring) {
                  return new Promise((resolve) => {
                    const hide = () => {
                      $contextState.mutate((s) => s.characters[character], (prev) => {
                        return {
                          ...prev,
                          visible: false
                        };
                      });
                    };
                    if (restoring) {
                      hide();
                      resolve();
                      return;
                    }
                    const timeoutId = setTimeout(() => {
                      hide();
                      resolve();
                    }, duration);
                    if (className2) {
                      chars[character].canvas.className = className2;
                    }
                    $contextState.mutate((s) => s.characters[character], (prev) => {
                      return {
                        ...prev,
                        style: style2,
                        hideTimeoutId: timeoutId
                      };
                    });
                  });
                },
                animate(classes) {
                  const target2 = this.canvas;
                  if (!target2) return;
                  const classNames = classes.filter((className2) => !target2.classList.contains(className2));
                  target2.classList.add(...classNames);
                  const onAnimationEnd = () => {
                    target2.classList.remove(...classNames);
                  };
                  target2.addEventListener("animationend", onAnimationEnd, {
                    once: true
                  });
                }
              };
              useShared(name).characters[character] = characterHandle;
              return characterHandle;
            },
            dialog(content, name2, character, emotion, resolve) {
              handleDialogAction($contextState, content, name2, character, emotion, resolve);
            },
            choices(label, choices, resolve) {
              handleChoiceAction($contextState, label, choices, resolve);
            },
            clear(keep, keepCharacters, keepAudio, resolve) {
              handleClearAction($rendererState, $contextState, options, context, keep, keepCharacters);
              audio.clear(keepAudio);
              resolve();
            },
            input(label, onInput, setup, resolve) {
              handleInputAction($contextState, options, context, label, onInput, setup, resolve);
            },
            custom(fn) {
              return handleCustomAction($contextState, fn);
            },
            clearBlockingActions(name2) {
              handleClearBlockingActions($contextState, name2);
            },
            vibrate(pattern) {
              handleVibrateAction(pattern);
            },
            text(content, resolve) {
              handleTextAction($contextState, content, resolve);
            },
            audio: audio.context,
            meta: {
              get restoring() {
                return $contextState.get().meta.restoring;
              },
              set restoring(value) {
                $contextState.mutate((s) => s.meta.restoring, value);
              },
              get preview() {
                return $contextState.get().meta.preview;
              },
              set preview(value) {
                $contextState.mutate((s) => s.meta.preview, value);
              },
              get goingBack() {
                return $contextState.get().meta.goingBack;
              },
              set goingBack(value) {
                $contextState.mutate((s) => s.meta.goingBack, value);
              }
            }
          };
          return context;
        }),
        removeContext(name) {
          removeContext(name);
          removeContextState(name);
        },
        ui: {
          showScreen(name) {
            $rendererState.mutate((s) => s.screen, name);
          },
          getScreen() {
            return $rendererState.get().screen;
          },
          showLoading() {
            $rendererState.mutate((s) => s.loadingShown, true);
          },
          hideLoading() {
            $rendererState.mutate((s) => s.loadingShown, false);
          },
          showExitPrompt() {
            $rendererState.mutate((s) => s.exitPromptShown, true);
          },
          start: createStartFunction(() => {
            const Root = createRootComponent({
              setRoot,
              renderer,
              fullscreen,
              emitter,
              controls,
              skipTypewriterWhenGoingBack,
              settingsIcons: settingsIcons2,
              showAudioSettings,
              rendererContext: renderer.getContext(options.mainContextKey),
              coreOptions: options,
              $rendererState,
              $contextState: useContextState(options.mainContextKey)
            });
            return render(() => createComponent(Root, {}), target);
          })
        },
        misc: {
          preloadImage: (src) => {
            renderer.misc.preloadImageBlocking(src);
            return src;
          },
          preloadImageBlocking: async (src) => {
            await imagePreloadWithCaching(src);
          },
          preloadAudioBlocking
        },
        actions: {
          showImage,
          hideImage
        }
      };
      return renderer;
    },
    registerScreen(name, screen) {
      $rendererState.mutate((s) => s.screens[name], () => screen);
    },
    registerMainmenuItem(fn) {
      $rendererState.mutate((s) => s.mainmenu, (mainmenu) => [...mainmenu, fn]);
    }
  };
};
export {
  createSolidRenderer
};
