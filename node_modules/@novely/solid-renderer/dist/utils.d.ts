/**
 * Using this because `Array.prototype.findLast` has not enough support
 * @see https://caniuse.com/?search=findLast
 */
declare const findLast: <T>(array: T[], fn: (this: T[], item: T, index: number, array: T[]) => boolean) => T;
declare const capitalize: (str: string) => string;
declare const isCSSImage: (str: string) => boolean;
declare const createImage: (src: string) => HTMLImageElement;
declare const imageLoaded: (image: HTMLImageElement) => Promise<boolean>;
/**
 * Uses `PRELOADING_IMAGE_MAP` and `PRELOADED_IMAGE_MAP` for asset caching.
 * @param src Image source
 * @returns Loaded image
 */
declare const imagePreloadWithCaching: (src: string) => Promise<HTMLImageElement>;
/**
 * Takes images from `PRELOADING_IMAGE_MAP` and `PRELOADED_IMAGE_MAP` cache. When no images were cached adds images to `PRELOADING_IMAGE_MAP`.
 * @param src Image source
 * @returns Image, load status is unknown
 */
declare const imagePreloadWithCachingNotComplete: (src: string) => HTMLImageElement;
/**
 * Draws passed `images` array on a `canvas`
 */
declare const canvasDrawImages: (canvas: HTMLCanvasElement | undefined, ctx: CanvasRenderingContext2D | undefined, images: HTMLImageElement[]) => Promise<readonly [HTMLCanvasElement, CanvasRenderingContext2D]>;
declare const url: <T extends string>(str: T) => `url(${T})`;
declare const onKey: (cb: (event: KeyboardEvent) => void, ...keys: string[]) => (e: KeyboardEvent) => void;
declare const simple: <T extends unknown[], R>(fn: (...args: T) => R) => (...args: T) => R;
declare const getDocumentStyles: () => string;
/**
 * A wrapper on `fn` to make it run only once!
 * @param fn Function that needed to run no more than one time
 */
declare const once: (fn: () => void) => () => void;
export { isCSSImage, canvasDrawImages, url, createImage, capitalize, onKey, findLast, simple, getDocumentStyles, once, imageLoaded, imagePreloadWithCaching, imagePreloadWithCachingNotComplete };
