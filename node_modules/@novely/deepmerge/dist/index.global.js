"use strict";
var Novely = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    deepmerge: () => deepmerge
  });

  // src/utils.ts
  var { isArray } = Array;
  var { hasOwnProperty, propertyIsEnumerable, getOwnPropertySymbols } = Object;
  var propertyIsOnObject = (object, property) => {
    try {
      return property in object;
    } catch {
      return false;
    }
  };
  var propertyIsUnsafe = (target, key) => {
    return propertyIsOnObject(target, key) && !(hasOwnProperty.call(target, key) && propertyIsEnumerable.call(target, key));
  };
  var getEnumerableOwnPropertySymbols = (target) => {
    if (!getOwnPropertySymbols)
      return [];
    return getOwnPropertySymbols(target).filter((symbol) => propertyIsEnumerable.call(target, symbol));
  };
  var keys = (target) => {
    return [...Object.keys(target), ...getEnumerableOwnPropertySymbols(target)];
  };
  var isMergeableObject = (value) => {
    return !!value && typeof value === "object" && !["RegExp", "Date"].includes(Object.prototype.toString.call(value).slice(8, -1));
  };

  // src/index.ts
  var empty = (value) => {
    return isArray(value) ? [] : {};
  };
  var clone = (value) => {
    return isMergeableObject(value) ? deepmerge(empty(value), value) : value;
  };
  var deepmerge = (target, source) => {
    if (isArray(target) && isArray(source)) {
      const array = target.concat(source).map((element) => clone(element));
      return array;
    } else if (!isArray(target) && !isArray(source)) {
      const destination = {};
      for (const key of keys(target)) {
        destination[key] = clone(target[key]);
      }
      for (const key of keys(source)) {
        if (propertyIsUnsafe(target, key)) {
          continue;
        }
        if (propertyIsOnObject(target, key) && isMergeableObject(source[key])) {
          destination[key] = deepmerge(target[key], source[key]);
        } else {
          destination[key] = clone(source[key]);
        }
      }
      return destination;
    } else {
      return clone(source);
    }
  };
  return __toCommonJS(src_exports);
})();
//# sourceMappingURL=index.global.js.map