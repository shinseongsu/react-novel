// src/utils.ts
var { isArray } = Array;
var { hasOwnProperty, propertyIsEnumerable, getOwnPropertySymbols } = Object;
var propertyIsOnObject = (object, property) => {
  try {
    return property in object;
  } catch {
    return false;
  }
};
var propertyIsUnsafe = (target, key) => {
  return propertyIsOnObject(target, key) && !(hasOwnProperty.call(target, key) && propertyIsEnumerable.call(target, key));
};
var getEnumerableOwnPropertySymbols = (target) => {
  if (!getOwnPropertySymbols)
    return [];
  return getOwnPropertySymbols(target).filter((symbol) => propertyIsEnumerable.call(target, symbol));
};
var keys = (target) => {
  return [...Object.keys(target), ...getEnumerableOwnPropertySymbols(target)];
};
var isMergeableObject = (value) => {
  return !!value && typeof value === "object" && !["RegExp", "Date"].includes(Object.prototype.toString.call(value).slice(8, -1));
};

// src/index.ts
var empty = (value) => {
  return isArray(value) ? [] : {};
};
var clone = (value) => {
  return isMergeableObject(value) ? deepmerge(empty(value), value) : value;
};
var mergeArray = (target, source) => {
  const destination = target.slice();
  source.forEach((item, index) => {
    if (typeof destination[index] === "undefined") {
      destination[index] = clone(item);
    } else if (isMergeableObject(item)) {
      destination[index] = deepmerge(target[index], item);
    } else if (target.indexOf(item) === -1) {
      destination.push(item);
    }
  });
  return destination;
};
var mergeObject = (target, source) => {
  const destination = {};
  for (const key of keys(target)) {
    destination[key] = clone(target[key]);
  }
  for (const key of keys(source)) {
    if (propertyIsUnsafe(target, key)) {
      continue;
    }
    if (propertyIsOnObject(target, key) && isMergeableObject(source[key])) {
      destination[key] = deepmerge(target[key], source[key]);
    } else {
      destination[key] = clone(source[key]);
    }
  }
  return destination;
};
var deepmerge = (target, source) => {
  if (isArray(target) && isArray(source)) {
    const merged = mergeArray(target, source);
    return merged;
  } else if (!isArray(target) && !isArray(source)) {
    const merged = mergeObject(target, source);
    return merged;
  } else {
    return clone(source);
  }
};
export {
  deepmerge
};
//# sourceMappingURL=index.js.map