{"version":3,"sources":["../src/utils.ts","../src/index.ts"],"sourcesContent":["const { isArray } = Array;\nconst { hasOwnProperty, propertyIsEnumerable, getOwnPropertySymbols } = Object;\n\nconst propertyIsOnObject = <T extends Record<PropertyKey, unknown>, K extends PropertyKey>(object: T, property: K): object is T & { [Key in K]: unknown } => {\n\ttry {\n\t\treturn property in object\n\t} catch {\n\t\treturn false\n\t}\n}\n\nconst propertyIsUnsafe = (target: Record<PropertyKey, unknown>, key: PropertyKey) => {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nconst getEnumerableOwnPropertySymbols = (target: Record<PropertyKey, unknown>) => {\n  if (!getOwnPropertySymbols) return [];\n\n  return getOwnPropertySymbols(target).filter(symbol => propertyIsEnumerable.call(target, symbol))\n}\n\nconst keys = <T extends Record<PropertyKey, unknown>>(target: T): (keyof T)[] => {\n  return [...Object.keys(target), ...getEnumerableOwnPropertySymbols(target)];\n}\n\nconst isMergeableObject = (value: unknown): value is Record<PropertyKey, unknown> => {\n  return !!value && typeof value === 'object' && !(['RegExp', 'Date'].includes(Object.prototype.toString.call(value).slice(8, -1)));\n}\n\nexport { isArray, propertyIsOnObject, propertyIsUnsafe, getEnumerableOwnPropertySymbols, isMergeableObject, keys }\n","import { isArray, propertyIsOnObject, propertyIsUnsafe, isMergeableObject, keys } from './utils';\n\nconst empty = <T extends (Record<PropertyKey, unknown> | unknown[])>(value: T): T => {\n  return (isArray(value) ? [] : {}) as T;\n}\n\nconst clone = <T>(value: T): T => {\n  return isMergeableObject(value)\n    ? deepmerge(empty(value), value)\n    : value;\n}\n\nconst mergeArray = <T>(target: T[], source: T[]) => {\n  const destination = target.slice();\n\n  source.forEach((item, index) => {\n    if (typeof destination[index] === 'undefined') {\n      destination[index] = clone(item);\n    } else if (isMergeableObject(item)) {\n      destination[index] = deepmerge(target[index] as any, item as any);\n    } else if (target.indexOf(item) === -1) {\n      destination.push(item);\n    }\n  });\n\n  return destination;\n}\n\nconst mergeObject = <T extends Record<PropertyKey, unknown>>(target: T, source: T): T => {\n  const destination: Record<PropertyKey, any> = {};\n\n  for (const key of keys(target)) {\n    destination[key] = clone(target[key]);\n  }\n\n  for (const key of keys(source)) {\n    if (propertyIsUnsafe(target, key)) {\n      continue;\n    }\n\n    if (propertyIsOnObject(target, key) && isMergeableObject(source[key])) {\n      destination[key] = deepmerge(target[key] as any, source[key] as any);\n    } else {\n      destination[key] = clone(source[key]);\n    }\n  }\n\n  return destination as unknown as T;\n}\n\nconst deepmerge = <T extends (Record<PropertyKey, unknown> | unknown[])>(target: T, source: T): T => {\n  if (isArray(target) && isArray(source)) {\n    const merged = mergeArray(target, source);\n\n    return merged as unknown as T;\n  } else if (!isArray(target) && !isArray(source)) {\n    const merged = mergeObject(target, source);\n\n    return merged as unknown as T;\n  } else {\n    return clone(source);\n  }\n}\n\nexport { deepmerge }\n"],"mappings":";AAAA,IAAM,EAAE,QAAQ,IAAI;AACpB,IAAM,EAAE,gBAAgB,sBAAsB,sBAAsB,IAAI;AAExE,IAAM,qBAAqB,CAAgE,QAAW,aAAuD;AAC5J,MAAI;AACH,WAAO,YAAY;AAAA,EACpB,QAAQ;AACP,WAAO;AAAA,EACR;AACD;AAEA,IAAM,mBAAmB,CAAC,QAAsC,QAAqB;AACpF,SAAO,mBAAmB,QAAQ,GAAG,KACjC,EAAE,eAAe,KAAK,QAAQ,GAAG,KAChC,qBAAqB,KAAK,QAAQ,GAAG;AAC3C;AAEA,IAAM,kCAAkC,CAAC,WAAyC;AAChF,MAAI,CAAC;AAAuB,WAAO,CAAC;AAEpC,SAAO,sBAAsB,MAAM,EAAE,OAAO,YAAU,qBAAqB,KAAK,QAAQ,MAAM,CAAC;AACjG;AAEA,IAAM,OAAO,CAAyC,WAA2B;AAC/E,SAAO,CAAC,GAAG,OAAO,KAAK,MAAM,GAAG,GAAG,gCAAgC,MAAM,CAAC;AAC5E;AAEA,IAAM,oBAAoB,CAAC,UAA0D;AACnF,SAAO,CAAC,CAAC,SAAS,OAAO,UAAU,YAAY,CAAE,CAAC,UAAU,MAAM,EAAE,SAAS,OAAO,UAAU,SAAS,KAAK,KAAK,EAAE,MAAM,GAAG,EAAE,CAAC;AACjI;;;AC3BA,IAAM,QAAQ,CAAuD,UAAgB;AACnF,SAAQ,QAAQ,KAAK,IAAI,CAAC,IAAI,CAAC;AACjC;AAEA,IAAM,QAAQ,CAAI,UAAgB;AAChC,SAAO,kBAAkB,KAAK,IAC1B,UAAU,MAAM,KAAK,GAAG,KAAK,IAC7B;AACN;AAEA,IAAM,aAAa,CAAI,QAAa,WAAgB;AAClD,QAAM,cAAc,OAAO,MAAM;AAEjC,SAAO,QAAQ,CAAC,MAAM,UAAU;AAC9B,QAAI,OAAO,YAAY,KAAK,MAAM,aAAa;AAC7C,kBAAY,KAAK,IAAI,MAAM,IAAI;AAAA,IACjC,WAAW,kBAAkB,IAAI,GAAG;AAClC,kBAAY,KAAK,IAAI,UAAU,OAAO,KAAK,GAAU,IAAW;AAAA,IAClE,WAAW,OAAO,QAAQ,IAAI,MAAM,IAAI;AACtC,kBAAY,KAAK,IAAI;AAAA,IACvB;AAAA,EACF,CAAC;AAED,SAAO;AACT;AAEA,IAAM,cAAc,CAAyC,QAAW,WAAiB;AACvF,QAAM,cAAwC,CAAC;AAE/C,aAAW,OAAO,KAAK,MAAM,GAAG;AAC9B,gBAAY,GAAG,IAAI,MAAM,OAAO,GAAG,CAAC;AAAA,EACtC;AAEA,aAAW,OAAO,KAAK,MAAM,GAAG;AAC9B,QAAI,iBAAiB,QAAQ,GAAG,GAAG;AACjC;AAAA,IACF;AAEA,QAAI,mBAAmB,QAAQ,GAAG,KAAK,kBAAkB,OAAO,GAAG,CAAC,GAAG;AACrE,kBAAY,GAAG,IAAI,UAAU,OAAO,GAAG,GAAU,OAAO,GAAG,CAAQ;AAAA,IACrE,OAAO;AACL,kBAAY,GAAG,IAAI,MAAM,OAAO,GAAG,CAAC;AAAA,IACtC;AAAA,EACF;AAEA,SAAO;AACT;AAEA,IAAM,YAAY,CAAuD,QAAW,WAAiB;AACnG,MAAI,QAAQ,MAAM,KAAK,QAAQ,MAAM,GAAG;AACtC,UAAM,SAAS,WAAW,QAAQ,MAAM;AAExC,WAAO;AAAA,EACT,WAAW,CAAC,QAAQ,MAAM,KAAK,CAAC,QAAQ,MAAM,GAAG;AAC/C,UAAM,SAAS,YAAY,QAAQ,MAAM;AAEzC,WAAO;AAAA,EACT,OAAO;AACL,WAAO,MAAM,MAAM;AAAA,EACrB;AACF;","names":[]}