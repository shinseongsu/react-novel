{"version":3,"sources":["../src/constants.ts","../src/parser.ts","../src/printer.ts","../src/transformer.ts","../src/traverse.ts"],"sourcesContent":["const NEW_LINE = '\\n';\n\nexport { NEW_LINE };\n","import type { Ast, AstNode } from './types';\nimport { NEW_LINE } from './constants';\n\nconst parse_line = (str: string) => {\n\tlet ident = 0;\n\n\twhile (str.slice(0, 2) === '  ') {\n\t\tident += 1;\n\t\tstr = str.slice(2, str.length);\n\t}\n\n\treturn { ident, content: str };\n};\n\nconst push = <T>(list: unknown, item: T) => {\n\tif (list && typeof list === 'object' && 'children' in list && Array.isArray(list.children)) {\n\t\tlist.children.push(item);\n\t} else if (Array.isArray(list)) {\n\t\tlist.push(item);\n\t} else if (\n\t\tlist &&\n\t\ttypeof list === 'object' &&\n\t\t'content' in list &&\n\t\ttypeof list.content === 'string' &&\n\t\titem &&\n\t\ttypeof item === 'object' &&\n\t\t'content' in item &&\n\t\ttypeof item.content === 'string'\n\t) {\n\t\tlist.content += NEW_LINE + item.content;\n\t}\n\n\treturn item;\n};\n\nconst parse = (source: string) => {\n\tconst lines = source.split(NEW_LINE);\n\tconst ast: Ast = [];\n\n\tconst elevator: AstNode[] = [];\n\n\tconst parse_expression = (expression: string, parent: AstNode | undefined): AstNode => {\n\t\tif (expression.startsWith('!')) {\n\t\t\tconst [name, ...items] = expression.slice(1).split(' ');\n\n\t\t\tconst content = items.join(' ');\n\n\t\t\tconst matches = [...content.matchAll(/(?:\"([^\"]*)\")|([^\\s\"]+)/gm)]\n\t\t\t\t.map(([, one, two]) => one || two)\n\t\t\t\t.map((match) => {\n\t\t\t\t\tif (match.startsWith('%')) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: 'JSValue',\n\t\t\t\t\t\t\tcontent: match.slice(1),\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: 'Value',\n\t\t\t\t\t\tcontent: match,\n\t\t\t\t\t};\n\t\t\t\t}) as Extract<AstNode, { type: 'Value' | 'JSValue' }>[];\n\n\t\t\treturn {\n\t\t\t\ttype: 'Action',\n\t\t\t\tname: name,\n\t\t\t\tchildren: matches,\n\t\t\t};\n\t\t} else if (expression === '*') {\n\t\t\treturn {\n\t\t\t\ttype: 'Map',\n\t\t\t\tchildren: [],\n\t\t\t};\n\t\t} else if (expression === '=') {\n\t\t\treturn {\n\t\t\t\ttype: 'Array',\n\t\t\t\tchildren: [],\n\t\t\t};\n\t\t} else if (expression.startsWith('%')) {\n\t\t\treturn {\n\t\t\t\ttype: 'JSValue',\n\t\t\t\tcontent: expression.slice(1),\n\t\t\t};\n\t\t} else if (expression.startsWith('\\\\')) {\n\t\t\treturn {\n\t\t\t\ttype: 'Value',\n\t\t\t\tcontent: expression.slice(1),\n\t\t\t};\n\t\t} else if (parent?.type === 'Map') {\n\t\t\treturn {\n\t\t\t\ttype: 'MapItem',\n\t\t\t\tname: expression,\n\t\t\t\tchildren: [],\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttype: 'Value',\n\t\t\t\tcontent: expression,\n\t\t\t};\n\t\t}\n\t};\n\n\tfor (const line of lines) {\n\t\tconst { ident, content } = parse_line(line);\n\n\t\tif (ident === 0) {\n\t\t\televator[ident] = push(ast, {\n\t\t\t\ttype: 'Property',\n\t\t\t\tname: content,\n\t\t\t\tchildren: [],\n\t\t\t});\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst expression = parse_expression(content, elevator[ident - 1]);\n\n\t\televator[ident] = push(elevator[ident - 1], expression);\n\t}\n\n\treturn ast;\n};\n\nexport { parse };\n","import type { Ast, AstNode, PrintOptions } from './types';\nimport { NEW_LINE } from './constants';\n\nconst DOUBLE_SPACE = '  ';\n\nconst to_number = (value: string) => {\n\tconst numeralized = Number(value);\n\tconst isString = isNaN(numeralized) || !isFinite(numeralized);\n\n\treturn isString ? '' : numeralized;\n}\n\nconst print = (ast: Ast, {}: PrintOptions = {}) => {\n\tlet code = '';\n\n\tconst print_js_value = (value: Extract<AstNode, { type: 'JSValue' }>, depth: number, short: boolean) => {\n\t\treturn `${short ? '' : DOUBLE_SPACE.repeat(depth)}%${value.content}`;\n\t};\n\n\tconst print_array = (value: Extract<AstNode, { type: 'Array' }>, depth: number): string => {\n\t\tconst children = value.children.map((child) => print_with_unknown_printer(child, depth + 1));\n\n\t\treturn `${DOUBLE_SPACE.repeat(depth)}=${NEW_LINE}${children.join(NEW_LINE)}`;\n\t};\n\n\tconst print_value = (value: Extract<AstNode, { type: 'Value' }>, depth: number, short: boolean) => {\n\t\tconst num = to_number(value.content);\n\t\tconst start = DOUBLE_SPACE.repeat(depth);\n\n\t\tif (typeof num === 'number') {\n\t\t\tif (short) {\n\t\t\t\treturn value.content;\n\t\t\t}\n\n\t\t\treturn start + value.content;\n\t\t}\n\n\t\tconst isMultiline = value.content.startsWith(NEW_LINE);\n\n\t\tif (isMultiline) {\n\t\t\tif (short) {\n\t\t\t\tthrow new Error('Cannot be both `multiline` and `short`');\n\t\t\t}\n\n\t\t\tconst offset = start + DOUBLE_SPACE;\n\n\t\t\treturn `${start}\\\\${value.content.split(NEW_LINE).map((s, i) => i === 0 ? '' : offset + s).join(NEW_LINE)}`\n\t\t}\n\n\t\tif (short) {\n\t\t\tconst has = String.prototype.includes.bind(value.content);\n\t\t\tconst needToEscape = has(' ') || has('\"');\n\n\t\t\tif (needToEscape) {\n\t\t\t\treturn JSON.stringify(value.content)\n\t\t\t}\n\n\t\t\treturn value.content;\n\t\t}\n\n\t\treturn `${start}\\\\${value.content}`;\n\t};\n\n\tconst print_map_item = (value: Extract<AstNode, { type: 'MapItem' }>, depth: number) => {\n\t\tconst children = value.children.map((child) => print_with_unknown_printer(child, depth + 1)).join(NEW_LINE);\n\n\t\treturn `${DOUBLE_SPACE.repeat(depth)}${value.name}${NEW_LINE}${children}`\n\t}\n\n\tconst print_map = (value: Extract<AstNode, { type: 'Map' }>, depth: number): string => {\n\t\tconst children = value.children.map((child) => print_map_item(child, depth + 1));\n\n\t\treturn `${DOUBLE_SPACE.repeat(depth)}*${NEW_LINE}${children.join(NEW_LINE)}`\n\t};\n\n\tconst print_action = (value: Extract<AstNode, { type: 'Action' }>, depth: number): string => {\n\t\tconst all_is_number = value.children.every((item) => item.type !== 'Map' && item.type !== 'Array' && typeof to_number(item.content) === 'number') && value.children.length > 1;\n\t\tconst has_map_or_array = value.children.some((item) => item.type === 'Map' || item.type === 'Array');\n\t\tconst larger_than_80 = value.children.map((item) => (item.type === 'Map' || item.type === 'Array') ? '' : item.content).join('').length > 80;\n\t\tconst is_starts_with_new_line = value.children.some((item) => item.type === 'Value' && item.content.startsWith('\\n'));\n\n\t\tconst long = all_is_number || has_map_or_array || larger_than_80 || is_starts_with_new_line;\n\t\tconst short = !long;\n\n\t\tconst children = value.children.map((child) => print_with_unknown_printer(child, depth + 1, short)).join(short ? ' ' : NEW_LINE);\n\n\t\treturn `${DOUBLE_SPACE.repeat(depth)}!${value.name}${short ? ' ' : NEW_LINE}${children}`\n\t};\n\n\tconst print_with_unknown_printer = (child: AstNode, depth: number, short = false) => {\n\t\tif (child.type === 'Value') {\n\t\t\treturn print_value(child, depth, short);\n\t\t} else if (child.type === 'JSValue') {\n\t\t\treturn print_js_value(child, depth, short);\n\t\t} else if (child.type === 'Map') {\n\t\t\treturn print_map(child, depth);\n\t\t} else if (child.type === 'Action') {\n\t\t\treturn print_action(child, depth);\n\t\t} else if (child.type === 'Array') {\n\t\t\treturn print_array(child, depth);\n\t\t} else {\n\t\t\treturn '';\n\t\t}\n\t};\n\n\tfor (const top of ast) {\n\t\tcode += `${top.name}${top.name ? NEW_LINE : ''}`\n\n\t\tfor (const child of top.children) {\n\t\t\tcode += print_with_unknown_printer(child, 1) + NEW_LINE;\n\t\t}\n\t}\n\n\treturn code;\n}\n\nexport { print }\nexport type { PrintOptions } from './types'\n","import type { Ast, AstNode, TransformOptions } from './types';\n\nconst RESERVED = ['undefined', 'null', 'window', 'globalThis', '()', '$actions'];\n\nconst transform = (ast: Ast, { rewrites = {}, useWith = false }: TransformOptions = {}) => {\n\tlet code = useWith ? '($actions, $values1) => { with($values1) { return {' : '($actions, $values1) => ({';\n\n\tconst print_js_value = (value: Extract<AstNode, { type: 'JSValue' }>) => {\n\t\tconst isReserved = RESERVED.some((reserved) => value.content.startsWith(reserved));\n\n\t\tif (useWith || isReserved) {\n\t\t\treturn value.content;\n\t\t}\n\n\t\treturn `$values1.${value.content}`;\n\t};\n\n\tconst print_array = (value: Extract<AstNode, { type: 'Array' }>): string => {\n\t\treturn `[${value.children.map((child) => print_with_unknown_printer(child)).join(',')}]`;\n\t};\n\n\tconst print_value = (value: Extract<AstNode, { type: 'Value' }>) => {\n\t\tconst numeralized = Number(value.content);\n\n\t\tif (isNaN(numeralized) || !isFinite(numeralized)) {\n\t\t\treturn JSON.stringify(value.content);\n\t\t} else {\n\t\t\treturn value.content;\n\t\t}\n\t};\n\n\tconst print_map = (value: Extract<AstNode, { type: 'Map' }>) => {\n\t\tlet result = '{';\n\n\t\tfor (const child of value.children) {\n\t\t\tresult += print_map_item(child) + ',';\n\t\t}\n\n\t\treturn result + '}';\n\t};\n\n\tconst print_action = (value: Extract<AstNode, { type: 'Action' }>): string => {\n\t\tconst children = value.children.map((child) => print_with_unknown_printer(child));\n\t\tconst name = value.name in rewrites ? rewrites[value.name] : value.name;\n\n\t\treturn `$actions[\"${name}\"](${children.join(',')})`;\n\t};\n\n\tconst print_with_unknown_printer = (child: AstNode) => {\n\t\tif (child.type === 'Value') {\n\t\t\treturn print_value(child);\n\t\t} else if (child.type === 'JSValue') {\n\t\t\treturn print_js_value(child);\n\t\t} else if (child.type === 'Map') {\n\t\t\treturn print_map(child);\n\t\t} else if (child.type === 'Action') {\n\t\t\treturn print_action(child);\n\t\t} else if (child.type === 'Array') {\n\t\t\treturn print_array(child);\n\t\t} else {\n\t\t\treturn '';\n\t\t}\n\t};\n\n\tconst print_map_item = (value: Extract<AstNode, { type: 'MapItem' }>) => {\n\t\tlet result = value.name + ':[';\n\n\t\tfor (const child of value.children) {\n\t\t\tresult += print_with_unknown_printer(child) + ',';\n\t\t}\n\n\t\treturn result + ']';\n\t};\n\n\tfor (const top of ast) {\n\t\tif (top.name === '') continue;\n\n\t\tcode += top.name + ':[';\n\n\t\tfor (const child of top.children) {\n\t\t\tcode += print_with_unknown_printer(child) + ',';\n\t\t}\n\n\t\tcode += '],';\n\t}\n\n\treturn code + (useWith ? '} } }' : '})');\n};\n\nexport { transform };\n","import type { Ast, AstNode } from './types';\n\nconst traverse = (ast: Ast | AstNode, cb: (item: AstNode) => void) => {\n  if ('type' in ast) {\n    if (ast.type === 'Property' || ast.type === 'Action' || ast.type === 'Array' || ast.type === 'Map' || ast.type === 'MapItem') {\n      cb(ast);\n\n      for (const child of ast.children) {\n        traverse(child, cb);\n      }\n    } else if (ast.type === 'JSValue' || ast.type === 'Value') {\n      cb(ast)\n    }\n\n    return;\n  }\n\n  for (const property of ast) {\n    traverse(property, cb);\n  }\n}\n\nexport { traverse }\n"],"mappings":"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","names":[]}