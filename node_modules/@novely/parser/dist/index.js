// src/constants.ts
var NEW_LINE = "\n";

// src/parser.ts
var parse_line = (str) => {
  let ident = 0;
  while (str.slice(0, 2) === "  ") {
    ident += 1;
    str = str.slice(2, str.length);
  }
  return { ident, content: str };
};
var push = (list, item) => {
  if (list && typeof list === "object" && "children" in list && Array.isArray(list.children)) {
    list.children.push(item);
  } else if (Array.isArray(list)) {
    list.push(item);
  } else if (list && typeof list === "object" && "content" in list && typeof list.content === "string" && item && typeof item === "object" && "content" in item && typeof item.content === "string") {
    list.content += NEW_LINE + item.content;
  }
  return item;
};
var parse = (source) => {
  const lines = source.split(NEW_LINE);
  const ast = [];
  const elevator = [];
  const parse_expression = (expression, parent) => {
    if (expression.startsWith("!")) {
      const [name, ...items] = expression.slice(1).split(" ");
      const content = items.join(" ");
      const matches = [...content.matchAll(/(?:"([^"]*)")|([^\s"]+)/gm)].map(([, one, two]) => one || two).map((match) => {
        if (match.startsWith("%")) {
          return {
            type: "JSValue",
            content: match.slice(1)
          };
        }
        return {
          type: "Value",
          content: match
        };
      });
      return {
        type: "Action",
        name,
        children: matches
      };
    } else if (expression === "*") {
      return {
        type: "Map",
        children: []
      };
    } else if (expression === "=") {
      return {
        type: "Array",
        children: []
      };
    } else if (expression.startsWith("%")) {
      return {
        type: "JSValue",
        content: expression.slice(1)
      };
    } else if (expression.startsWith("\\")) {
      return {
        type: "Value",
        content: expression.slice(1)
      };
    } else if (parent?.type === "Map") {
      return {
        type: "MapItem",
        name: expression,
        children: []
      };
    } else {
      return {
        type: "Value",
        content: expression
      };
    }
  };
  for (const line of lines) {
    const { ident, content } = parse_line(line);
    if (ident === 0) {
      elevator[ident] = push(ast, {
        type: "Property",
        name: content,
        children: []
      });
      continue;
    }
    const expression = parse_expression(content, elevator[ident - 1]);
    elevator[ident] = push(elevator[ident - 1], expression);
  }
  return ast;
};

// src/printer.ts
var DOUBLE_SPACE = "  ";
var to_number = (value) => {
  const numeralized = Number(value);
  const isString = isNaN(numeralized) || !isFinite(numeralized);
  return isString ? "" : numeralized;
};
var print = (ast, {} = {}) => {
  let code = "";
  const print_js_value = (value, depth, short) => {
    return `${short ? "" : DOUBLE_SPACE.repeat(depth)}%${value.content}`;
  };
  const print_array = (value, depth) => {
    const children = value.children.map((child) => print_with_unknown_printer(child, depth + 1));
    return `${DOUBLE_SPACE.repeat(depth)}=${NEW_LINE}${children.join(NEW_LINE)}`;
  };
  const print_value = (value, depth, short) => {
    const num = to_number(value.content);
    const start = DOUBLE_SPACE.repeat(depth);
    if (typeof num === "number") {
      if (short) {
        return value.content;
      }
      return start + value.content;
    }
    const isMultiline = value.content.startsWith(NEW_LINE);
    if (isMultiline) {
      if (short) {
        throw new Error("Cannot be both `multiline` and `short`");
      }
      const offset = start + DOUBLE_SPACE;
      return `${start}\\${value.content.split(NEW_LINE).map((s, i) => i === 0 ? "" : offset + s).join(NEW_LINE)}`;
    }
    if (short) {
      const has = String.prototype.includes.bind(value.content);
      const needToEscape = has(" ") || has('"');
      if (needToEscape) {
        return JSON.stringify(value.content);
      }
      return value.content;
    }
    return `${start}\\${value.content}`;
  };
  const print_map_item = (value, depth) => {
    const children = value.children.map((child) => print_with_unknown_printer(child, depth + 1)).join(NEW_LINE);
    return `${DOUBLE_SPACE.repeat(depth)}${value.name}${NEW_LINE}${children}`;
  };
  const print_map = (value, depth) => {
    const children = value.children.map((child) => print_map_item(child, depth + 1));
    return `${DOUBLE_SPACE.repeat(depth)}*${NEW_LINE}${children.join(NEW_LINE)}`;
  };
  const print_action = (value, depth) => {
    const all_is_number = value.children.every((item) => item.type !== "Map" && item.type !== "Array" && typeof to_number(item.content) === "number") && value.children.length > 1;
    const has_map_or_array = value.children.some((item) => item.type === "Map" || item.type === "Array");
    const larger_than_80 = value.children.map((item) => item.type === "Map" || item.type === "Array" ? "" : item.content).join("").length > 80;
    const is_starts_with_new_line = value.children.some((item) => item.type === "Value" && item.content.startsWith("\n"));
    const long = all_is_number || has_map_or_array || larger_than_80 || is_starts_with_new_line;
    const short = !long;
    const children = value.children.map((child) => print_with_unknown_printer(child, depth + 1, short)).join(short ? " " : NEW_LINE);
    return `${DOUBLE_SPACE.repeat(depth)}!${value.name}${short ? " " : NEW_LINE}${children}`;
  };
  const print_with_unknown_printer = (child, depth, short = false) => {
    if (child.type === "Value") {
      return print_value(child, depth, short);
    } else if (child.type === "JSValue") {
      return print_js_value(child, depth, short);
    } else if (child.type === "Map") {
      return print_map(child, depth);
    } else if (child.type === "Action") {
      return print_action(child, depth);
    } else if (child.type === "Array") {
      return print_array(child, depth);
    } else {
      return "";
    }
  };
  for (const top of ast) {
    code += `${top.name}${top.name ? NEW_LINE : ""}`;
    for (const child of top.children) {
      code += print_with_unknown_printer(child, 1) + NEW_LINE;
    }
  }
  return code;
};

// src/transformer.ts
var RESERVED = ["undefined", "null", "window", "globalThis", "()", "$actions"];
var transform = (ast, { rewrites = {}, useWith = false } = {}) => {
  let code = useWith ? "($actions, $values1) => { with($values1) { return {" : "($actions, $values1) => ({";
  const print_js_value = (value) => {
    const isReserved = RESERVED.some((reserved) => value.content.startsWith(reserved));
    if (useWith || isReserved) {
      return value.content;
    }
    return `$values1.${value.content}`;
  };
  const print_array = (value) => {
    return `[${value.children.map((child) => print_with_unknown_printer(child)).join(",")}]`;
  };
  const print_value = (value) => {
    const numeralized = Number(value.content);
    if (isNaN(numeralized) || !isFinite(numeralized)) {
      return JSON.stringify(value.content);
    } else {
      return value.content;
    }
  };
  const print_map = (value) => {
    let result = "{";
    for (const child of value.children) {
      result += print_map_item(child) + ",";
    }
    return result + "}";
  };
  const print_action = (value) => {
    const children = value.children.map((child) => print_with_unknown_printer(child));
    const name = value.name in rewrites ? rewrites[value.name] : value.name;
    return `$actions["${name}"](${children.join(",")})`;
  };
  const print_with_unknown_printer = (child) => {
    if (child.type === "Value") {
      return print_value(child);
    } else if (child.type === "JSValue") {
      return print_js_value(child);
    } else if (child.type === "Map") {
      return print_map(child);
    } else if (child.type === "Action") {
      return print_action(child);
    } else if (child.type === "Array") {
      return print_array(child);
    } else {
      return "";
    }
  };
  const print_map_item = (value) => {
    let result = value.name + ":[";
    for (const child of value.children) {
      result += print_with_unknown_printer(child) + ",";
    }
    return result + "]";
  };
  for (const top of ast) {
    if (top.name === "")
      continue;
    code += top.name + ":[";
    for (const child of top.children) {
      code += print_with_unknown_printer(child) + ",";
    }
    code += "],";
  }
  return code + (useWith ? "} } }" : "})");
};

// src/traverse.ts
var traverse = (ast, cb) => {
  if ("type" in ast) {
    if (ast.type === "Property" || ast.type === "Action" || ast.type === "Array" || ast.type === "Map" || ast.type === "MapItem") {
      cb(ast);
      for (const child of ast.children) {
        traverse(child, cb);
      }
    } else if (ast.type === "JSValue" || ast.type === "Value") {
      cb(ast);
    }
    return;
  }
  for (const property of ast) {
    traverse(property, cb);
  }
};
export {
  parse,
  print,
  transform,
  traverse
};
//# sourceMappingURL=index.js.map