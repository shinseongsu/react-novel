var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});

// node_modules/esm-env/dev-browser.js
var DEV = true;

// node_modules/micro-memoize/dist/micro-memoize.esm.js
var DEFAULT_OPTIONS_KEYS = {
  isEqual: true,
  isMatchingKey: true,
  isPromise: true,
  maxSize: true,
  onCacheAdd: true,
  onCacheChange: true,
  onCacheHit: true,
  transformKey: true
};
var slice = Array.prototype.slice;
function cloneArray(arrayLike) {
  var length = arrayLike.length;
  if (!length) {
    return [];
  }
  if (length === 1) {
    return [arrayLike[0]];
  }
  if (length === 2) {
    return [arrayLike[0], arrayLike[1]];
  }
  if (length === 3) {
    return [arrayLike[0], arrayLike[1], arrayLike[2]];
  }
  return slice.call(arrayLike, 0);
}
function getCustomOptions(options) {
  var customOptions = {};
  for (var key in options) {
    if (!DEFAULT_OPTIONS_KEYS[key]) {
      customOptions[key] = options[key];
    }
  }
  return customOptions;
}
function isMemoized(fn) {
  return typeof fn === "function" && fn.isMemoized;
}
function isSameValueZero(object1, object2) {
  return object1 === object2 || object1 !== object1 && object2 !== object2;
}
function mergeOptions(existingOptions, newOptions) {
  var target = {};
  for (var key in existingOptions) {
    target[key] = existingOptions[key];
  }
  for (var key in newOptions) {
    target[key] = newOptions[key];
  }
  return target;
}
var Cache = (
  /** @class */
  function() {
    function Cache2(options) {
      this.keys = [];
      this.values = [];
      this.options = options;
      var isMatchingKeyFunction = typeof options.isMatchingKey === "function";
      if (isMatchingKeyFunction) {
        this.getKeyIndex = this._getKeyIndexFromMatchingKey;
      } else if (options.maxSize > 1) {
        this.getKeyIndex = this._getKeyIndexForMany;
      } else {
        this.getKeyIndex = this._getKeyIndexForSingle;
      }
      this.canTransformKey = typeof options.transformKey === "function";
      this.shouldCloneArguments = this.canTransformKey || isMatchingKeyFunction;
      this.shouldUpdateOnAdd = typeof options.onCacheAdd === "function";
      this.shouldUpdateOnChange = typeof options.onCacheChange === "function";
      this.shouldUpdateOnHit = typeof options.onCacheHit === "function";
    }
    Object.defineProperty(Cache2.prototype, "size", {
      /**
       * The number of cached [key,value] results.
       */
      get: function() {
        return this.keys.length;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Cache2.prototype, "snapshot", {
      /**
       * A copy of the cache at a moment in time. This is useful
       * to compare changes over time, since the cache mutates
       * internally for performance reasons.
       */
      get: function() {
        return {
          keys: cloneArray(this.keys),
          size: this.size,
          values: cloneArray(this.values)
        };
      },
      enumerable: false,
      configurable: true
    });
    Cache2.prototype._getKeyIndexFromMatchingKey = function(keyToMatch) {
      var _a = this.options, isMatchingKey = _a.isMatchingKey, maxSize = _a.maxSize;
      var keys2 = this.keys;
      var keysLength = keys2.length;
      if (!keysLength) {
        return -1;
      }
      if (isMatchingKey(keys2[0], keyToMatch)) {
        return 0;
      }
      if (maxSize > 1) {
        for (var index = 1; index < keysLength; index++) {
          if (isMatchingKey(keys2[index], keyToMatch)) {
            return index;
          }
        }
      }
      return -1;
    };
    Cache2.prototype._getKeyIndexForMany = function(keyToMatch) {
      var isEqual = this.options.isEqual;
      var keys2 = this.keys;
      var keysLength = keys2.length;
      if (!keysLength) {
        return -1;
      }
      if (keysLength === 1) {
        return this._getKeyIndexForSingle(keyToMatch);
      }
      var keyLength = keyToMatch.length;
      var existingKey;
      var argIndex;
      if (keyLength > 1) {
        for (var index = 0; index < keysLength; index++) {
          existingKey = keys2[index];
          if (existingKey.length === keyLength) {
            argIndex = 0;
            for (; argIndex < keyLength; argIndex++) {
              if (!isEqual(existingKey[argIndex], keyToMatch[argIndex])) {
                break;
              }
            }
            if (argIndex === keyLength) {
              return index;
            }
          }
        }
      } else {
        for (var index = 0; index < keysLength; index++) {
          existingKey = keys2[index];
          if (existingKey.length === keyLength && isEqual(existingKey[0], keyToMatch[0])) {
            return index;
          }
        }
      }
      return -1;
    };
    Cache2.prototype._getKeyIndexForSingle = function(keyToMatch) {
      var keys2 = this.keys;
      if (!keys2.length) {
        return -1;
      }
      var existingKey = keys2[0];
      var length = existingKey.length;
      if (keyToMatch.length !== length) {
        return -1;
      }
      var isEqual = this.options.isEqual;
      if (length > 1) {
        for (var index = 0; index < length; index++) {
          if (!isEqual(existingKey[index], keyToMatch[index])) {
            return -1;
          }
        }
        return 0;
      }
      return isEqual(existingKey[0], keyToMatch[0]) ? 0 : -1;
    };
    Cache2.prototype.orderByLru = function(key, value, startingIndex) {
      var keys2 = this.keys;
      var values = this.values;
      var currentLength = keys2.length;
      var index = startingIndex;
      while (index--) {
        keys2[index + 1] = keys2[index];
        values[index + 1] = values[index];
      }
      keys2[0] = key;
      values[0] = value;
      var maxSize = this.options.maxSize;
      if (currentLength === maxSize && startingIndex === currentLength) {
        keys2.pop();
        values.pop();
      } else if (startingIndex >= maxSize) {
        keys2.length = values.length = maxSize;
      }
    };
    Cache2.prototype.updateAsyncCache = function(memoized) {
      var _this = this;
      var _a = this.options, onCacheChange = _a.onCacheChange, onCacheHit = _a.onCacheHit;
      var firstKey = this.keys[0];
      var firstValue = this.values[0];
      this.values[0] = firstValue.then(function(value) {
        if (_this.shouldUpdateOnHit) {
          onCacheHit(_this, _this.options, memoized);
        }
        if (_this.shouldUpdateOnChange) {
          onCacheChange(_this, _this.options, memoized);
        }
        return value;
      }, function(error) {
        var keyIndex = _this.getKeyIndex(firstKey);
        if (keyIndex !== -1) {
          _this.keys.splice(keyIndex, 1);
          _this.values.splice(keyIndex, 1);
        }
        throw error;
      });
    };
    return Cache2;
  }()
);
function createMemoizedFunction(fn, options) {
  if (options === void 0) {
    options = {};
  }
  if (isMemoized(fn)) {
    return createMemoizedFunction(fn.fn, mergeOptions(fn.options, options));
  }
  if (typeof fn !== "function") {
    throw new TypeError("You must pass a function to `memoize`.");
  }
  var _a = options.isEqual, isEqual = _a === void 0 ? isSameValueZero : _a, isMatchingKey = options.isMatchingKey, _b = options.isPromise, isPromise2 = _b === void 0 ? false : _b, _c = options.maxSize, maxSize = _c === void 0 ? 1 : _c, onCacheAdd = options.onCacheAdd, onCacheChange = options.onCacheChange, onCacheHit = options.onCacheHit, transformKey = options.transformKey;
  var normalizedOptions = mergeOptions({
    isEqual,
    isMatchingKey,
    isPromise: isPromise2,
    maxSize,
    onCacheAdd,
    onCacheChange,
    onCacheHit,
    transformKey
  }, getCustomOptions(options));
  var cache = new Cache(normalizedOptions);
  var keys2 = cache.keys, values = cache.values, canTransformKey = cache.canTransformKey, shouldCloneArguments = cache.shouldCloneArguments, shouldUpdateOnAdd = cache.shouldUpdateOnAdd, shouldUpdateOnChange = cache.shouldUpdateOnChange, shouldUpdateOnHit = cache.shouldUpdateOnHit;
  var memoized = function() {
    var key = shouldCloneArguments ? cloneArray(arguments) : arguments;
    if (canTransformKey) {
      key = transformKey(key);
    }
    var keyIndex = keys2.length ? cache.getKeyIndex(key) : -1;
    if (keyIndex !== -1) {
      if (shouldUpdateOnHit) {
        onCacheHit(cache, normalizedOptions, memoized);
      }
      if (keyIndex) {
        cache.orderByLru(keys2[keyIndex], values[keyIndex], keyIndex);
        if (shouldUpdateOnChange) {
          onCacheChange(cache, normalizedOptions, memoized);
        }
      }
    } else {
      var newValue = fn.apply(this, arguments);
      var newKey = shouldCloneArguments ? key : cloneArray(arguments);
      cache.orderByLru(newKey, newValue, keys2.length);
      if (isPromise2) {
        cache.updateAsyncCache(memoized);
      }
      if (shouldUpdateOnAdd) {
        onCacheAdd(cache, normalizedOptions, memoized);
      }
      if (shouldUpdateOnChange) {
        onCacheChange(cache, normalizedOptions, memoized);
      }
    }
    return values[0];
  };
  memoized.cache = cache;
  memoized.fn = fn;
  memoized.isMemoized = true;
  memoized.options = normalizedOptions;
  return memoized;
}

// node_modules/dequal/lite/index.mjs
var has = Object.prototype.hasOwnProperty;
function dequal(foo, bar) {
  var ctor, len;
  if (foo === bar) return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date) return foo.getTime() === bar.getTime();
    if (ctor === RegExp) return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len])) ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}

// node_modules/yocto-queue/index.js
var Node = class {
  constructor(value) {
    __publicField(this, "value");
    __publicField(this, "next");
    this.value = value;
  }
};
var _head, _tail, _size;
var Queue = class {
  constructor() {
    __privateAdd(this, _head);
    __privateAdd(this, _tail);
    __privateAdd(this, _size);
    this.clear();
  }
  enqueue(value) {
    const node = new Node(value);
    if (__privateGet(this, _head)) {
      __privateGet(this, _tail).next = node;
      __privateSet(this, _tail, node);
    } else {
      __privateSet(this, _head, node);
      __privateSet(this, _tail, node);
    }
    __privateWrapper(this, _size)._++;
  }
  dequeue() {
    const current = __privateGet(this, _head);
    if (!current) {
      return;
    }
    __privateSet(this, _head, __privateGet(this, _head).next);
    __privateWrapper(this, _size)._--;
    return current.value;
  }
  peek() {
    if (!__privateGet(this, _head)) {
      return;
    }
    return __privateGet(this, _head).value;
  }
  clear() {
    __privateSet(this, _head, void 0);
    __privateSet(this, _tail, void 0);
    __privateSet(this, _size, 0);
  }
  get size() {
    return __privateGet(this, _size);
  }
  *[Symbol.iterator]() {
    let current = __privateGet(this, _head);
    while (current) {
      yield current.value;
      current = current.next;
    }
  }
};
_head = new WeakMap();
_tail = new WeakMap();
_size = new WeakMap();

// node_modules/p-limit/index.js
function pLimit(concurrency) {
  validateConcurrency(concurrency);
  const queue = new Queue();
  let activeCount = 0;
  const resumeNext = () => {
    if (activeCount < concurrency && queue.size > 0) {
      queue.dequeue()();
      activeCount++;
    }
  };
  const next = () => {
    activeCount--;
    resumeNext();
  };
  const run = async (function_, resolve, arguments_) => {
    const result = (async () => function_(...arguments_))();
    resolve(result);
    try {
      await result;
    } catch {
    }
    next();
  };
  const enqueue = (function_, resolve, arguments_) => {
    new Promise((internalResolve) => {
      queue.enqueue(internalResolve);
    }).then(
      run.bind(void 0, function_, resolve, arguments_)
    );
    (async () => {
      await Promise.resolve();
      if (activeCount < concurrency) {
        resumeNext();
      }
    })();
  };
  const generator = (function_, ...arguments_) => new Promise((resolve) => {
    enqueue(function_, resolve, arguments_);
  });
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.size
    },
    clearQueue: {
      value() {
        queue.clear();
      }
    },
    concurrency: {
      get: () => concurrency,
      set(newConcurrency) {
        validateConcurrency(newConcurrency);
        concurrency = newConcurrency;
        queueMicrotask(() => {
          while (activeCount < concurrency && queue.size > 0) {
            resumeNext();
          }
        });
      }
    }
  });
  return generator;
}
function validateConcurrency(concurrency) {
  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  }
}

// node_modules/@novely/core/dist/index.js
var SKIPPED_DURING_RESTORE = /* @__PURE__ */ new Set(["dialog", "say", "choice", "input", "vibrate", "text"]);
var BLOCK_EXIT_STATEMENTS = /* @__PURE__ */ new Set(["choice:exit", "condition:exit", "block:exit"]);
var BLOCK_STATEMENTS = /* @__PURE__ */ new Set(["choice", "condition", "block"]);
var AUDIO_ACTIONS = /* @__PURE__ */ new Set([
  "playMusic",
  "stopMusic",
  "playSound",
  "stopSound",
  "voice",
  "stopVoice"
]);
var EMPTY_SET = /* @__PURE__ */ new Set();
var DEFAULT_TYPEWRITER_SPEED = "Medium";
var HOWLER_SUPPORTED_FILE_FORMATS = /* @__PURE__ */ new Set([
  "mp3",
  "mpeg",
  "opus",
  "ogg",
  "oga",
  "wav",
  "aac",
  "caf",
  "m4a",
  "m4b",
  "mp4",
  "weba",
  "webm",
  "dolby",
  "flac"
]);
var SUPPORTED_IMAGE_FILE_FORMATS = /* @__PURE__ */ new Set([
  "apng",
  "avif",
  "gif",
  "jpg",
  "jpeg",
  "jfif",
  "pjpeg",
  "pjp",
  "png",
  "svg",
  "webp",
  "bmp"
]);
var MAIN_CONTEXT_KEY = "$MAIN";
var STACK_MAP = /* @__PURE__ */ new Map();
var CUSTOM_ACTION_MAP = /* @__PURE__ */ new Map();
var PRELOADED_ASSETS = /* @__PURE__ */ new Set();
var ASSETS_TO_PRELOAD = /* @__PURE__ */ new Set();
function klona(val) {
  var k, out, tmp;
  if (Array.isArray(val)) {
    out = Array(k = val.length);
    while (k--) out[k] = (tmp = val[k]) && typeof tmp === "object" ? klona(tmp) : tmp;
    return out;
  }
  if (Object.prototype.toString.call(val) === "[object Object]") {
    out = {};
    for (k in val) {
      if (k === "__proto__") {
        Object.defineProperty(out, k, {
          value: klona(val[k]),
          configurable: true,
          enumerable: true,
          writable: true
        });
      } else {
        out[k] = (tmp = val[k]) && typeof tmp === "object" ? klona(tmp) : tmp;
      }
    }
    return out;
  }
  return val;
}
var cut = (str2) => str2.replace(/^no$/, "");
var audio = new Audio();
var canPlay = (type) => !!cut(audio.canPlayType(type));
var canPlayMultiple = (...types) => types.some((type) => canPlay(type));
var supportsMap = {
  mp3: canPlayMultiple("audio/mpeg;", "audio/mp3;"),
  mpeg: canPlay("audio/mpeg;"),
  opus: canPlay('audio/ogg; codecs="opus"'),
  ogg: canPlay('audio/ogg; codecs="vorbis"'),
  oga: canPlay('audio/ogg; codecs="vorbis"'),
  wav: canPlayMultiple('audio/wav; codecs="1"', "audio/wav;"),
  aac: canPlay("audio/aac;"),
  caf: canPlay("audio/x-caf;"),
  m4a: canPlayMultiple("audio/x-m4a;", "audio/m4a;", "audio/aac;"),
  m4b: canPlayMultiple("audio/x-m4b;", "audio/m4b;", "audio/aac;"),
  mp4: canPlayMultiple("audio/x-mp4;", "audio/mp4;", "audio/aac;"),
  weba: canPlay('audio/webm; codecs="vorbis"'),
  webm: canPlay('audio/webm; codecs="vorbis"'),
  dolby: canPlay('audio/mp4; codecs="ec-3"'),
  flac: canPlayMultiple("audio/x-flac;", "audio/flac;")
};
var avif = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=";
var jxl = "data:image/jxl;base64,/woIAAAMABKIAgC4AF3lEgAAFSqjjBu8nOv58kOHxbSN6wxttW1hSaLIODZJJ3BIEkkaoCUzGM6qJAE=";
var webp = "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA";
var supportsFormat = (source) => {
  const { promise, resolve } = Promise.withResolvers();
  const img = Object.assign(document.createElement("img"), {
    src: source
  });
  img.onload = img.onerror = () => {
    resolve(img.height === 2);
  };
  return promise;
};
var supportsMap2 = {
  avif: false,
  jxl: false,
  webp: false
};
var formatsMap = {
  avif,
  jxl,
  webp
};
var loadImageFormatsSupport = async () => {
  const promises = [];
  for (const [format, source] of Object.entries(formatsMap)) {
    const promise = supportsFormat(source).then((supported) => {
      supportsMap2[format] = supported;
    });
    promises.push(promise);
  }
  await Promise.all(promises);
};
loadImageFormatsSupport();
var getType = createMemoizedFunction((extensions) => {
  if (extensions.every((extension) => HOWLER_SUPPORTED_FILE_FORMATS.has(extension))) {
    return "audio";
  }
  if (extensions.every((extension) => SUPPORTED_IMAGE_FILE_FORMATS.has(extension))) {
    return "image";
  }
  throw extensions;
});
var SUPPORT_MAPS = {
  "image": supportsMap2,
  "audio": supportsMap
};
var asset = createMemoizedFunction((...variants) => {
  if (DEV && variants.length === 0) {
    throw new Error(`Attempt to use "asset" function without arguments`);
  }
  const map = {};
  const extensions = [];
  for (const v of variants) {
    const e = getUrlFileExtension(v);
    map[e] = v;
    extensions.push(e);
  }
  const type = getType(extensions);
  const getSource = createMemoizedFunction(() => {
    const support = SUPPORT_MAPS[type];
    for (const extension of extensions) {
      if (extension in support) {
        if (support[extension]) {
          return map[extension];
        }
      } else {
        return map[extension];
      }
    }
    if (DEV) {
      throw new Error(`No matching asset was found for ${variants.map((v) => `"${v}"`).join(", ")}`);
    }
    return "";
  });
  return {
    get source() {
      return getSource();
    },
    get type() {
      return type;
    }
  };
});
var isAsset = (suspect) => {
  return suspect !== null && typeof suspect === "object" && "source" in suspect && "type" in suspect;
};
var matchAction = ({ getContext, onBeforeActionCall, push, forward }, values) => {
  return (action, props, { ctx, data }) => {
    const context = typeof ctx === "string" ? getContext(ctx) : ctx;
    if (action !== "say") {
      onBeforeActionCall({
        action,
        props,
        ctx: context
      });
    }
    return values[action]({
      ctx: context,
      data,
      push() {
        if (context.meta.preview) return;
        push(context);
      },
      forward() {
        if (context.meta.preview) return;
        forward(context);
      }
    }, props);
  };
};
var isNumber = (val) => {
  return typeof val === "number";
};
var isNull = (val) => {
  return val === null;
};
var isString = (val) => {
  return typeof val === "string";
};
var isFunction = (val) => {
  return typeof val === "function";
};
var isPromise = (val) => {
  return Boolean(val) && (typeof val === "object" || isFunction(val)) && isFunction(val.then);
};
var isEmpty = (val) => {
  return typeof val === "object" && !isNull(val) && Object.keys(val).length === 0;
};
var isCSSImage = (str2) => {
  const startsWith = String.prototype.startsWith.bind(str2);
  return startsWith("http") || startsWith("/") || startsWith(".") || startsWith("data");
};
var str = String;
var isUserRequiredAction = ([action, ...meta]) => {
  return Boolean(action === "custom" && meta[0] && meta[0].requireUserAction);
};
var getLanguage = (languages) => {
  let { language } = navigator;
  if (languages.includes(language)) {
    return language;
  } else if (languages.includes(language = language.slice(0, 2))) {
    return language;
  } else if (language = languages.find((value) => navigator.languages.includes(value))) {
    return language;
  }
  return languages[0];
};
var throttle = (fn, ms) => {
  let throttled = false, savedArgs, savedThis;
  function wrapper(...args) {
    if (throttled) {
      savedArgs = args;
      savedThis = this;
      return;
    }
    fn.apply(this, args);
    throttled = true;
    setTimeout(() => {
      throttled = false;
      if (savedArgs) {
        wrapper.apply(savedThis, savedArgs);
        savedArgs = savedThis = null;
      }
    }, ms);
  }
  return wrapper;
};
var findLastIndex = (array, fn) => {
  for (let i = array.length - 1; i >= 0; i--) {
    if (fn.call(array, array[i], i, array)) {
      return i;
    }
  }
  return -1;
};
var createControlledPromise = () => {
  const object = {
    resolve: null,
    reject: null,
    promise: null,
    cancel: null
  };
  const init = () => {
    const promise = new Promise((resolve, reject) => {
      object.reject = reject;
      object.resolve = (value) => {
        resolve({ cancelled: false, value });
      };
      object.cancel = () => {
        resolve({ cancelled: true, value: null });
        init();
      };
    });
    object.promise = promise;
  };
  return init(), object;
};
var findLastPathItemBeforeItemOfType = (path, name) => {
  const index = findLastIndex(path, ([_name, _value], i, array) => {
    const next = array[i + 1];
    return isNull(_name) && isNumber(_value) && next != null && next[0] === name;
  });
  return path[index];
};
var isBlockStatement = (statement) => {
  return BLOCK_STATEMENTS.has(statement);
};
var isBlockExitStatement = (statement) => {
  return BLOCK_EXIT_STATEMENTS.has(statement);
};
var isSkippedDuringRestore = (item) => {
  return SKIPPED_DURING_RESTORE.has(item);
};
var isAudioAction = (action) => {
  return AUDIO_ACTIONS.has(action);
};
var noop = () => {
};
var isAction = (element) => {
  return Array.isArray(element) && isString(element[0]);
};
var flattenStory = (story) => {
  const entries = Object.entries(story).map(([name, items]) => {
    const flat = (item) => {
      return item.flatMap((data) => {
        const type = data[0];
        if (Array.isArray(type)) return flat(data);
        return [data];
      });
    };
    return [name, flat(items)];
  });
  return Object.fromEntries(entries);
};
var isExitImpossible = (path) => {
  const blockStatements = path.filter(([item]) => isBlockStatement(item));
  const blockExitStatements = path.filter(([item]) => isBlockExitStatement(item));
  if (blockStatements.length === 0 && blockExitStatements.length === 0) {
    return true;
  }
  if (blockStatements.length > blockExitStatements.length) {
    return false;
  }
  return !blockExitStatements.every(([name], i) => name && name.startsWith(blockStatements[i][0]));
};
var getOppositeAction = (action) => {
  const MAP = {
    "showCharacter": "hideCharacter",
    "playSound": "stopSound",
    "playMusic": "stopMusic",
    "voice": "stopVoice"
  };
  return MAP[action];
};
var getActionsFromPath = (story, path, filter) => {
  let current = story;
  let precurrent;
  let ignoreNestedBefore = null;
  let index = 0;
  let skipPreserve = void 0;
  const skip = /* @__PURE__ */ new Set();
  const max = path.reduce((acc, [type, val]) => {
    if (isNull(type) && isNumber(val)) {
      return acc + 1;
    }
    return acc;
  }, 0);
  const queue = [];
  const blocks = [];
  for (const [type, val] of path) {
    if (type === "jump") {
      precurrent = story;
      current = current[val];
    } else if (type === null) {
      precurrent = current;
      if (isNumber(val)) {
        index++;
        let startIndex = 0;
        if (ignoreNestedBefore) {
          const prev = findLastPathItemBeforeItemOfType(path.slice(0, index), ignoreNestedBefore);
          if (prev) {
            startIndex = prev[1];
            ignoreNestedBefore = null;
          }
        }
        for (let i = startIndex; i <= val; i++) {
          const item = current[i];
          if (!isAction(item)) continue;
          const [action] = item;
          const last = index === max && i === val;
          const shouldSkip = isSkippedDuringRestore(action) || isUserRequiredAction(item);
          if (shouldSkip) {
            skip.add(item);
          }
          if (shouldSkip && last) {
            skipPreserve = item;
          }
          if (filter && shouldSkip && !last) {
            continue;
          } else {
            queue.push(item);
          }
        }
      }
      current = current[val];
    } else if (type === "choice") {
      blocks.push(precurrent);
      current = current[val + 1][1];
    } else if (type === "condition") {
      blocks.push(precurrent);
      current = current[2][val];
    } else if (type === "block") {
      blocks.push(precurrent);
      current = story[val];
    } else if (type === "block:exit" || type === "choice:exit" || type === "condition:exit") {
      current = blocks.pop();
      ignoreNestedBefore = type.slice(0, -5);
    }
  }
  return {
    queue,
    skip,
    skipPreserve
  };
};
var createQueueProcessor = (queue, options) => {
  const processedQueue = [];
  const keep = /* @__PURE__ */ new Set();
  const characters = /* @__PURE__ */ new Set();
  const audio2 = {
    music: /* @__PURE__ */ new Set(),
    sound: /* @__PURE__ */ new Set()
  };
  const next = (i) => queue.slice(i + 1);
  for (const [i, item] of queue.entries()) {
    const [action, ...params] = item;
    if (options.skip.has(item) && item !== options.skipPreserve) {
      continue;
    }
    keep.add(action);
    if (action === "function" || action === "custom") {
      if (action === "custom") {
        const fn = params[0];
        if ("callOnlyLatest" in fn && fn.callOnlyLatest) {
          const notLatest = next(i).some(([, func]) => {
            if (!isFunction(func)) return false;
            const c0 = func;
            const c1 = fn;
            const isIdenticalID = Boolean(c0.id && c1.id && c0.id === c1.id);
            const isIdenticalByReference = c0 === c1;
            return isIdenticalID || isIdenticalByReference || str(c0) === str(c1);
          });
          if (notLatest) continue;
        } else if ("skipOnRestore" in fn && fn.skipOnRestore) {
          if (fn.skipOnRestore(() => next(i))) {
            continue;
          }
        }
      }
      processedQueue.push(item);
    } else if (action === "showCharacter" || action === "playSound" || action === "playMusic" || action === "voice") {
      const closing = getOppositeAction(action);
      const skip = next(i).some(([_action, target]) => {
        if (target !== params[0] && action !== "voice") {
          return false;
        }
        const musicGonnaBePaused = action === "playMusic" && _action === "pauseMusic";
        const soundGonnaBePaused = action === "playSound" && _action === "pauseSound";
        return musicGonnaBePaused || soundGonnaBePaused || _action === closing || _action === action;
      });
      if (skip) continue;
      if (action === "showCharacter") {
        characters.add(params[0]);
      } else if (action === "playMusic") {
        audio2.music.add(unwrapAsset(params[0]));
      } else if (action === "playSound") {
        audio2.sound.add(unwrapAsset(params[0]));
      }
      processedQueue.push(item);
    } else if (action === "showBackground" || action === "preload") {
      const skip = next(i).some(([_action]) => action === _action);
      if (skip) continue;
      processedQueue.push(item);
    } else if (action === "animateCharacter") {
      const skip = next(i).some(([_action, character], j, array) => {
        if (action === _action && character === params[0]) {
          return true;
        }
        const next2 = array.slice(j);
        const characterWillAnimate = next2.some(([__action, __character]) => action === __action);
        const hasBlockingActions = next2.some((item2) => options.skip.has(item2));
        return characterWillAnimate && hasBlockingActions;
      });
      if (skip) continue;
      processedQueue.push(item);
    } else {
      processedQueue.push(item);
    }
  }
  const run = async (match) => {
    for await (const item of processedQueue) {
      const result = match(item);
      if (isPromise(result)) {
        await result;
      }
    }
    processedQueue.length = 0;
  };
  return {
    run,
    keep: {
      keep,
      characters,
      audio: audio2
    }
  };
};
var getStack = (ctx) => {
  const { id } = ctx;
  const cached = STACK_MAP.get(id);
  if (cached) return cached;
  const stack = [];
  STACK_MAP.set(id, stack);
  return stack;
};
var createUseStackFunction = (renderer) => {
  const useStack = (context) => {
    const ctx = typeof context === "string" ? renderer.getContext(context) : context;
    const stack = getStack(ctx);
    return {
      get previous() {
        return stack.previous;
      },
      get value() {
        return stack.at(-1);
      },
      set value(value) {
        stack[stack.length - 1] = value;
      },
      back() {
        if (stack.length > 1) {
          stack.previous = stack.pop();
          ctx.meta.goingBack = true;
        }
      },
      push(value) {
        stack.push(value);
      },
      clear() {
        stack.previous = void 0;
        stack.length = 0;
        stack.length = 1;
      }
    };
  };
  return useStack;
};
var mapSet = (set, fn) => {
  return [...set].map(fn);
};
var isImageAsset = (asset2) => {
  return isString(asset2) && isCSSImage(asset2);
};
var getUrlFileExtension = (address) => {
  try {
    const { pathname } = new URL(address, location.href);
    return pathname.split(".").at(-1).split("!")[0].split(":")[0];
  } catch (error) {
    if (DEV) {
      console.error(new Error(`Could not construct URL "${address}".`, { cause: error }));
    }
    return "";
  }
};
var fetchContentType = async (request, url) => {
  try {
    const response = await request(url, {
      method: "HEAD"
    });
    return response.headers.get("Content-Type") || "";
  } catch (error) {
    if (DEV) {
      console.error(new Error(`Failed to fetch file at "${url}"`, { cause: error }));
    }
    return "";
  }
};
var getResourseType = createMemoizedFunction(
  async (request, url) => {
    if (!isCSSImage(url)) {
      return "other";
    }
    const extension = getUrlFileExtension(url);
    if (HOWLER_SUPPORTED_FILE_FORMATS.has(extension)) {
      return "audio";
    }
    if (SUPPORTED_IMAGE_FILE_FORMATS.has(extension)) {
      return "image";
    }
    const contentType = await fetchContentType(request, url);
    if (contentType.includes("audio")) {
      return "audio";
    }
    if (contentType.includes("image")) {
      return "image";
    }
    return "other";
  },
  {
    isPromise: true
  }
);
var capitalize = (str2) => {
  return str2[0].toUpperCase() + str2.slice(1);
};
var getIntlLanguageDisplayName = createMemoizedFunction((lang) => {
  try {
    const intl = new Intl.DisplayNames([lang], {
      type: "language"
    });
    return intl.of(lang) || lang;
  } catch {
    return lang;
  }
});
var createReferFunction = (story) => {
  const refer = (path) => {
    let current = story;
    let precurrent = story;
    const blocks = [];
    for (const [type, val] of path) {
      if (type === "jump") {
        precurrent = story;
        current = current[val];
      } else if (type === null) {
        precurrent = current;
        current = current[val];
      } else if (type === "choice") {
        blocks.push(precurrent);
        current = current[val + 1][1];
      } else if (type === "condition") {
        blocks.push(precurrent);
        current = current[2][val];
      } else if (type === "block") {
        blocks.push(precurrent);
        current = story[val];
      } else if (type === "block:exit" || type === "choice:exit" || type === "condition:exit") {
        current = blocks.pop();
      }
    }
    return current;
  };
  return refer;
};
var exitPath = ({ path, refer, onExitImpossible }) => {
  var _a;
  const last = path.at(-1);
  const ignore = [];
  let wasExitImpossible = false;
  if (!isAction(refer(path))) {
    if (last && isNull(last[0]) && isNumber(last[1])) {
      last[1]--;
    } else {
      path.pop();
    }
  }
  if (isExitImpossible(path)) {
    const referred = refer(path);
    if (isAction(referred) && isSkippedDuringRestore(referred[0])) {
      onExitImpossible == null ? void 0 : onExitImpossible();
    }
    wasExitImpossible = true;
    return {
      exitImpossible: wasExitImpossible
    };
  }
  for (let i = path.length - 1; i > 0; i--) {
    const [name] = path[i];
    if (isBlockExitStatement(name)) {
      ignore.push(name);
    }
    if (!isBlockStatement(name)) continue;
    if ((_a = ignore.at(-1)) == null ? void 0 : _a.startsWith(name)) {
      ignore.pop();
      continue;
    }
    path.push([`${name}:exit`]);
    const prev = findLastPathItemBeforeItemOfType(path.slice(0, i + 1), name);
    if (prev) path.push([null, prev[1] + 1]);
    if (!isAction(refer(path))) {
      path.pop();
      continue;
    }
    break;
  }
  return {
    exitImpossible: wasExitImpossible
  };
};
var nextPath = (path) => {
  const last = path.at(-1);
  if (last && (isNull(last[0]) || last[0] === "jump") && isNumber(last[1])) {
    last[1]++;
  } else {
    path.push([null, 0]);
  }
  return path;
};
var isBlockingAction = (action) => {
  return isUserRequiredAction(action) || isSkippedDuringRestore(action[0]) && action[0] !== "vibrate";
};
var collectActionsBeforeBlockingAction = ({ path, refer }) => {
  const collection = [];
  let action = refer(path);
  while (true) {
    if (action == void 0) {
      const { exitImpossible } = exitPath({
        path,
        refer
      });
      if (exitImpossible) {
        break;
      }
    }
    if (!action) {
      break;
    }
    if (isBlockingAction(action)) {
      const [name, ...props] = action;
      if (name === "choice") {
        const choiceProps = props;
        for (let i = 0; i < choiceProps.length; i++) {
          const branchContent = choiceProps[i];
          if (!Array.isArray(branchContent)) continue;
          const virtualPath = klona(path);
          virtualPath.push(["choice", i], [null, 0]);
          const innerActions = collectActionsBeforeBlockingAction({
            path: virtualPath,
            refer
          });
          collection.push(...innerActions);
        }
      } else if (name === "condition") {
        const conditionProps = props;
        const conditions = Object.keys(conditionProps[1]);
        for (const condition of conditions) {
          const virtualPath = klona(path);
          virtualPath.push(["condition", condition], [null, 0]);
          const innerActions = collectActionsBeforeBlockingAction({
            path: virtualPath,
            refer
          });
          collection.push(...innerActions);
        }
      }
      break;
    }
    collection.push(action);
    if (action[0] === "jump") {
      path = [["jump", action[1]], [null, 0]];
    } else if (action[0] == "block") {
      path.push(["block", action[1]], [null, 0]);
    } else {
      nextPath(path);
    }
    action = refer(path);
  }
  return collection;
};
var unwrapAsset = (asset2) => {
  return isAsset(asset2) ? asset2.source : asset2;
};
var handleAudioAsset = (asset2) => {
  if (DEV && isAsset(asset2) && asset2.type !== "audio") {
    throw new Error("Attempt to use non-audio asset in audio action", { cause: asset2 });
  }
  return unwrapAsset(asset2);
};
var handleImageAsset = (asset2) => {
  if (DEV && isAsset(asset2) && asset2.type !== "image") {
    throw new Error("Attempt to use non-image asset in action that requires image assets", { cause: asset2 });
  }
  return unwrapAsset(asset2);
};
var getCharactersData = (characters) => {
  const entries = Object.entries(characters);
  const mapped = entries.map(([key, value]) => [key, { name: value.name, emotions: Object.keys(value.emotions) }]);
  return Object.fromEntries(mapped);
};
var toArray = (target) => {
  return Array.isArray(target) ? target : [target];
};
var store = (current, subscribers = /* @__PURE__ */ new Set()) => {
  const subscribe = (cb) => {
    subscribers.add(cb), cb(current);
    return () => {
      subscribers.delete(cb);
    };
  };
  const push = (value) => {
    for (const cb of subscribers) cb(value);
  };
  const update = (fn) => {
    push(current = fn(current));
  };
  const set = (val) => {
    update(() => val);
  };
  const get = () => {
    return current;
  };
  return { subscribe, update, set, get };
};
var { isArray } = Array;
var { hasOwnProperty, propertyIsEnumerable, getOwnPropertySymbols } = Object;
var propertyIsOnObject = (object, property) => {
  try {
    return property in object;
  } catch {
    return false;
  }
};
var propertyIsUnsafe = (target, key) => {
  return propertyIsOnObject(target, key) && // Properties are safe to merge if they don't exist in the target yet,
  !(hasOwnProperty.call(target, key) && // unsafe if they exist up the prototype chain,
  propertyIsEnumerable.call(target, key));
};
var getEnumerableOwnPropertySymbols = (target) => {
  if (!getOwnPropertySymbols) return [];
  return getOwnPropertySymbols(target).filter((symbol) => propertyIsEnumerable.call(target, symbol));
};
var keys = (target) => {
  return [...Object.keys(target), ...getEnumerableOwnPropertySymbols(target)];
};
var isMergeableObject = (value) => {
  return !!value && typeof value === "object" && !["RegExp", "Date"].includes(Object.prototype.toString.call(value).slice(8, -1));
};
var empty = (value) => {
  return isArray(value) ? [] : {};
};
var clone = (value) => {
  return isMergeableObject(value) ? deepmerge(empty(value), value) : value;
};
var mergeArray = (target, source) => {
  const destination = target.slice();
  source.forEach((item, index) => {
    if (typeof destination[index] === "undefined") {
      destination[index] = clone(item);
    } else if (isMergeableObject(item)) {
      destination[index] = deepmerge(target[index], item);
    } else if (target.indexOf(item) === -1) {
      destination.push(item);
    }
  });
  return destination;
};
var mergeObject = (target, source) => {
  const destination = {};
  for (const key of keys(target)) {
    destination[key] = clone(target[key]);
  }
  for (const key of keys(source)) {
    if (propertyIsUnsafe(target, key)) {
      continue;
    }
    if (propertyIsOnObject(target, key) && isMergeableObject(source[key])) {
      destination[key] = deepmerge(target[key], source[key]);
    } else {
      destination[key] = clone(source[key]);
    }
  }
  return destination;
};
var deepmerge = (target, source) => {
  if (isArray(target) && isArray(source)) {
    const merged = mergeArray(target, source);
    return merged;
  } else if (!isArray(target) && !isArray(source)) {
    const merged = mergeObject(target, source);
    return merged;
  } else {
    return clone(source);
  }
};
var RGX = /{{(.*?)}}/g;
var split = (input, delimeters) => {
  const output = [];
  for (const delimeter of delimeters) {
    if (!input) break;
    const [start, end] = input.split(delimeter, 2);
    output.push(start);
    input = end;
  }
  output.push(input);
  return output;
};
var flattenAllowedContent = (c, state) => {
  if (Array.isArray(c)) {
    return c.map((item) => flattenAllowedContent(item, state)).join("<br>");
  }
  if (typeof c === "function") {
    return flattenAllowedContent(c(state), state);
  }
  return c;
};
var replace = (input, data, pluralization, actions, pr) => {
  return input.replaceAll(RGX, (x, key, y) => {
    x = 0;
    y = data;
    const [pathstr, plural, action] = split(key.trim(), ["@", "%"]);
    if (!pathstr) {
      return "";
    }
    const path = pathstr.split(".");
    while (y && x < path.length) y = y[path[x++]];
    if (plural && pluralization && y && pr) {
      y = pluralization[plural][pr.select(y)];
    }
    const actionHandler = actions && action ? actions[action] : void 0;
    if (actionHandler) y = actionHandler(y);
    return y == null ? "" : y;
  });
};
var createCustomActionNode = (id) => {
  const div = document.createElement("div");
  div.setAttribute("data-id", id);
  return div;
};
var getCustomActionHolder = (ctx, fn) => {
  const cached = CUSTOM_ACTION_MAP.get(ctx.id + fn.key);
  if (cached) {
    return cached;
  }
  const holder = {
    cleanup: noop,
    node: null,
    fn,
    localData: {}
  };
  CUSTOM_ACTION_MAP.set(ctx.id + fn.key, holder);
  return holder;
};
var handleCustomAction = (ctx, fn, { lang, state, setMountElement, setClear, remove: renderersRemove }) => {
  const holder = getCustomActionHolder(ctx, fn);
  const flags = {
    ...ctx.meta
  };
  const getDomNodes = (insert = true) => {
    if (holder.node || !insert) {
      return {
        element: holder.node,
        root: ctx.root
      };
    }
    holder.node = insert ? createCustomActionNode(fn.key) : null;
    setMountElement(holder.node);
    return {
      element: holder.node,
      root: ctx.root
    };
  };
  const clear = (func) => {
    setClear(holder.cleanup = () => {
      func();
      holder.node = null;
      holder.cleanup = noop;
      setMountElement(null);
      setClear(noop);
    });
  };
  const data = (updatedData) => {
    if (updatedData) {
      return holder.localData = updatedData;
    }
    return holder.localData;
  };
  const remove = () => {
    holder.cleanup();
    renderersRemove();
  };
  return fn({
    flags,
    lang,
    state,
    data,
    clear,
    remove,
    rendererContext: ctx,
    getDomNodes
  });
};
var localStorageStorage = (options) => {
  return {
    async get() {
      const fallback = { saves: [], data: {}, meta: [] };
      try {
        const value = localStorage.getItem(options.key);
        return value ? JSON.parse(value) : fallback;
      } catch {
        return fallback;
      }
    },
    async set(data) {
      try {
        localStorage.setItem(options.key, JSON.stringify(data));
      } catch {
      }
    }
  };
};
var setupBrowserVisibilityChangeListeners = ({ onChange }) => {
  if (typeof document === "undefined") return noop;
  const onVisibilityChange = () => {
    if (document.visibilityState === "hidden") {
      onChange();
    }
  };
  addEventListener("visibilitychange", onVisibilityChange);
  addEventListener("beforeunload", onChange);
  return () => {
    removeEventListener("visibilitychange", onVisibilityChange);
    removeEventListener("beforeunload", onChange);
  };
};
var enqueueAssetForPreloading = (asset2) => {
  if (!PRELOADED_ASSETS.has(asset2)) {
    ASSETS_TO_PRELOAD.add(asset2);
  }
};
var handleAssetsPreloading = async ({ request, limiter, preloadAudioBlocking, preloadImageBlocking }) => {
  const list = mapSet(ASSETS_TO_PRELOAD, (asset2) => {
    return limiter(async () => {
      const type = await getResourseType(request, asset2);
      switch (type) {
        case "audio": {
          await preloadAudioBlocking(asset2);
          break;
        }
        case "image": {
          await preloadImageBlocking(asset2);
          break;
        }
      }
      ASSETS_TO_PRELOAD.delete(asset2);
      PRELOADED_ASSETS.add(asset2);
    });
  });
  await Promise.allSettled(list);
  ASSETS_TO_PRELOAD.clear();
};
var huntAssets = ({ characters, action, props, handle }) => {
  if (action === "showBackground") {
    if (isString(props[0])) {
      handle(handleAudioAsset(props[0]));
    }
    if (props[0] && typeof props[0] === "object") {
      for (const value of Object.values(props[0])) {
        if (isImageAsset(value)) {
          handle(value);
        }
      }
    }
    return;
  }
  if (isAudioAction(action) && isString(props[0])) {
    handle(handleAudioAsset(props[0]));
    return;
  }
  if (action === "showCharacter" && isString(props[0]) && isString(props[1])) {
    const images = toArray(characters[props[0]].emotions[props[1]]);
    for (const asset2 of images) {
      handle(handleImageAsset(asset2));
    }
    return;
  }
  if (action === "custom" && props[0].assets && props[0].assets.length > 0) {
    for (const asset2 of props[0].assets) {
      handle(asset2);
    }
    return;
  }
};
var novely = ({
  characters,
  characterAssetSizes = {},
  defaultEmotions = {},
  storage = localStorageStorage({ key: "novely-game-storage" }),
  storageDelay = Promise.resolve(),
  renderer: createRenderer,
  initialScreen = "mainmenu",
  translation,
  state: defaultState = {},
  data: defaultData = {},
  autosaves = true,
  migrations = [],
  throttleTimeout = 799,
  getLanguage: getLanguage2 = getLanguage,
  overrideLanguage = false,
  askBeforeExit = true,
  preloadAssets = "lazy",
  parallelAssetsDownloadLimit = 15,
  fetch: request = fetch,
  saveOnUnload = true,
  startKey = "start"
}) => {
  const languages = Object.keys(translation);
  const limitScript = pLimit(1);
  const limitAssetsDownload = pLimit(parallelAssetsDownloadLimit);
  const story = {};
  const times = /* @__PURE__ */ new Set();
  const dataLoaded = createControlledPromise();
  let initialScreenWasShown = false;
  let destroyed = false;
  const intime = (value) => {
    return times.add(value), value;
  };
  const scriptBase = async (part) => {
    if (destroyed) return;
    Object.assign(story, flattenStory(part));
    let loadingIsShown = false;
    if (!initialScreenWasShown) {
      renderer.ui.showLoading();
      loadingIsShown = true;
    }
    if (preloadAssets === "blocking" && ASSETS_TO_PRELOAD.size > 0) {
      if (!loadingIsShown) {
        renderer.ui.showLoading();
      }
      await handleAssetsPreloading({
        ...renderer.misc,
        limiter: limitAssetsDownload,
        request
      });
    }
    await dataLoaded.promise;
    renderer.ui.hideLoading();
    if (!initialScreenWasShown) {
      initialScreenWasShown = true;
      if (initialScreen === "game") {
        restore(void 0);
      } else {
        renderer.ui.showScreen(initialScreen);
      }
    }
  };
  const script = (part) => {
    return limitScript(() => scriptBase(part));
  };
  const action = new Proxy({}, {
    get(_, action2) {
      if (action2 in renderer.actions) {
        return renderer.actions[action2];
      }
      return (...props) => {
        if (preloadAssets === "blocking") {
          huntAssets({ characters, action: action2, props, handle: enqueueAssetForPreloading });
        }
        return [action2, ...props];
      };
    }
  });
  const getDefaultSave = (state = {}) => {
    return [
      [
        ["jump", startKey],
        [null, 0]
      ],
      state,
      [intime(Date.now()), "auto"]
    ];
  };
  const getLanguageWithoutParameters = () => {
    const language = getLanguage2(languages, getLanguage);
    if (languages.includes(language)) {
      return language;
    }
    if (DEV) {
      throw new Error(`Attempt to use unsupported language "${language}". Supported languages: ${languages.join(", ")}.`);
    }
    throw 0;
  };
  const initialData = {
    saves: [],
    data: klona(defaultData),
    meta: [getLanguageWithoutParameters(), DEFAULT_TYPEWRITER_SPEED, 1, 1, 1]
  };
  const storageData = store(initialData);
  const coreData = store({
    dataLoaded: false
  });
  const onDataLoadedPromise = ({ cancelled }) => {
    if (cancelled) {
      dataLoaded.promise.then(onDataLoadedPromise);
      return;
    }
    coreData.update((data2) => {
      data2.dataLoaded = true;
      return data2;
    });
  };
  dataLoaded.promise.then(onDataLoadedPromise);
  const onStorageDataChange = (value) => {
    if (coreData.get().dataLoaded) storage.set(value);
  };
  const throttledOnStorageDataChange = throttle(onStorageDataChange, throttleTimeout);
  const throttledEmergencyOnStorageDataChange = throttle(() => {
    if (saveOnUnload === true || saveOnUnload === "prod" && !DEV) {
      onStorageDataChange(storageData.get());
    }
  }, 10);
  storageData.subscribe(throttledOnStorageDataChange);
  const getStoredData = async () => {
    var _a, _b, _c, _d;
    let stored = await storage.get();
    for (const migration of migrations) {
      stored = migration(stored);
      if (DEV && !stored) {
        throw new Error("Migrations should return a value.");
      }
    }
    if (overrideLanguage || !stored.meta[0]) {
      stored.meta[0] = getLanguageWithoutParameters();
    }
    (_a = stored.meta)[1] || (_a[1] = DEFAULT_TYPEWRITER_SPEED);
    (_b = stored.meta)[2] ?? (_b[2] = 1);
    (_c = stored.meta)[3] ?? (_c[3] = 1);
    (_d = stored.meta)[4] ?? (_d[4] = 1);
    if (isEmpty(stored.data)) {
      stored.data = defaultData;
    }
    dataLoaded.resolve();
    storageData.set(stored);
  };
  storageDelay.then(getStoredData);
  const initial = getDefaultSave(klona(defaultState));
  const unsubscribeFromBrowserVisibilityChange = setupBrowserVisibilityChangeListeners({
    onChange: throttledEmergencyOnStorageDataChange
  });
  const save = (type) => {
    if (!coreData.get().dataLoaded) return;
    if (!autosaves && type === "auto") return;
    const stack = useStack(MAIN_CONTEXT_KEY);
    const current = klona(stack.value);
    storageData.update((prev) => {
      const replace2 = () => {
        prev.saves[prev.saves.length - 1] = current;
        return prev;
      };
      const add = () => {
        prev.saves.push(current);
        return prev;
      };
      const last = prev.saves.at(-1);
      if (!last) return add();
      current[2][0] = intime(Date.now());
      current[2][1] = type;
      const isIdentical = dequal(last[0], current[0]) && dequal(last[1], current[1]);
      const isLastMadeInCurrentSession = times.has(last[2][0]);
      if (isLastMadeInCurrentSession && last[2][1] === "auto" && type === "manual") {
        return replace2();
      }
      if (last[2][1] === "manual" && type === "auto" && isIdentical) {
        return prev;
      }
      if (isLastMadeInCurrentSession && last[2][1] === "auto" && type === "auto") {
        return replace2();
      }
      return add();
    });
  };
  const newGame = () => {
    if (!coreData.get().dataLoaded) return;
    const save2 = getDefaultSave(klona(defaultState));
    if (autosaves) {
      storageData.update((prev) => {
        return prev.saves.push(save2), prev;
      });
    }
    const context = renderer.getContext(MAIN_CONTEXT_KEY);
    const stack = useStack(context);
    stack.value = save2;
    context.meta.restoring = context.meta.goingBack = false;
    renderer.ui.showScreen("game");
    render(context);
  };
  const set = (save2, ctx) => {
    const stack = useStack(ctx || MAIN_CONTEXT_KEY);
    stack.value = save2;
    return restore(save2);
  };
  let interacted = 0;
  const restore = async (save2) => {
    if (isEmpty(story)) {
      if (DEV) {
        throw new Error("Story is empty. You should call an `enine.script` function [https://novely.pages.dev/guide/story.html]");
      }
      return;
    }
    if (!coreData.get().dataLoaded) return;
    let latest = save2 || storageData.get().saves.at(-1);
    if (!latest) {
      latest = klona(initial);
      storageData.update((prev) => {
        prev.saves.push(latest);
        return prev;
      });
    }
    const context = renderer.getContext(MAIN_CONTEXT_KEY);
    const stack = useStack(context);
    context.meta.restoring = true;
    const previous = stack.previous;
    const [path] = stack.value = latest;
    renderer.ui.showScreen("game");
    const { queue, skip, skipPreserve } = getActionsFromPath(story, path, false);
    const { run, keep: { keep, characters: characters2, audio: audio2 } } = createQueueProcessor(queue, {
      skip,
      skipPreserve
    });
    if (previous) {
      const { queue: prevQueue } = getActionsFromPath(story, previous[0], false);
      for (let i = prevQueue.length - 1; i > queue.length - 1; i--) {
        const element = prevQueue[i];
        if (!isAction(element)) {
          continue;
        }
        const [action2, fn] = element;
        if (action2 === "custom") {
          getCustomActionHolder(context, fn).cleanup();
        }
      }
    }
    if (context.meta.goingBack) {
      match("clear", [keep, characters2, audio2], {
        ctx: context,
        data: latest[1]
      });
    }
    const lastQueueItem = queue.at(-1);
    const lastQueueItemRequiresUserAction = lastQueueItem && isBlockingAction(lastQueueItem);
    await run((item) => {
      if (!latest) return;
      if (lastQueueItem === item && lastQueueItemRequiresUserAction) {
        return;
      }
      const [action2, ...props] = item;
      return match(action2, props, {
        ctx: context,
        data: latest[1]
      });
    });
    if (!context.meta.goingBack) {
      context.meta.restoring = false;
    }
    render(context);
    context.meta.restoring = context.meta.goingBack = false;
  };
  const refer = createReferFunction(story);
  const exit = (force = false, saving = true) => {
    const ctx = renderer.getContext(MAIN_CONTEXT_KEY);
    const stack = useStack(ctx);
    const current = stack.value;
    const isSaved = () => {
      const { saves } = storageData.get();
      const [currentPath, currentData] = stack.value;
      return saves.some(([path, data2, [date, type2]]) => type2 === "manual" && times.has(date) && dequal(path, currentPath) && dequal(data2, currentData));
    };
    if (interacted > 1 && !force && askBeforeExit && !isSaved()) {
      renderer.ui.showExitPrompt();
      return;
    }
    if (interacted > 0 && saving) {
      save("auto");
    }
    stack.clear();
    ctx.clear(EMPTY_SET, EMPTY_SET, { music: EMPTY_SET, sounds: EMPTY_SET }, noop);
    renderer.ui.showScreen("mainmenu");
    ctx.audio.destroy();
    const [time, type] = current[2];
    if (type === "auto" && interacted <= 1 && times.has(time)) {
      storageData.update((prev) => {
        prev.saves = prev.saves.filter((save2) => save2 !== current);
        return prev;
      });
    }
    interactivity(false);
    times.clear();
  };
  const back = async () => {
    const stack = useStack(MAIN_CONTEXT_KEY);
    const valueBeforeBack = stack.value;
    stack.back();
    if (dequal(valueBeforeBack, stack.value) && !stack.previous) {
      return;
    }
    await restore(stack.value);
  };
  const t = (key, lang) => {
    return translation[lang].internal[key];
  };
  const preview = async (save2, name) => {
    if (isEmpty(story)) {
      return Promise.resolve({
        assets: []
      });
    }
    const [path, data2] = save2;
    const { queue } = getActionsFromPath(story, path, true);
    const ctx = renderer.getContext(name);
    ctx.meta.restoring = true;
    ctx.meta.preview = true;
    const processor = createQueueProcessor(queue, {
      skip: EMPTY_SET
    });
    useStack(ctx).push(klona(save2));
    const assets = [];
    await processor.run(([action2, ...props]) => {
      if (isAudioAction(action2)) return;
      if (action2 === "vibrate") return;
      if (action2 === "end") return;
      huntAssets({ characters, action: action2, props, handle: assets.push.bind(assets) });
      return match(action2, props, {
        ctx,
        data: data2
      });
    });
    return {
      assets
    };
  };
  const removeContext = (name) => {
    STACK_MAP.delete(name);
  };
  const getStateAtCtx = (context) => {
    return useStack(context).value[1];
  };
  const getStateFunction = (context) => {
    const stack = useStack(context);
    const state = (value) => {
      const _state = getStateAtCtx(context);
      if (!value) {
        return _state;
      }
      const prev = _state;
      const val = isFunction(value) ? value(prev) : deepmerge(prev, value);
      stack.value[1] = val;
      return void 0;
    };
    return state;
  };
  const getLanguageDisplayName = (lang) => {
    const language = translation[lang];
    if (DEV && !language) {
      throw new Error(`Attempt to use unsupported language "${language}". Supported languages: ${languages.join(", ")}.`);
    }
    return capitalize(language.nameOverride || getIntlLanguageDisplayName(lang));
  };
  const clearCustomAction = (ctx, fn) => {
    getCustomActionHolder(ctx, fn).cleanup();
  };
  const getResourseTypeForRenderer = (url) => {
    return getResourseType(request, url);
  };
  const getCharacterColor = (c) => {
    return c in characters ? characters[c].color : "#000000";
  };
  const getCharacterAssets = (character, emotion) => {
    return toArray(characters[character].emotions[emotion]).map(handleImageAsset);
  };
  const renderer = createRenderer({
    mainContextKey: MAIN_CONTEXT_KEY,
    characters: getCharactersData(characters),
    characterAssetSizes,
    set,
    restore,
    save,
    newGame,
    exit,
    back,
    t,
    preview,
    removeContext,
    getStateFunction,
    clearCustomAction,
    languages,
    storageData,
    coreData,
    getLanguageDisplayName,
    getCharacterColor,
    getCharacterAssets,
    getResourseType: getResourseTypeForRenderer
  });
  const useStack = createUseStackFunction(renderer);
  useStack(MAIN_CONTEXT_KEY).push(initial);
  const UIInstance = renderer.ui.start();
  const enmemory = (ctx) => {
    if (ctx.meta.restoring) return;
    const stack = useStack(ctx);
    const current = klona(stack.value);
    current[2][1] = "auto";
    stack.push(current);
    save("auto");
  };
  const next = (ctx) => {
    const stack = useStack(ctx);
    const path = stack.value[0];
    nextPath(path);
  };
  const matchActionOptions = {
    getContext: renderer.getContext,
    push(ctx) {
      if (ctx.meta.restoring) return;
      next(ctx);
      render(ctx);
    },
    forward(ctx) {
      if (!ctx.meta.preview) enmemory(ctx);
      matchActionOptions.push(ctx);
      if (!ctx.meta.preview) interactivity(true);
    },
    onBeforeActionCall({ action: action2, props, ctx }) {
      if (preloadAssets !== "automatic") return;
      if (ctx.meta.preview || ctx.meta.restoring) return;
      if (!isBlockingAction([action2, ...props])) return;
      try {
        const collection = collectActionsBeforeBlockingAction({
          path: nextPath(klona(useStack(ctx).value[0])),
          refer
        });
        for (const [action3, ...props2] of collection) {
          huntAssets({ characters, action: action3, props: props2, handle: enqueueAssetForPreloading });
        }
        handleAssetsPreloading({
          ...renderer.misc,
          request,
          limiter: limitAssetsDownload
        });
      } catch (cause) {
        console.error(cause);
      }
    }
  };
  const match = matchAction(matchActionOptions, {
    wait({ ctx, push }, [time]) {
      if (ctx.meta.restoring) return;
      setTimeout(push, isFunction(time) ? time(getStateAtCtx(ctx)) : time);
    },
    showBackground({ ctx, push }, [background]) {
      if (isString(background) || isAsset(background)) {
        ctx.background({
          "all": handleImageAsset(background)
        });
      } else {
        ctx.background(Object.fromEntries(Object.entries(background).map(([media, asset2]) => [media, handleImageAsset(asset2)])));
      }
      push();
    },
    playMusic({ ctx, push }, [source]) {
      ctx.audio.music(handleAudioAsset(source), "music").play(true);
      push();
    },
    pauseMusic({ ctx, push }, [source]) {
      ctx.audio.music(handleAudioAsset(source), "music").pause();
      push();
    },
    stopMusic({ ctx, push }, [source]) {
      ctx.audio.music(handleAudioAsset(source), "music").stop();
      push();
    },
    playSound({ ctx, push }, [source, loop]) {
      ctx.audio.music(handleAudioAsset(source), "sound").play(loop || false);
      push();
    },
    pauseSound({ ctx, push }, [source]) {
      ctx.audio.music(handleAudioAsset(source), "sound").pause();
      push();
    },
    stopSound({ ctx, push }, [source]) {
      ctx.audio.music(handleAudioAsset(source), "sound").stop();
      push();
    },
    voice({ ctx, push }, [source]) {
      const [lang] = storageData.get().meta;
      const audioSource = isString(source) ? source : isAsset(source) ? source : source[lang];
      if (!audioSource) {
        push();
        return;
      }
      ctx.audio.voice(handleAudioAsset(audioSource));
      push();
    },
    stopVoice({ ctx, push }) {
      ctx.audio.voiceStop();
      push();
    },
    showCharacter({ ctx, push }, [character, emotion, className, style]) {
      emotion ?? (emotion = defaultEmotions[character]);
      if (DEV && !emotion) {
        throw new Error(`Attemp to show character "${character}" without emotion provided.`);
      }
      if (!emotion) return;
      if (DEV && !characters[character].emotions[emotion]) {
        throw new Error(`Attempt to show character "${character}" with unknown emotion "${emotion}"`);
      }
      const handle = ctx.character(character);
      handle.append(className, style, ctx.meta.restoring);
      handle.emotion(emotion, true);
      push();
    },
    hideCharacter({ ctx, push }, [character, className, style, duration]) {
      ctx.character(character).remove(className, style, duration, ctx.meta.restoring).then(push);
    },
    dialog({ ctx, data: data2, forward }, [character, content, emotion]) {
      const name = (() => {
        const c = character;
        const cs = characters;
        const [lang] = storageData.get().meta;
        if (c && c in cs) {
          const block = cs[c].name;
          if (typeof block === "string") {
            return block;
          }
          if (lang in block) {
            return block[lang];
          }
        }
        return c || "";
      })();
      ctx.clearBlockingActions("dialog");
      ctx.dialog(
        templateReplace(content, data2),
        templateReplace(name, data2),
        character,
        emotion,
        forward
      );
    },
    say({ ctx, data: data2 }, [character, content]) {
      if (DEV && !characters[character]) {
        throw new Error(`Attempt to call Say action with unknown character "${character}"`);
      }
      match("dialog", [character, content], {
        ctx,
        data: data2
      });
    },
    function({ ctx, push }, [fn]) {
      const { restoring, goingBack, preview: preview2 } = ctx.meta;
      const result = fn({
        lang: storageData.get().meta[0],
        goingBack,
        restoring,
        preview: preview2,
        state: getStateFunction(ctx)
      });
      if (!ctx.meta.restoring) {
        result ? result.then(push) : push();
      }
      return result;
    },
    choice({ ctx, data: data2 }, [question, ...choices]) {
      const isWithoutQuestion = Array.isArray(question);
      if (isWithoutQuestion) {
        choices.unshift(question);
        question = "";
      }
      const transformedChoices = choices.map(([content, action2, visible]) => {
        const shown = !visible || visible({
          lang: storageData.get().meta[0],
          state: getStateAtCtx(ctx)
        });
        if (DEV && action2.length === 0 && !shown) {
          console.warn(`Choice children should not be empty, either add content there or make item not selectable`);
        }
        return [templateReplace(content, data2), shown];
      });
      if (DEV && transformedChoices.length === 0) {
        throw new Error(`Running choice without variants to choose from, look at how to use Choice action properly [https://novely.pages.dev/guide/actions/choice#usage]`);
      }
      ctx.clearBlockingActions("choice");
      ctx.choices(templateReplace(question, data2), transformedChoices, (selected) => {
        if (!ctx.meta.preview) {
          enmemory(ctx);
        }
        const stack = useStack(ctx);
        const offset = isWithoutQuestion ? 0 : 1;
        if (DEV && !transformedChoices[selected]) {
          throw new Error("Choice children is empty, either add content there or make item not selectable");
        }
        stack.value[0].push(["choice", selected + offset], [null, 0]);
        render(ctx);
        interactivity(true);
      });
    },
    jump({ ctx, data: data2 }, [scene]) {
      if (DEV && !story[scene]) {
        throw new Error(`Attempt to jump to unknown scene "${scene}"`);
      }
      if (DEV && story[scene].length === 0) {
        throw new Error(`Attempt to jump to empty scene "${scene}"`);
      }
      const stack = useStack(ctx);
      stack.value[0] = [
        ["jump", scene],
        [null, -1]
      ];
      match("clear", [], {
        ctx,
        data: data2
      });
    },
    clear({ ctx, push }, [keep, characters2, audio2]) {
      ctx.vibrate(0);
      ctx.clear(
        keep || EMPTY_SET,
        characters2 || EMPTY_SET,
        audio2 || { music: EMPTY_SET, sounds: EMPTY_SET },
        push
      );
    },
    condition({ ctx }, [condition, variants]) {
      if (DEV && Object.values(variants).length === 0) {
        throw new Error(`Attempt to use Condition action with empty variants object`);
      }
      if (!ctx.meta.restoring) {
        const val = String(condition(getStateAtCtx(ctx)));
        if (DEV && !variants[val]) {
          throw new Error(`Attempt to go to unknown variant "${val}"`);
        }
        if (DEV && variants[val].length === 0) {
          throw new Error(`Attempt to go to empty variant "${val}"`);
        }
        const stack = useStack(MAIN_CONTEXT_KEY);
        stack.value[0].push(["condition", val], [null, 0]);
        render(ctx);
      }
    },
    end({ ctx }) {
      if (ctx.meta.preview) return;
      exit(true, false);
    },
    input({ ctx, data: data2, forward }, [question, onInput, setup]) {
      ctx.clearBlockingActions("input");
      ctx.input(
        templateReplace(question, data2),
        onInput,
        setup || noop,
        forward
      );
    },
    custom({ ctx, push }, [fn]) {
      if (fn.requireUserAction) {
        ctx.clearBlockingActions(void 0);
      }
      const state = getStateFunction(ctx);
      const lang = storageData.get().meta[0];
      const result = handleCustomAction(ctx, fn, {
        ...ctx.custom(fn),
        state,
        lang
      });
      const next2 = () => {
        if (fn.requireUserAction && !ctx.meta.preview) {
          enmemory(ctx);
          interactivity(true);
        }
        push();
      };
      if (!ctx.meta.restoring) {
        if (isPromise(result)) {
          result.then(next2);
        } else {
          next2();
        }
      }
      return result;
    },
    vibrate({ ctx, push }, pattern) {
      ctx.vibrate(pattern);
      push();
    },
    next({ push }) {
      push();
    },
    animateCharacter({ ctx, push }, [character, className]) {
      const classes = className.split(" ");
      if (DEV && classes.length === 0) {
        throw new Error("Attempt to use AnimateCharacter without classes. Classes should be provided [https://novely.pages.dev/guide/actions/animateCharacter.html]");
      }
      if (ctx.meta.preview) return;
      ctx.character(character).animate(classes);
      push();
    },
    text({ ctx, data: data2, forward }, text) {
      const string = text.map((content) => templateReplace(content, data2)).join(" ");
      if (DEV && string.length === 0) {
        throw new Error(`Action Text was called with empty string or array`);
      }
      ctx.clearBlockingActions("text");
      ctx.text(string, forward);
    },
    exit({ ctx, data: data2 }) {
      if (ctx.meta.restoring) return;
      const { exitImpossible } = exitPath({
        path: useStack(ctx).value[0],
        refer,
        onExitImpossible: () => {
          match("end", [], {
            ctx,
            data: data2
          });
        }
      });
      if (exitImpossible) {
        ctx.clearBlockingActions(void 0);
        return;
      }
      render(ctx);
    },
    preload({ ctx, push }, [source]) {
      if (DEV && preloadAssets !== "lazy") {
        console.error(`You do not need a preload action becase "preloadAssets" strategy was set to "${preloadAssets}"`);
      }
      if (!ctx.meta.goingBack && !ctx.meta.restoring && !PRELOADED_ASSETS.has(source)) {
        PRELOADED_ASSETS.add(renderer.misc.preloadImage(source));
      }
      push();
    },
    block({ ctx }, [scene]) {
      if (DEV && !story[scene]) {
        throw new Error(`Attempt to call Block action with unknown scene "${scene}"`);
      }
      if (DEV && story[scene].length === 0) {
        throw new Error(`Attempt to call Block action with empty scene "${scene}"`);
      }
      if (!ctx.meta.restoring) {
        const stack = useStack(ctx);
        stack.value[0].push(["block", scene], [null, 0]);
        render(ctx);
      }
    }
  });
  const render = (ctx) => {
    const stack = useStack(ctx);
    const referred = refer(stack.value[0]);
    if (isAction(referred)) {
      const [action2, ...props] = referred;
      match(action2, props, {
        ctx,
        data: stack.value[1]
      });
    } else if (Object.values(story).some((branch) => branch === referred)) {
      match("end", [], {
        ctx,
        data: stack.value[1]
      });
    } else {
      match("exit", [], {
        ctx,
        data: stack.value[1]
      });
    }
  };
  const interactivity = (value = false) => {
    interacted = value ? interacted + 1 : 0;
  };
  const templateReplace = (content, values) => {
    const { data: data2, meta: [lang] } = storageData.get();
    const obj = values || data2;
    const str2 = flattenAllowedContent(
      !isFunction(content) && !isString(content) ? content[lang] : content,
      obj
    );
    const t2 = translation[lang];
    const pluralRules = (t2.plural || t2.actions) && new Intl.PluralRules(t2.tag || lang);
    return replace(
      str2,
      obj,
      t2.plural,
      t2.actions,
      pluralRules
    );
  };
  const data = (value) => {
    const _data = storageData.get().data;
    if (!value) return _data;
    const val = isFunction(value) ? value(_data) : deepmerge(_data, value);
    storageData.update((prev) => {
      prev.data = val;
      return prev;
    });
    return void 0;
  };
  const typeEssentials = {
    l: null,
    s: null,
    d: null,
    c: null
  };
  const getCurrentStorageData = () => {
    return coreData.get().dataLoaded ? klona(storageData.get()) : null;
  };
  const setStorageData = (data2) => {
    if (destroyed) {
      if (DEV) {
        throw new Error(`function \`setStorageData\` was called after novely instance was destroyed. Data is not updater nor synced after destroy.`);
      }
      return;
    }
    storageData.set(data2);
  };
  return {
    /**
     * Function to set game script
     *
     * @example
     * ```ts
     * engine.script({
     *   start: [
     *     action.function(() => {})
     *   ]
     * })
     * ```
     */
    script,
    /**
     * Get actions
     *
     * @example
     * ```ts
     * engine.script({
     *   start: [
     *     action.function(() => {})
     *   ]
     * })
     * ```
     */
    action,
    /**
     * @deprecated Will be removed BUT replaced with state passed into actions as a parameter
     */
    state: getStateFunction(MAIN_CONTEXT_KEY),
    /**
     * Store data between games
     *
     * @example
     * ```ts
     * engine.script({
     *   start: [
     *     action.function(() => {
     *       // Paid content should be purchased only once
     *       // So it will be available in any save
     *       data({ paid_content_purchased: true })
     *     })
     *   ]
     * })
     * ```
     */
    data,
    /**
     * Used in combination with type utilities
     *
     * @example
     * ```ts
     * import type { ConditionParams, StateFunction } from '@novely/core';
       *
     * const conditionCheck = (state: StateFunction<ConditionParams<typeof engine.typeEssintials>>) => {
     *   return state.age >= 18;
     * }
     * ```
     */
    typeEssentials,
    /**
     * Replaces content inside {{braces}} with using global data
     * @example
     * ```ts
     * data({ name: 'Alexei' })
     *
     * templateReplace('{{name}} is our hero')
     * templateReplace({
     *  en: (data) => 'Hello, ' + data.name
     * })
     * ```
     */
    templateReplace(content) {
      return templateReplace(content);
    },
    /**
     * Cancel data loading, hide UI, ignore page change events
     * Data updates still will work in case Novely already was loaded
     */
    destroy() {
      dataLoaded.cancel();
      UIInstance.unmount();
      unsubscribeFromBrowserVisibilityChange();
      destroyed = true;
    },
    /**
     * Funtion to get current storage data
     *
     * @example
     * ```ts
     * const currentStorageData = engine.getCurrentStorageData();
     * ```
     */
    getCurrentStorageData,
    /**
     * Function to set storage data. Using this function is not recommended.
     *
     * @deprecated
     * @example
     * ```ts
     * const currentStorageData = engine.getCurrentStorageData();
     *
     * if (currentStorageData) {
     *   // update music volume
     *   currentStorageData.meta[2] = 1;
     *
     *   setStorageData(currentStorageData)
     * }
     * ```
     */
    setStorageData
  };
};
var extendAction = (base, extension) => {
  return new Proxy({}, {
    get(_, key, receiver) {
      return Reflect.get(key in extension ? extension : base, key, receiver);
    }
  });
};
var RU = {
  NewGame: " ",
  HomeScreen: " ",
  ToTheGame: " ",
  Language: "",
  NoSaves: " ",
  LoadSave: "",
  Saves: "",
  Settings: "",
  Sumbit: "",
  GoBack: "",
  DoSave: "",
  Auto: "",
  Stop: "",
  Exit: "",
  Automatic: "",
  Manual: "",
  Remove: "",
  LoadASaveFrom: "  ",
  DeleteASaveFrom: "  ",
  TextSpeed: " ",
  TextSpeedSlow: "",
  TextSpeedMedium: "",
  TextSpeedFast: "",
  TextSpeedAuto: "",
  CompleteText: " ",
  GoForward: " ",
  ExitDialogWarning: " ,   ?   .",
  ExitDialogExit: "",
  ExitDialogBack: "  ",
  OpenMenu: " ",
  CloseMenu: " ",
  MusicVolume: " ",
  SoundVolume: " ",
  VoiceVolume: " "
};
var EN = {
  NewGame: "New Game",
  HomeScreen: "Home Screen",
  ToTheGame: "To the Game",
  Language: "Language",
  NoSaves: "No saves",
  LoadSave: "Load",
  Saves: "Saves",
  Settings: "Settings",
  Sumbit: "Submit",
  GoBack: "Go back",
  DoSave: "Save",
  Auto: "Auto",
  Stop: "Stop",
  Exit: "Exit",
  Automatic: "Automatic",
  Manual: "Manual",
  Remove: "Remove",
  LoadASaveFrom: "Load a save from",
  DeleteASaveFrom: "Delete a save from",
  TextSpeed: "Text Speed",
  TextSpeedSlow: "Slow",
  TextSpeedMedium: "Medium",
  TextSpeedFast: "Fast",
  TextSpeedAuto: "Auto",
  CompleteText: "Complete text",
  GoForward: "Go forward",
  ExitDialogWarning: "Are you sure you want to exit? Progress will be saved.",
  ExitDialogExit: "Exit",
  ExitDialogBack: "Return to game",
  OpenMenu: "Open menu",
  CloseMenu: "Close menu",
  MusicVolume: "Music volume",
  SoundVolume: "Sound volume",
  VoiceVolume: "Voice volume"
};
var KK = {
  NewGame: " ",
  HomeScreen: " ",
  ToTheGame: "",
  Language: "",
  NoSaves: " ",
  LoadSave: "",
  Saves: "",
  Settings: "",
  Sumbit: "",
  GoBack: "",
  DoSave: "",
  Auto: "",
  Stop: "",
  Exit: "",
  Automatic: "",
  Manual: "",
  Remove: "",
  LoadASaveFrom: " ",
  DeleteASaveFrom: " ",
  TextSpeed: " ",
  TextSpeedSlow: "",
  TextSpeedMedium: "",
  TextSpeedFast: "",
  TextSpeedAuto: "",
  CompleteText: " ",
  GoForward: " ",
  ExitDialogWarning: "    ?  ",
  ExitDialogExit: "",
  ExitDialogBack: " ",
  OpenMenu: " ",
  CloseMenu: " ",
  MusicVolume: " ",
  SoundVolume: " ",
  VoiceVolume: " "
};
var JP = {
  NewGame: "",
  HomeScreen: "",
  ToTheGame: "",
  Language: "",
  NoSaves: "",
  LoadSave: "",
  Saves: "",
  Settings: "",
  Sumbit: "",
  GoBack: "",
  DoSave: "",
  Auto: "",
  Stop: "",
  Exit: "",
  Automatic: "",
  Manual: "",
  Remove: "",
  LoadASaveFrom: "",
  DeleteASaveFrom: "",
  TextSpeed: "",
  TextSpeedSlow: "",
  TextSpeedMedium: "",
  TextSpeedFast: "",
  TextSpeedAuto: "",
  CompleteText: "",
  GoForward: "",
  ExitDialogWarning: "",
  ExitDialogExit: "",
  ExitDialogBack: "",
  OpenMenu: "",
  CloseMenu: "",
  MusicVolume: "",
  SoundVolume: "",
  VoiceVolume: ""
};
export {
  EN,
  JP,
  KK,
  RU,
  asset,
  extendAction,
  localStorageStorage,
  novely
};
//# sourceMappingURL=@novely_core.js.map
