{"version":3,"sources":["../src/wait_for_interaction.ts","../src/browser-events.ts","../src/queue.ts","../src/memo.ts","../src/audio.ts"],"sourcesContent":["const waitForInteraction = (() => {\n  const { promise, resolve } = Promise.withResolvers<void>();\n\t\n\tconst onUserInteraction = () => {\n\t\tresolve();\n\t};\n\n\tdocument.addEventListener('touchstart', onUserInteraction, { once: true });\n\tdocument.addEventListener('touchend', onUserInteraction, { once: true });\n\tdocument.addEventListener('click', onUserInteraction, { once: true });\n\tdocument.addEventListener('keydown', onUserInteraction, { once: true });\n\n\treturn () => {\n    return promise;\n  };\n})();\n\nexport { waitForInteraction }","type EventHandler<T> = (this: Document, event: T) => void;\n\ntype BlurEventHandler = EventHandler<Event>;\ntype FocusEventHandler = EventHandler<FocusEvent>;\n\nconst BLUR_HANDLERS = new Set<BlurEventHandler>();\nconst FOCUS_HANDLERS = new Set<FocusEventHandler>();\n\ntype EventListeners = {\n  focus: FocusEventHandler;\n  blur: BlurEventHandler;\n}\n\nconst registerEventListeners = (listeners: EventListeners) => {\n  BLUR_HANDLERS.add(listeners.blur);\n  FOCUS_HANDLERS.add(listeners.focus);\n\n  return () => {\n    BLUR_HANDLERS.delete(listeners.blur);\n    FOCUS_HANDLERS.delete(listeners.focus);\n  }\n}\n\naddEventListener('focus', function (event) {\n  for (const handler of FOCUS_HANDLERS) {\n    try {\n      handler.call(this.document, event);\n    } catch {}\n  }\n});\n\naddEventListener('blur', function (event) {\n  for (const handler of BLUR_HANDLERS) {\n    try {\n      handler.call(this.document, event);\n    } catch {}\n  }\n});\n\nexport { registerEventListeners, BLUR_HANDLERS as _BLUR_HANDLERS, FOCUS_HANDLERS as _FOCUS_HANDLERS }\nexport type { EventHandler, BlurEventHandler, FocusEventHandler, EventListeners }","import pLimit from 'p-limit';\n\ntype Thenable<T> = T | Promise<T>;\ntype Queue = (() => Thenable<void>)[]\n\nconst createQueue = (queue: Queue, stopped = false) => {\n  const limit = pLimit(1);\n\n  const run = async () => {\n    const items = queue.slice();\n\n    for await (const item of items) {\n      if (stopped) break;\n\n      try {\n        await item();\n      } catch (error) {\n        console.error(error);\n        \n        /**\n         * In case that exception is handled then stopped will be set manually in catch block\n         * But in other cases stop it here\n         */\n        stopped = true;\n      }\n    }\n\n    queue = queue.filter(item => !items.includes(item));\n    stopped = false;\n  };\n\n  return {\n    get queue() {\n      return queue;\n    },\n    set queue(value) {\n      queue = value;\n    },\n    stop() {\n      stopped = true;\n    },\n    execute: () => {\n      return limit(run);\n    }\n  }\n}\n\nexport { createQueue }\nexport type { Queue }","/**\n * Primitive memo key-based wrapper.\n * \n * This memoization function wraps an asynchronous function and caches its result\n * based on a unique key. If the function has already been called with the same\n * key, the cached result (a promise) will be returned instead of invoking the\n * function again.\n * \n * @warning\n * This cache implementation does not handle promise rejections. If the provided\n * function's promise is rejected, the rejection will be cached, and any subsequent\n * calls with the same key will return the same rejected promise.\n */\nconst createMemo = <T>() => {\n  const cache = new Map<string, Promise<T>>()\n\n  return (key: string, fn: () => Promise<T>) => {\n    return () => {\n      const preserved = cache.get(key);\n\n      if (preserved) {\n        return preserved;\n      }\n\n      const promise = fn();\n\n      cache.set(key, promise);\n\n      return promise;\n    }\n  }\n}\n\nexport { createMemo }","import type { AudioInstance } from \"./types\";\nimport { waitForInteraction } from \"./wait_for_interaction\";\nimport { registerEventListeners } from './browser-events';\nimport { createQueue } from './queue';\nimport { createMemo } from './memo';\n\nconst fetcherMemo = createMemo<ArrayBuffer>();\nconst decoderMemo = createMemo<AudioBuffer>();\n\ntype ExtendAudioGraphOptions = {\n  context: AudioContext;\n  node: GainNode;\n}\n\ntype AudioNodeLike = {\n  connect: ((destinationNode: AudioNode) => void);\n}\n\ntype ExtendAudioGraph = (options: ExtendAudioGraphOptions) => AudioNode | AudioNodeLike;\n\ntype AudioOptions = {\n  /**\n   * Source\n   */\n  src: string;\n  /**\n   * Loop\n   * @default false\n   */\n  loop?: boolean;\n  /**\n   * Volume\n   * @default 1\n   */\n  volume?: number;\n  /**\n   * Will pause playing on blur event, play on focus.\n   * @default false\n   */\n  pauseOnBlur?: boolean;\n  /**\n   * @default false\n   */\n  autoplay?: boolean;\n  /**\n   * Function to extend audio \"graph\"\n   */\n  extendAudioGraph?: ExtendAudioGraph;\n};\n\nconst createAudio = (options: AudioOptions) => {\n  let audioContext: AudioContext;\n  let gainNode: GainNode;\n  let bufferSource: AudioBufferSourceNode;\n  let arrayBuffer: ArrayBuffer;\n  let audioBuffer: AudioBuffer;\n\n  /**\n   * Values that pending it's queue to be set\n   */\n  let pendingVolume = options.volume || 1;\n  let pendingLoop = options.loop || false;\n\n  const createAudioContext = () => {\n    audioContext = new AudioContext()\n  }\n\n  const getGainNode = () => {\n    return gainNode;\n  }\n\n  const createGainNode = () => {\n    gainNode = audioContext.createGain();\n\n    const node = (options.extendAudioGraph || getGainNode)({\n      context: audioContext,\n      node: gainNode\n    });\n\n    node.connect(audioContext.destination);\n  }\n\n  const createBufferSource = () => {\n    bufferSource = audioContext.createBufferSource();\n  }\n\n  const interruptQueueThenDestroy = (cause: Error | unknown) => {\n    /**\n     * Firstly prevent next queue items from running because they depend on previous items\n     * Then destroy audio because there is no reason to try run it over and over again\n     */\n    queue.stop();\n    instance.destroy();\n\n    return new Error('', { cause });\n  }\n\n  const fetchArrayBuffer = fetcherMemo(options.src, async () => {\n    try {\n      return await fetch(options.src).then(response => response.arrayBuffer());\n    } catch (error) {\n      throw interruptQueueThenDestroy(error);\n    }\n  });\n\n  const setArrayBuffer = async () => {\n    arrayBuffer = await fetchArrayBuffer();\n  }\n\n  const decodeAudioData = decoderMemo(options.src, async () => {\n    try {\n      return await audioContext.decodeAudioData(arrayBuffer);\n    } catch (error) {\n      throw interruptQueueThenDestroy(error);\n    }\n  })\n\n  const setAudioData = async () => {\n    audioBuffer = await decodeAudioData();\n  }\n\n  const connectSources = () => {\n    if (bufferSource && bufferSource.buffer === null) {\n      bufferSource.buffer = audioBuffer;\n      bufferSource.connect(gainNode);\n    }\n  }\n\n  const setVolume = () => {\n    gainNode.gain.value = pendingVolume;\n  }\n\n  const setLoop = () => {\n    bufferSource.loop = pendingLoop;\n  }\n\n  const queue = createQueue([\n    waitForInteraction,\n    createAudioContext,\n    createGainNode,\n    setVolume,\n    createBufferSource,\n    setLoop,\n    fetchArrayBuffer,\n    setArrayBuffer,\n    decodeAudioData,\n    setAudioData,\n    connectSources,\n  ]);\n\n  /**\n   * Will resume when focus or not\n   */\n  let resume = false;\n\n  const unregister = registerEventListeners({\n    focus: () => {\n      if (!options.pauseOnBlur || !resume || state.destroyed) return;\n\n      resume = false;\n\n      queue.queue.push(playAudio);\n      queue.execute()\n    },\n    blur: () => {\n      if (!options.pauseOnBlur || !state.playing || state.destroyed) return;\n\n      resume = true;\n\n      queue.queue.push(pauseAudio);\n      queue.execute()\n    }\n  });\n\n  const state = {\n    started: false,\n    playing: false,\n    destroyed: false\n  };\n\n  const playAudio = async () => {\n    if (state.destroyed) return;\n\n    if (audioContext.state === \"suspended\") {\n      await audioContext.resume();\n\n      if (state.started) {\n        state.playing = true;\n      }\n    }\n\n    if (!state.started) {\n      bufferSource.start();\n\n      state.started = true;\n      state.playing = true;\n    }\n  }\n\n  const pauseAudio = async () => {\n    if (state.destroyed) return;\n    \n    if (audioContext.state === \"suspended\" && queue.queue.at(-1) === playAudio) {\n      queue.queue.pop();\n    }\n\n    if (audioContext.state === \"running\") {\n      await audioContext.suspend();\n\n      state.playing = false;\n    }\n  }\n\n  const disconnectAudio = async () => {\n    bufferSource && bufferSource.disconnect();\n\n    /**\n     * Reset `started` value\n     * That will make `source.start()` call when `play()` will be called\n     */\n    state.started = false;\n  }\n\n  const instance = {\n    async play() {\n      if (state.destroyed) return;\n      \n      queue.queue.push(playAudio);\n\n      return queue.execute();\n    },\n    async pause() {\n      if (state.destroyed) return;\n      \n      queue.queue.push(pauseAudio);\n\n      return queue.execute();\n    },\n    async reset() {\n      if (state.destroyed) return;\n\n      if (state.playing) {\n        queue.queue.push(pauseAudio)\n      }\n\n      queue.queue.push(\n        disconnectAudio,\n        createBufferSource,\n        setLoop,\n        connectSources\n      );\n\n      if (state.playing) {\n        queue.queue.push(playAudio)\n      }\n\n      return queue.execute();\n    },\n    async stop() {\n      if (state.destroyed) return;\n\n      queue.queue.push(\n        pauseAudio,\n        disconnectAudio,\n        createBufferSource,\n        setLoop,\n        connectSources\n      );\n\n      return queue.execute();\n    },\n    async destroy() {\n      if (state.destroyed) return;\n\n      unregister();\n\n      queue.queue = [\n        pauseAudio,\n        disconnectAudio\n      ];\n\n      await queue.execute();\n\n      state.destroyed = true;\n\n      // @ts-expect-error\n      audioContext = null;\n      // @ts-expect-error\n      gainNode = null;\n      // @ts-expect-error\n      bufferSource = null;\n      // @ts-expect-error\n      arrayBuffer = null;\n      // @ts-expect-error\n      audioBuffer = null;\n    },\n    async fetch() {\n      if (state.destroyed) return;\n\n      await fetchArrayBuffer();\n    },\n    get playing() {\n      return state.playing;\n    },\n    get destroyed() {\n      return state.destroyed;\n    },\n    get volume() {\n      return pendingVolume;\n    },\n    set volume(value) {\n      if (state.destroyed) return;\n\n      pendingVolume = value;\n      queue.queue.push(setVolume);\n      queue.execute()\n    },\n    get loop() {\n      return pendingLoop;\n    },\n    set loop(value) {\n      if (state.destroyed) return;\n     \n      pendingLoop = value;\n      queue.queue.push(setLoop);\n      queue.execute()\n    }\n  } satisfies AudioInstance;\n\n  if (options.autoplay) {\n    queue.queue.push(playAudio)\n    queue.execute()\n  }\n\n  return instance;\n};\n\nconst prefetchAudio = (src: string) => {\n  const fetcher = fetcherMemo(src, () => fetch(src).then(res => res.arrayBuffer()));\n\n  return fetcher();\n}\n\nexport { prefetchAudio, createAudio };\nexport type { AudioOptions }"],"mappings":"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","names":[]}