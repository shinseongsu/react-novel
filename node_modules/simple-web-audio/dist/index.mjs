// src/wait_for_interaction.ts
var waitForInteraction = (() => {
  const { promise, resolve } = Promise.withResolvers();
  const onUserInteraction = () => {
    resolve();
  };
  document.addEventListener("touchstart", onUserInteraction, { once: true });
  document.addEventListener("touchend", onUserInteraction, { once: true });
  document.addEventListener("click", onUserInteraction, { once: true });
  document.addEventListener("keydown", onUserInteraction, { once: true });
  return () => {
    return promise;
  };
})();

// src/browser-events.ts
var BLUR_HANDLERS = /* @__PURE__ */ new Set();
var FOCUS_HANDLERS = /* @__PURE__ */ new Set();
var registerEventListeners = (listeners) => {
  BLUR_HANDLERS.add(listeners.blur);
  FOCUS_HANDLERS.add(listeners.focus);
  return () => {
    BLUR_HANDLERS.delete(listeners.blur);
    FOCUS_HANDLERS.delete(listeners.focus);
  };
};
addEventListener("focus", function(event) {
  for (const handler of FOCUS_HANDLERS) {
    try {
      handler.call(this.document, event);
    } catch {
    }
  }
});
addEventListener("blur", function(event) {
  for (const handler of BLUR_HANDLERS) {
    try {
      handler.call(this.document, event);
    } catch {
    }
  }
});

// src/queue.ts
import pLimit from "p-limit";
var createQueue = (queue, stopped = false) => {
  const limit = pLimit(1);
  const run = async () => {
    const items = queue.slice();
    for await (const item of items) {
      if (stopped) break;
      try {
        await item();
      } catch (error) {
        console.error(error);
        stopped = true;
      }
    }
    queue = queue.filter((item) => !items.includes(item));
    stopped = false;
  };
  return {
    get queue() {
      return queue;
    },
    set queue(value) {
      queue = value;
    },
    stop() {
      stopped = true;
    },
    execute: () => {
      return limit(run);
    }
  };
};

// src/memo.ts
var createMemo = () => {
  const cache = /* @__PURE__ */ new Map();
  return (key, fn) => {
    return () => {
      const preserved = cache.get(key);
      if (preserved) {
        return preserved;
      }
      const promise = fn();
      cache.set(key, promise);
      return promise;
    };
  };
};

// src/audio.ts
var fetcherMemo = createMemo();
var decoderMemo = createMemo();
var createAudio = (options) => {
  let audioContext;
  let gainNode;
  let bufferSource;
  let arrayBuffer;
  let audioBuffer;
  let pendingVolume = options.volume || 1;
  let pendingLoop = options.loop || false;
  const createAudioContext = () => {
    audioContext = new AudioContext();
  };
  const getGainNode = () => {
    return gainNode;
  };
  const createGainNode = () => {
    gainNode = audioContext.createGain();
    const node = (options.extendAudioGraph || getGainNode)({
      context: audioContext,
      node: gainNode
    });
    node.connect(audioContext.destination);
  };
  const createBufferSource = () => {
    bufferSource = audioContext.createBufferSource();
  };
  const interruptQueueThenDestroy = (cause) => {
    queue.stop();
    instance.destroy();
    return new Error("", { cause });
  };
  const fetchArrayBuffer = fetcherMemo(options.src, async () => {
    try {
      return await fetch(options.src).then((response) => response.arrayBuffer());
    } catch (error) {
      throw interruptQueueThenDestroy(error);
    }
  });
  const setArrayBuffer = async () => {
    arrayBuffer = await fetchArrayBuffer();
  };
  const decodeAudioData = decoderMemo(options.src, async () => {
    try {
      return await audioContext.decodeAudioData(arrayBuffer);
    } catch (error) {
      throw interruptQueueThenDestroy(error);
    }
  });
  const setAudioData = async () => {
    audioBuffer = await decodeAudioData();
  };
  const connectSources = () => {
    if (bufferSource && bufferSource.buffer === null) {
      bufferSource.buffer = audioBuffer;
      bufferSource.connect(gainNode);
    }
  };
  const setVolume = () => {
    gainNode.gain.value = pendingVolume;
  };
  const setLoop = () => {
    bufferSource.loop = pendingLoop;
  };
  const queue = createQueue([
    waitForInteraction,
    createAudioContext,
    createGainNode,
    setVolume,
    createBufferSource,
    setLoop,
    fetchArrayBuffer,
    setArrayBuffer,
    decodeAudioData,
    setAudioData,
    connectSources
  ]);
  let resume = false;
  const unregister = registerEventListeners({
    focus: () => {
      if (!options.pauseOnBlur || !resume || state.destroyed) return;
      resume = false;
      queue.queue.push(playAudio);
      queue.execute();
    },
    blur: () => {
      if (!options.pauseOnBlur || !state.playing || state.destroyed) return;
      resume = true;
      queue.queue.push(pauseAudio);
      queue.execute();
    }
  });
  const state = {
    started: false,
    playing: false,
    destroyed: false
  };
  const playAudio = async () => {
    if (state.destroyed) return;
    if (audioContext.state === "suspended") {
      await audioContext.resume();
      if (state.started) {
        state.playing = true;
      }
    }
    if (!state.started) {
      bufferSource.start();
      state.started = true;
      state.playing = true;
    }
  };
  const pauseAudio = async () => {
    if (state.destroyed) return;
    if (audioContext.state === "suspended" && queue.queue.at(-1) === playAudio) {
      queue.queue.pop();
    }
    if (audioContext.state === "running") {
      await audioContext.suspend();
      state.playing = false;
    }
  };
  const disconnectAudio = async () => {
    bufferSource && bufferSource.disconnect();
    state.started = false;
  };
  const instance = {
    async play() {
      if (state.destroyed) return;
      queue.queue.push(playAudio);
      return queue.execute();
    },
    async pause() {
      if (state.destroyed) return;
      queue.queue.push(pauseAudio);
      return queue.execute();
    },
    async reset() {
      if (state.destroyed) return;
      if (state.playing) {
        queue.queue.push(pauseAudio);
      }
      queue.queue.push(
        disconnectAudio,
        createBufferSource,
        setLoop,
        connectSources
      );
      if (state.playing) {
        queue.queue.push(playAudio);
      }
      return queue.execute();
    },
    async stop() {
      if (state.destroyed) return;
      queue.queue.push(
        pauseAudio,
        disconnectAudio,
        createBufferSource,
        setLoop,
        connectSources
      );
      return queue.execute();
    },
    async destroy() {
      if (state.destroyed) return;
      unregister();
      queue.queue = [
        pauseAudio,
        disconnectAudio
      ];
      await queue.execute();
      state.destroyed = true;
      audioContext = null;
      gainNode = null;
      bufferSource = null;
      arrayBuffer = null;
      audioBuffer = null;
    },
    async fetch() {
      if (state.destroyed) return;
      await fetchArrayBuffer();
    },
    get playing() {
      return state.playing;
    },
    get destroyed() {
      return state.destroyed;
    },
    get volume() {
      return pendingVolume;
    },
    set volume(value) {
      if (state.destroyed) return;
      pendingVolume = value;
      queue.queue.push(setVolume);
      queue.execute();
    },
    get loop() {
      return pendingLoop;
    },
    set loop(value) {
      if (state.destroyed) return;
      pendingLoop = value;
      queue.queue.push(setLoop);
      queue.execute();
    }
  };
  if (options.autoplay) {
    queue.queue.push(playAudio);
    queue.execute();
  }
  return instance;
};
var prefetchAudio = (src) => {
  const fetcher = fetcherMemo(src, () => fetch(src).then((res) => res.arrayBuffer()));
  return fetcher();
};
export {
  createAudio,
  prefetchAudio,
  waitForInteraction
};
//# sourceMappingURL=index.mjs.map